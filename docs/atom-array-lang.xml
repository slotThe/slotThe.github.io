<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Tony Zorman Â· Blog</title>
    <link href="https://tony-zorman.com/atom-array-lang.xml" rel="self" />
    <link href="https://tony-zorman.com" />
    <id>https://tony-zorman.com/atom-array-lang.xml</id>
    <author>
        <name>Tony Zorman</name>
        
        <email>mail@tony-zorman.com</email>
        
    </author>
    <updated>2026-01-11T00:00:00Z</updated>
    <entry>
    <title>The J Incunabulum</title>
    <link href="https://tony-zorman.com/posts/j-incunabulum.html" />
    <id>https://tony-zorman.com/posts/j-incunabulum.html</id>
    <published>2026-01-11T00:00:00Z</published>
    <updated>2026-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <div class="header">
      11th Jan 2026
      
        &nbsp;&nbsp;Â·&nbsp;&nbsp;&nbsp;<span title="1992 words">8 min read</span>&nbsp;&nbsp;&nbsp;Â·&nbsp;&nbsp;
      
      
        <a title="All pages tagged '#c'." href="/tags/c.html" rel="tag">#c</a>Â Â Â <a title="All pages tagged '#j'." href="/tags/j.html" rel="tag">#j</a>Â Â Â <a title="All pages tagged '#array-lang'." href="/tags/array-lang.html" rel="tag">#array-lang</a>
      
    </div>
    <h1 class="post-title">The J Incunabulum</h1>
    <div id="title-underline"></div>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  

<div class="fullwidth">
<p>Ever wanted to find out what
<a href="https://code.jsoftware.com/wiki/Essays/Incunabulum">that one page</a>
of totally cryptic C is all about?</p>
</div>
<!--more-->
<div class="fullwidth">
<p>While Iâ€™m waiting for <em>current disastrous weather event</em> to clear up, why not do something fun,
like trying to understand an interpreter for a line-noise language that someone wrote in a different kind of line-noise language almost 40 years ago?</p>
<p>If youâ€™re out of the loop:
the <a href="https://code.jsoftware.com/wiki/Essays/Incunabulum">J Incunabulum</a>
is a one-page interpreter for the <a href="https://www.jsoftware.com/">J</a> programming language,
written in ~1989 by <a href="https://en.wikipedia.org/wiki/Arthur_Whitney_(computer_scientist)">Arthur Whitney</a>,
of <a href="https://en.wikipedia.org/wiki/K_(programming_language)">k</a>
and <a href="https://en.wikipedia.org/wiki/Q_(programming_language_from_Kx_Systems)">q</a> fame.</p>
<p>Note that this post is a bit of an experiment, in various ways.
The most visually striking might be that Iâ€™m trying out a semi-experimental two-column layout for displaying code on the right,
and some hopefully enlightening commentary on the left.
This is probably completely broken if you view this post in an RSS viewer, or on a phone,
with the best-case being that you just experience this as a normal, linear, post.
Sorry about that.
If you notice any CSS irregularities because youâ€™re using a vertical monitor with a 1504Ã—2256 resolution or something,
please <a href="https://tony-zorman.com/about.html">let me know</a>.</p>
</div>
<hr />
<div class="fullwidth">
<p>So, the goal for today is to understand an interpreter for a tiny array-style programming language.
Note that all of the names and explanations Iâ€™ll come up with are probably slightly incorrect.
I donâ€™t know how Arthur Whitney thinks, nor am I sure that the names all fit.
Plus, I donâ€™t actually know C, so it may well be true that I messed up some of the casts,
and the original program actually worked slightly differently.
Consult at your own risk.</p>
<p>Further, this is not the minimal number of changes to get this to
compile on a modern machineâ€”for example, I switched to ANSI C function
definitionsâ€”, but it helped me better understand whatâ€™s going on.
Hereâ€™s the minimal set of changes to <a href="https://code.jsoftware.com/wiki/Essays/Incunabulum">the original</a> Iâ€™ve found to work:</p>
<details>
<summary>
Diff
</summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -1,11 +1,11 @@</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="st">-typedef char C;typedef long I;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="va">+typedef char C;typedef long long I;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> typedef struct a{I t,r,d[3],p[2];}*A;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> #define P printf</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> #define R return</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> #define V1(f) A f(w)A w;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> #define V2(f) A f(a,w)A a,w;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> #define DO(n,x) {I i=0,_n=(n);for(;i&lt;_n;++i){x;}}</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">-I *ma(n){R(I*)malloc(n*4);}mv(d,s,n)I *d,*s;{DO(n,d[i]=s[i]);}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="va">+I *ma(n){R(I*)malloc(n*8);}mv(d,s,n)I *d,*s;{DO(n,d[i]=s[i]);}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> tr(r,d)I *d;{I z=1;DO(r,z=z*d[i]);R z;}</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> A ga(t,r,d)I *d;{A z=(A)ma(5+tr(r,d));z-&gt;t=t,z-&gt;r=r,mv(z-&gt;d,d,r);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  R z;}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -34,8 +34,8 @@</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> A ex(e)I *e;{I a=*e;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  if(qp(a)){if(e[1]=='=')R st[a-'a']=ex(e+2);a= st[ a-'a'];}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  R qv(a)?(*vm[a])(ex(e+1)):e[1]?(*vd[e[1]])(a,ex(e+2)):(A)a;}</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="st">-noun(c){A z;if(c&lt;'0'||c&gt;'9')R 0;z=ga(0,0,0);*z-&gt;p=c-'0';R z;}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="st">-verb(c){I i=0;for(;vt[i];)if(vt[i++]==c)R i;R 0;}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="va">+I noun(c){A z;if(c&lt;'0'||c&gt;'9')R 0;z=ga(0,0,0);*z-&gt;p=c-'0';R z;}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="va">+I verb(c){I i=0;for(;vt[i];)if(vt[i++]==c)R i;R 0;}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> I *wd(s)C *s;{I a,n=strlen(s),*e=ma(n+1);C c;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  DO(n,e[i]=(a=noun(c=s[i]))?a:(a=verb(c))?a:c);e[n]=0;R e;}</span></code></pre></div>
</details>
<p>Anyways, letâ€™s crack on.</p>
</div>
<hr />
<h2 id="the-array-type">The array type</h2>
<p>We first include some libraries, which were apparently implicit in the original thing.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span></code></pre></div>
<p>The next three definitions are just utility functions:
<code>P</code> and <code>R</code> are to make the code even terser,
and <code>DO</code> is a neat way to compactify loops.
For example, given some <code>int a=0</code>, then <code>DO(n,a+=i)</code> is the same as <code>for(int i=0, i&lt;n, ++i) a+=i;</code>.
Notice how the argument <code>x</code> has access to the loop variable <code>i</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define P printf</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define R </span><span class="cf">return</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DO</span><span class="op">(</span><span class="pp">n</span><span class="op">,</span><span class="pp">x</span><span class="op">)</span><span class="pp"> </span><span class="op">{</span><span class="pp">I _n</span><span class="op">=(</span><span class="pp">n</span><span class="op">),</span><span class="pp">i</span><span class="op">=</span><span class="dv">0</span><span class="op">;</span><span class="cf">for</span><span class="op">(;</span><span class="pp">i</span><span class="op">&lt;</span><span class="pp">_n</span><span class="op">;++</span><span class="pp">i</span><span class="op">){</span><span class="pp">x</span><span class="op">;}}</span></span></code></pre></div>
<p>Next, some typedefs. <code>C</code> for <code>char</code>, <code>V</code> for <code>void</code> (added by me), and <code>long long</code> for <code>I</code>.
The last definition is particularly important,
as <code>I</code> will serve as an opaque type for some of the program:
it could either hold a character, an actual number (in which case itâ€™s seen as an index into an array of function pointers),
or a pointer to an array (this includes numbers as <a href="https://aplwiki.com/wiki/Rank">rank</a> 0 arrays).
The original program was written on a 32-bit machine, so one had <code>typedef long I;</code>,
but on modern systems we need 64-bit integers for this.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">char</span> C<span class="op">;</span> <span class="kw">typedef</span> <span class="dt">void</span> V<span class="op">;</span> <span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> I<span class="op">;</span></span></code></pre></div>
<p>Defining functions works with <code>V1</code> for <a href="https://aplwiki.com/wiki/Monadic_function">monadic</a> <a href="https://aplwiki.com/wiki/Function">verbs</a> (functions in J parlance)
and <code>V2</code> for <a href="https://aplwiki.com/wiki/Dyadic_function">dyadic</a> ones.
Functions defined this way take â€œimplicitâ€ arguments <code>a</code> and <code>w</code>
(or just <code>w</code> in the monadic case).
I guess this is based on APLâ€™s Î± and Ï‰ arguments.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define V1</span><span class="op">(</span><span class="pp">f</span><span class="op">)</span><span class="pp"> A f</span><span class="op">(</span><span class="pp">A w</span><span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define V2</span><span class="op">(</span><span class="pp">f</span><span class="op">)</span><span class="pp"> A f</span><span class="op">(</span><span class="pp">A a</span><span class="op">,</span><span class="pp"> A w</span><span class="op">)</span></span></code></pre></div>
<p>This is the main attractionâ€”the array struct <code>a</code>,
with pointer type <code>A</code>.
It contains the following fields:</p>
<ul>
<li><code>t</code>, the type: this is 0 if the array is unboxed, and 1 if it is <a href="https://aplwiki.com/wiki/Box">boxed</a>.</li>
<li><code>r</code>, the <a href="https://aplwiki.com/wiki/Rank">rank</a>: a number from 0 to 2, indicating the rank of the array
(whether itâ€™s a <a href="https://aplwiki.com/wiki/Scalar">scalar</a>, a <a href="https://aplwiki.com/wiki/Vector">vector</a>, or a <a href="https://aplwiki.com/wiki/Matrix">matrix</a>).</li>
<li><code>d</code>, the dimension(?): the <a href="https://aplwiki.com/wiki/Shape">shape</a> vector of the array; i.e., the number of elements in each dimension.</li>
<li><code>p</code>, the pointer(payload?): a pointer to the rest of the data.
Itâ€™s a <a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>,
but Iâ€™m honestly not sure why itâ€™s not just declared as <code>p[]</code>.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> a<span class="op">{</span>I t<span class="op">,</span>r<span class="op">,</span>d<span class="op">[</span><span class="dv">3</span><span class="op">],</span>p<span class="op">[</span><span class="dv">2</span><span class="op">];}*</span>A<span class="op">;</span></span></code></pre></div>
<p>Now we can define small helpers:
<code>ma</code> allocates an integer array of size <code>n</code> and returns it,
<code>mv</code> moves data from one array to another,
and <code>tr</code> returns the number of elements of an array, given its rank and its dimension vector.
Iâ€™d imagine <code>tr</code> stands for â€œtotal rankâ€ or something similar.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>I<span class="op">*</span>ma<span class="op">(</span>I n<span class="op">){</span>R<span class="op">(</span>I<span class="op">*)</span>malloc<span class="op">(</span>n<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span>I<span class="op">));}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>V mv<span class="op">(</span>I<span class="op">*</span>d<span class="op">,</span>I<span class="op">*</span>s<span class="op">,</span>I n<span class="op">){</span>DO<span class="op">(</span>n<span class="op">,</span>d<span class="op">[</span>i<span class="op">]=</span>s<span class="op">[</span>i<span class="op">]);}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>I tr<span class="op">(</span>I r<span class="op">,</span>I<span class="op">*</span>d<span class="op">){</span>I z<span class="op">=</span><span class="dv">1</span><span class="op">;</span>DO<span class="op">(</span>r<span class="op">,</span>z<span class="op">=</span>z<span class="op">*</span>d<span class="op">[</span>i<span class="op">]);</span>R z<span class="op">;}</span></span></code></pre></div>
<p>The next function is one of the main attractions.
Iâ€™d imagine <code>ga</code> stands for â€œgeneral allocatorâ€ or something in that vein,
and it does exactly what it says on the tin:
it creates a new array <code>z</code>,
allocates the total number of elements needed (<code>tr(r,d)</code>),
plus five spots for <code>t</code>, <code>r</code>, and <code>d</code> itself,
and then copies everything over.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>A ga<span class="op">(</span>I t<span class="op">,</span>I r<span class="op">,</span>I<span class="op">*</span>d<span class="op">){</span>A z<span class="op">={</span><span class="dv">0</span><span class="op">};</span>z<span class="op">=(</span>A<span class="op">)</span>ma<span class="op">(</span><span class="dv">5</span><span class="op">+</span>tr<span class="op">(</span>r<span class="op">,</span>d<span class="op">));</span>z<span class="op">-&gt;</span>t<span class="op">=</span>t<span class="op">,</span>z<span class="op">-&gt;</span>r<span class="op">=</span>r<span class="op">,</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>d<span class="op">,</span>d<span class="op">,</span>r<span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> R z<span class="op">;}</span></span></code></pre></div>
<h2 id="verbs">Verbs</h2>
<p>Now, we get to defining some <a href="https://aplwiki.com/wiki/Function">verbs</a>.
The easiest to understand is surely the not-implemented <code>find</code>!
But <code>id</code> is a close second.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>V2<span class="op">(</span>find<span class="op">){}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>V1<span class="op">(</span>id<span class="op">){</span>R w<span class="op">;}</span> <span class="co">/* expands to A id(A w){return w;} */</span></span></code></pre></div>
<p>The <a href="https://aplwiki.com/wiki/Index_Generator">iota</a> verb enumerates the integers from <code>0</code> to one minus its argument (it returns an empty array if given <code>0</code>),
<code>sha</code> returns the <a href="https://aplwiki.com/wiki/Shape">shape</a> vector of the array,
and <code>size</code> returns the length of the first dimension.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>V1<span class="op">(</span>iota<span class="op">){</span>I n<span class="op">=*</span>w<span class="op">-&gt;</span>p<span class="op">;</span>A z<span class="op">=</span>ga<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,&amp;</span>n<span class="op">);</span>DO<span class="op">(</span>n<span class="op">,</span>z<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]=</span>i<span class="op">);</span>R z<span class="op">;}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>V1<span class="op">(</span>sha<span class="op">){</span>A z<span class="op">=</span>ga<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,&amp;</span>w<span class="op">-&gt;</span>r<span class="op">);</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">,</span>w<span class="op">-&gt;</span>d<span class="op">,</span>w<span class="op">-&gt;</span>r<span class="op">);</span>R z<span class="op">;}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>V1<span class="op">(</span>size<span class="op">){</span>A z<span class="op">=</span>ga<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">);*</span>z<span class="op">-&gt;</span>p<span class="op">=</span>w<span class="op">-&gt;</span>r<span class="op">?*</span>w<span class="op">-&gt;</span>d<span class="op">:</span><span class="dv">1</span><span class="op">;</span>R z<span class="op">;}</span></span></code></pre></div>
<p>Addition is implemented as one would expect:
allocate a result array with the same shape as the input,
and add corresponding elements.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>V2<span class="op">(</span>plus<span class="op">){</span>I r<span class="op">=</span>w<span class="op">-&gt;</span>r<span class="op">,*</span>d<span class="op">=</span>w<span class="op">-&gt;</span>d<span class="op">,</span>n<span class="op">=</span>tr<span class="op">(</span>r<span class="op">,</span>d<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a> A z<span class="op">=</span>ga<span class="op">(</span><span class="dv">0</span><span class="op">,</span>r<span class="op">,</span>d<span class="op">);</span>DO<span class="op">(</span>n<span class="op">,</span>z<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]=</span>a<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]+</span>w<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]);</span>R z<span class="op">;}</span></span></code></pre></div>
<p><a href="https://aplwiki.com/wiki/Catenate">Cat</a> joins two arrays into a single vector,
and <a href="https://aplwiki.com/wiki/Enclose">box</a> wraps an array in a scalar box.
This is, I think, the first instance of abusing <code>I</code> as an opaque type:
notice the cast <code>*z-&gt;p=(I)w</code> to turn the entire given array into the first element of <code>z-&gt;p</code>
(which is an integer array).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>V1<span class="op">(</span>box<span class="op">){</span>A z<span class="op">=</span>ga<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">);*</span>z<span class="op">-&gt;</span>p<span class="op">=(</span>I<span class="op">)</span>w<span class="op">;</span>R z<span class="op">;}</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>V2<span class="op">(</span>cat<span class="op">){</span>I an<span class="op">=</span>tr<span class="op">(</span>a<span class="op">-&gt;</span>r<span class="op">,</span>a<span class="op">-&gt;</span>d<span class="op">),</span>wn<span class="op">=</span>tr<span class="op">(</span>w<span class="op">-&gt;</span>r<span class="op">,</span>w<span class="op">-&gt;</span>d<span class="op">),</span>n<span class="op">=</span>an<span class="op">+</span>wn<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a> A z<span class="op">=</span>ga<span class="op">(</span>w<span class="op">-&gt;</span>t<span class="op">,</span><span class="dv">1</span><span class="op">,&amp;</span>n<span class="op">);</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">,</span>a<span class="op">-&gt;</span>p<span class="op">,</span>an<span class="op">);</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">+</span>an<span class="op">,</span>w<span class="op">-&gt;</span>p<span class="op">,</span>wn<span class="op">);</span>R z<span class="op">;}</span></span></code></pre></div>
<p><a href="https://aplwiki.com/wiki/From">From</a> implements selection.
Given an index <code>a</code> (or an array, in which case only the first value is used) and an array <code>w</code>,
it returns the sub-array at that index.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>V2<span class="op">(</span>from<span class="op">){</span>I r<span class="op">=</span>w<span class="op">-&gt;</span>r<span class="op">-</span><span class="dv">1</span><span class="op">,*</span>d<span class="op">=</span>w<span class="op">-&gt;</span>d<span class="op">+</span><span class="dv">1</span><span class="op">,</span>n<span class="op">=</span>tr<span class="op">(</span>r<span class="op">,</span>d<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a> A z<span class="op">=</span>ga<span class="op">(</span>w<span class="op">-&gt;</span>t<span class="op">,</span>r<span class="op">,</span>d<span class="op">);</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">,</span>w<span class="op">-&gt;</span>p<span class="op">+(</span>n<span class="op">**</span>a<span class="op">-&gt;</span>p<span class="op">),</span>n<span class="op">);</span>R z<span class="op">;}</span></span></code></pre></div>
<p><a href="https://aplwiki.com/wiki/Reshape">Reshape</a> changes the shape of an array.
The left argument specifies the new shape.
The, in my opinion, incredibly cursed last line copies elements cyclically if needed.
We first fill all of <code>w</code> into <code>z</code>,
and then walk two pointers, one ahead of the other by <code>wn</code>, forward <code>n-wn</code> steps,
filling up elements as we go.
Later iterations can already access the ones resulting from earlier memmoves.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>V2<span class="op">(</span>rsh<span class="op">){</span>I r<span class="op">=</span>a<span class="op">-&gt;</span>r<span class="op">?*</span>a<span class="op">-&gt;</span>d<span class="op">:</span><span class="dv">1</span><span class="op">,</span>n<span class="op">=</span>tr<span class="op">(</span>r<span class="op">,</span>a<span class="op">-&gt;</span>p<span class="op">),</span>wn<span class="op">=</span>tr<span class="op">(</span>w<span class="op">-&gt;</span>r<span class="op">,</span>w<span class="op">-&gt;</span>d<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a> A z<span class="op">=</span>ga<span class="op">(</span>w<span class="op">-&gt;</span>t<span class="op">,</span>r<span class="op">,</span>a<span class="op">-&gt;</span>p<span class="op">);</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">,</span>w<span class="op">-&gt;</span>p<span class="op">,</span>wn<span class="op">=</span>n<span class="op">&gt;</span>wn<span class="op">?</span>wn<span class="op">:</span>n<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span><span class="op">(</span>n<span class="op">-=</span>wn<span class="op">)</span>mv<span class="op">(</span>z<span class="op">-&gt;</span>p<span class="op">+</span>wn<span class="op">,</span>z<span class="op">-&gt;</span>p<span class="op">,</span>n<span class="op">);</span>R z<span class="op">;}</span></span></code></pre></div>
<h2 id="the-repl">The REPL</h2>
<p>The main part of the program is a small REPL.
It reads a line, calls <code>wd</code> (word) to parse it,
then executes it with <code>ex</code>,
and finally pretty-prints it with <code>pr</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span>C s<span class="op">[</span><span class="dv">99</span><span class="op">];</span><span class="cf">while</span><span class="op">(</span>fgets<span class="op">(</span>s<span class="op">,</span><span class="dv">99</span><span class="op">,</span>stdin<span class="op">)){</span>pr<span class="op">(</span>ex<span class="op">(</span>wd<span class="op">(</span>s<span class="op">,</span>strlen<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span><span class="op">)));}}</span></span></code></pre></div>
<h3 id="parsing">Parsing</h3>
<p>Letâ€™s first define the verb table <code>vt</code>,
giving names to the functions defined above.
There are arrays of function pointers for monadic (<code>vm</code>) and dyadic (<code>vd</code>) verbs;
for example, <code>6#1,2</code> is reshape, <code>&lt;a</code> is box, and so on.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>C vt<span class="op">[]=</span><span class="st">&quot;+{~&lt;#,&quot;</span><span class="op">;</span> <span class="co">/* +    {    ~    &lt;   #   ,    */</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>A<span class="op">(*</span>vd<span class="op">[])(</span>A<span class="op">,</span>A<span class="op">)</span>  <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span>plus<span class="op">,</span>from<span class="op">,</span>find<span class="op">,</span><span class="dv">0</span>  <span class="op">,</span>rsh<span class="op">,</span>cat<span class="op">},</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a> <span class="op">(*</span>vm<span class="op">[])(</span>A<span class="op">)</span>    <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span>id  <span class="op">,</span>size<span class="op">,</span>iota<span class="op">,</span>box<span class="op">,</span>sha<span class="op">,</span><span class="dv">0</span>  <span class="op">};</span></span></code></pre></div>
<p>For parsing we need two small utility functions that check whether the given character is a <a href="https://aplwiki.com/wiki/Array_(syntax)">noun</a> or a verb.
Here, a noun is a number between 0 and 9,
which is then immediately transformed into a rank 0 array, cast to an integer, and returned.
In case of a verb, return the index of it in the <code>vt</code> array incremented by one.
The plus one is due to both functions returning a plain 0 if nothing matches,
so both <code>vd</code> and <code>vm</code> have that as an â€œerror stateâ€.
Note that this is different from inputting a literal 0, which would be transformed into an array.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>I noun<span class="op">(</span>C c<span class="op">){</span>A z<span class="op">;</span><span class="cf">if</span><span class="op">(</span>c<span class="op">&lt;</span><span class="ch">'0'</span><span class="op">||</span>c<span class="op">&gt;</span><span class="ch">'9'</span><span class="op">)</span>R <span class="dv">0</span><span class="op">;</span>z<span class="op">=</span>ga<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">);*</span>z<span class="op">-&gt;</span>p<span class="op">=</span>c<span class="op">-</span><span class="ch">'0'</span><span class="op">;</span>R<span class="op">(</span>I<span class="op">)</span>z<span class="op">;}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>I verb<span class="op">(</span>C c<span class="op">){</span>I i<span class="op">=</span><span class="dv">0</span><span class="op">;</span><span class="cf">for</span><span class="op">(;</span>vt<span class="op">[</span>i<span class="op">];)</span><span class="cf">if</span><span class="op">(</span>vt<span class="op">[</span>i<span class="op">++]==</span>c<span class="op">)</span>R i<span class="op">;</span>R <span class="dv">0</span><span class="op">;}</span></span></code></pre></div>
<p>Parsing is done character by character,
exactly as one would expect: allocate an integer array <code>e</code>,
check if each character is a noun or a verb,
and store the result back into <code>e</code>.
If it is neither, just store the characterâ€™s value.
The <code>x = cond1 ? y : cond2 ? z : w</code>-type ternary operator chaining is a classic for Whitney-style programs.
Make of that what you will.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>I<span class="op">*</span>wd<span class="op">(</span>C<span class="op">*</span>s<span class="op">,</span>I n<span class="op">){</span>I a<span class="op">,*</span>e<span class="op">=</span>ma<span class="op">(</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span>C c<span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  DO<span class="op">(</span>n<span class="op">,</span>e<span class="op">[</span>i<span class="op">]=(</span>a<span class="op">=</span>noun<span class="op">(</span>c<span class="op">=</span>s<span class="op">[</span>i<span class="op">]))?</span>a<span class="op">:(</span>a<span class="op">=</span>verb<span class="op">(</span>c<span class="op">))?</span>a<span class="op">:</span>c<span class="op">);</span>e<span class="op">[</span>n<span class="op">]=</span><span class="dv">0</span><span class="op">;</span>R e<span class="op">;}</span></span></code></pre></div>
<h3 id="execution">Execution</h3>
<p>Onto execution.
Thereâ€™s enough memory for 26 variables, <code>a</code> to <code>z</code>, which are stored in the <code>st</code> array.
Executionâ€”like parsingâ€”is done character by character.
There are two queries that will be important here:
with <code>qp</code> one can ask whether the character is a letter,
and <code>qv</code> checks if itâ€™s a verb (all of the symbols <code>+{~&lt;#,</code> have an ASCII value less than <code>a</code>).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>A st<span class="op">[</span><span class="dv">26</span><span class="op">];</span> I qp<span class="op">(</span>I a<span class="op">){</span>R a<span class="op">&gt;=</span><span class="ch">'a'</span><span class="op">&amp;&amp;</span>a<span class="op">&lt;=</span><span class="ch">'z'</span><span class="op">;}</span> I qv<span class="op">(</span>I a<span class="op">){</span>R a<span class="op">&lt;</span><span class="ch">'a'</span><span class="op">;}</span></span></code></pre></div>
<p>Execution itself is done right-to-left,
using a recursive descent approach.
If the currently scrutinised character is a letter,
and is followed by an equals sign, then we execute whatever is to the right of that equals sign,
store the information in <code>st</code>, and return.
Otherwise, whatever value happens to be in <code>st</code> for that letter is cast to an integer and stored in <code>a</code>.
Now <code>a</code> either points to a character in the input,
is an actual integer (in which case itâ€™s an index into the <code>vm</code> or <code>vd</code> arrays),
or is a pointer to an array.
Next, we check if <code>a</code> is a verb;
if it is, then it must be a monadic one,
so we call the corresponding function pointer with the result of first evaluating its argument.
If <code>a</code> is not a verb, we check if there is anything to its right.
If yes, this thing to its right must be a dyadic function,
so we call that dyadic function with its left argument <code>a</code>â€”which is already evaluated, and we now know must be an arrayâ€”, and with the array its right argument evaluates to.
If none of those conditions match, <code>a</code> must be a lone array that is already fully evaluated, so return that.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>A ex<span class="op">(</span>I<span class="op">*</span>e<span class="op">){</span>I a<span class="op">=*</span>e<span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>qp<span class="op">(</span>a<span class="op">)){</span><span class="cf">if</span><span class="op">(</span>e<span class="op">[</span><span class="dv">1</span><span class="op">]==</span><span class="ch">'='</span><span class="op">)</span>R st<span class="op">[</span>a<span class="op">-</span><span class="ch">'a'</span><span class="op">]=</span>ex<span class="op">(</span>e<span class="op">+</span><span class="dv">2</span><span class="op">);</span> a<span class="op">=(</span>I<span class="op">)</span>st<span class="op">[</span>a<span class="op">-</span><span class="ch">'a'</span><span class="op">];}</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  R qv<span class="op">(</span>a<span class="op">)?(*</span>vm<span class="op">[</span>a<span class="op">])(</span>ex<span class="op">(</span>e<span class="op">+</span><span class="dv">1</span><span class="op">)):</span>e<span class="op">[</span><span class="dv">1</span><span class="op">]?(*</span>vd<span class="op">[</span>e<span class="op">[</span><span class="dv">1</span><span class="op">]])((</span>A<span class="op">)</span>a<span class="op">,</span>ex<span class="op">(</span>e<span class="op">+</span><span class="dv">2</span><span class="op">)):(</span>A<span class="op">)</span>a<span class="op">;}</span></span></code></pre></div>
<h3 id="pretty-printing">Pretty printing</h3>
<p><code>pi</code> prints an integer, and <code>nl</code> prints a newline.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>V pi<span class="op">(</span>I i<span class="op">){</span>P<span class="op">(</span><span class="st">&quot;</span><span class="sc">%lld</span><span class="st"> &quot;</span><span class="op">,</span>i<span class="op">);}</span> V nl<span class="op">(){</span>P<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);}</span></span></code></pre></div>
<p>The main pretty-printing function is <code>pr</code>.
The first line prints the shape vector of the given array.
The second line checks whether the array is boxed;
if itâ€™s not, then it just prints the array as a flat listâ€”hence the shape information in the first line, I suppose.
If it is a boxed array, we indicate that with <code>&lt;</code>, and recurse.
Here we dangerously reinterpret the integer thatâ€™s stored in each <code>w-&gt;p[i]</code> as a pointer to an array.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>V pr<span class="op">(</span>A w<span class="op">){</span>I r<span class="op">=</span>w<span class="op">-&gt;</span>r<span class="op">,*</span>d<span class="op">=</span>w<span class="op">-&gt;</span>d<span class="op">,</span>n<span class="op">=</span>tr<span class="op">(</span>r<span class="op">,</span>d<span class="op">);</span>DO<span class="op">(</span>r<span class="op">,</span>pi<span class="op">(</span>d<span class="op">[</span>i<span class="op">]));</span>nl<span class="op">();</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span><span class="op">(</span>w<span class="op">-&gt;</span>t<span class="op">)</span>DO<span class="op">(</span>n<span class="op">,</span>P<span class="op">(</span><span class="st">&quot;&lt; &quot;</span><span class="op">);</span>pr<span class="op">((</span>A<span class="op">)</span>w<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]))</span><span class="cf">else</span> DO<span class="op">(</span>n<span class="op">,</span>pi<span class="op">(</span>w<span class="op">-&gt;</span>p<span class="op">[</span>i<span class="op">]));</span>nl<span class="op">();}</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Obviously, this code is <em>super</em> brittle and basically segfaults if you look at it wrong.
When holding it just right, however, it does sort of work,
and then it feels a bit magicalâ€”here are the core ideas of an array programming language in barely 40 lines of C.
Plus, it made me feel a bit like a computer science archaeologist.
An afternoon well spent, Iâ€™d say!
If youâ€™re interested in playing with this yourself,
Iâ€™ve pushed everything in this post to a
<a href="https://codeberg.org/slotThe/J-Incunabulum">Codeberg repository</a>.</p>
<pre><code>$ gcc -std=c89 j.c &amp;&amp; ./a.out
    1,2,8,7
4
1 2 8 7
    a=~7
7
0 1 2 3 4 5 6
    a+a
7
0 2 4 6 8 10 12
    b=2,3
2
2 3
    c=b#a
2 3
0 1 2 3 4 5
    a=&lt;1,2,3,4

&lt; 4
1 2 3 4

    b=a,1
2
94660986832144 1</code></pre>

      <!-- Body is included in the above file -->
    </section>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Writing a JSON Parser in BQN</title>
    <link href="https://tony-zorman.com/posts/bqn-json.html" />
    <id>https://tony-zorman.com/posts/bqn-json.html</id>
    <published>2025-10-08T00:00:00Z</published>
    <updated>2025-10-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <div class="header">
      8th Oct 2025â€“18 Oct 2025
      
        &nbsp;&nbsp;Â·&nbsp;&nbsp;&nbsp;<span title="6544 words">27 min read</span>&nbsp;&nbsp;&nbsp;Â·&nbsp;&nbsp;
      
      
        <a title="All pages tagged '#BQN'." href="/tags/BQN.html" rel="tag">#BQN</a>Â Â Â <a title="All pages tagged '#array-lang'." href="/tags/array-lang.html" rel="tag">#array-lang</a>
      
    </div>
    <h1 class="post-title">Writing a JSON Parser in BQN</h1>
    <div id="title-underline"></div>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  

<p>At least, for some vague definition of JSON.<!--more-->
I will restrict myself to the following underspecified subset,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
so that this will not be a 20â€™000-word post:</p>
<ul>
<li>Only (positive) integers.</li>
<li>ASCII only and only <code>\</code>-based escaping.</li>
<li>No constants.</li>
<li>Absolutely no input validationâ€”weâ€™ll try to parse the wildest things.</li>
</ul>
<p>Some of those are not difficult to add:
adding negative integers is a 4-character change,
and other number formats are not much harder.
Constants are a fun exercise for the reader, and also useful for JSON in the wild.
Input validation is not difficult per se,
but seemed a bit too tedious for this blog post to me.
Iâ€™m staying away from Unicode though,
see <a href="https://github.com/mlochbaum/bqn-libs/blob/master/json.bqn">bqn-libs/json.bqn</a> for that.
In general, I do not claim originality for any line of code in this post<!--
-->â€”this is more or less my attempt to understand <a href="https://github.com/mlochbaum/bqn-libs/blob/master/json.bqn">bqn-libs/json.bqn</a> to a reasonable degree.</p>
<p>This article assumes that you are already a bit familiar with BQN as a language,
or know some amount of array programming and are willing to look up unknown symbols.
If not, I recommend starting with the official <a href="https://mlochbaum.github.io/BQN/tutorial/index.html">tutorials</a>.
Iâ€™ve also written about my experience of
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html">using BQN</a>
for Advent of Code,
a post which certainly contains some amount of written words that talk about the language.
Iâ€™ll recall the basic tricks that one uses in array-oriented parsing,
though if you feel like Iâ€™m going too fast perhaps itâ€™s a good idea to peruse my post about writing a
<a href="https://tony-zorman.com/posts/bqn-csv.html">CSV parser</a>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h2 id="lists-of-numbers">Lists of numbers</h2>
<p>Weâ€™ll start with simply trying to parse lists of integers.
Canâ€™t be that hard, right?
Additionally<!--
-->â€”and this is where <em>array-oriented</em> starts to come into playâ€”<!--
-->we want to handle as much as possible using flat arrays.
This is both faster and way cooler.
In particular, this will result in a parser that has essentially no branching to speak of:
everything is just executed in order, line by line.</p>
<p>Motivated by an Advent of Code problem,
<a href="https://saltysylvi.github.io/blog/index.html">Sylvia</a>
has already written a
<a href="https://saltysylvi.github.io/blog/parsing-nested-lists-in-bqn.html">fantastic article</a>
about this exact type of thing,
including a comparison with two other approaches:
recursive descent, as well as a more nested array-style parser.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
I will follow the same approach for this part of the parser;
if youâ€™ve already readâ€”and understoodâ€”Sylviaâ€™s post, feel free to skip to <a href="#adding-strings">Adding strings</a>.</p>
<p>Assume we have a list of numbers like the following:<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<pre class="bqn"><code>    inp â† &quot;[12,34,5,678,910]&quot;
&quot;[12,34,5,678,910]&quot;</code></pre>
<p>Weâ€™ll follow standard practise by first tokenisingâ€”lexingâ€”the string,
and then parsing the tokens.</p>
<h3 id="tokenisation">Tokenisation</h3>
<p>Brackets can stay as they are,
each number will be replaced by a single <code>0</code>,
and thus all commas can be removed.
Weâ€™ll then return a two element array,
the first entry containing the tokenised array,
and the second one being all of the numbers.</p>
<pre class="bqn"><code>    Tokenise inp
âŸ¨ &quot;[00000]&quot; âŸ¨ 12 34 5 678 910 âŸ© âŸ©</code></pre>
<p>The first thing we have to do is to get the start of each number,
and save that in a variable <code>ns</code>,
while a mask of all numbers will be called <code>n</code>.</p>
<pre class="bqn"><code>    '0'+â†•10
&quot;0123456789&quot;
    inpâˆŠ('0'+â†•10)
âŸ¨ 0 1 1 0 1 1 0 1 0 1 1 1 0 1 1 1 0 âŸ©
    Â»âŠ¸&lt; inpâˆŠ('0'+â†•10)
âŸ¨ 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 âŸ©
    ns â† Â»âŠ¸&lt; nâ†inpâˆŠ('0'+â†•10)
âŸ¨ 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 âŸ©
    n         # For comparison
âŸ¨ 0 1 1 0 1 1 0 1 0 1 1 1 0 1 1 1 0 âŸ©
    inp â‰ ns  # Visualise ns by stacking inp on top of it
â”Œâ”€
â•µ '[' '1' '2' ',' '3' '4' ',' '5' ',' '6' '7' '8' ',' '9' '1' '0' ']'
   0   1   0   0   1   0   0   1   0   1   0   0   0   1   0   0   0
                                                                     â”˜</code></pre>
<p>While itâ€™s not immediately obvious,
defining <code>ns</code> is useful because we can create a depth scan of all numbers,
where the start of each new number increases the depth by one.</p>
<pre class="bqn"><code>    +`ns
âŸ¨ 0 1 1 1 2 2 2 3 3 4 4 4 4 5 5 5 5 âŸ©
    inp â‰ +`ns
â”Œâ”€
â•µ '[' '1' '2' ',' '3' '4' ',' '5' ',' '6' '7' '8' ',' '9' '1' '0' ']'
   0   1   1   1   2   2   2   3   3   4   4   4   4   5   5   5   5
                                                                     â”˜</code></pre>
<p>By supplementing this with <code>n</code>,
we obtain sufficient information to <em>group</em> the string!</p>
<pre class="bqn"><code>    nÃ—+`ns                                    # Stencil out the numbers
âŸ¨ 0 1 1 0 2 2 0 3 0 4 4 4 0 5 5 5 0 âŸ©
    1-Ëœ nÃ—+`ns                                # Kill irrelevant part
âŸ¨ Â¯1 0 0 Â¯1 1 1 Â¯1 2 Â¯1 3 3 3 Â¯1 4 4 4 Â¯1 âŸ©
    (1-Ëœ nÃ—+`ns)âŠ”inp                          # Grouping
âŸ¨ &quot;12&quot; &quot;34&quot; &quot;5&quot; &quot;678&quot; &quot;910&quot; âŸ©
    â€¢ParseFloatÂ¨ (1-Ëœ nÃ—+`ns)âŠ”inp             # Parsing
âŸ¨ 12 34 5 678 910 âŸ©
    (10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½-âŸœ'0')Â¨ (1-Ëœ nÃ—+`ns)âŠ”inp       # Or: manual parsing
âŸ¨ 12 34 5 678 910 âŸ©</code></pre>
<p>Now all thatâ€™s left in the tokenisation step
is to create the string <code>"[00000]"</code> from the input.
Since we know all other tokens,
this can be achieved with a combination of <em>replicate</em>, <em>indices</em>, and <em>under</em>:</p>
<pre class="bqn"><code>    ts â† ns âˆ¨ inpâˆŠ&quot;[]&quot;                # Tokens are numbers and brackets
âŸ¨ 1 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 âŸ©
    ts/inp                            # Just the tokens of the string
&quot;[13569]&quot;
    ns/inp                            # Number beginnings
&quot;13569&quot;
    '0'Â¨âŒ¾(nsâŠ¸/)inp                    # Make them zero
&quot;[02,04,0,078,010]&quot;
    ts/'0'Â¨âŒ¾(nsâŠ¸/)inp                 # Choose just the tokens
&quot;[00000]&quot;</code></pre>
<p>Thatâ€™ll do!
We can put all of this into a function now:<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<pre class="bqn"><code>Tokenise â† {
  ns â† Â»âŠ¸&lt; nâ†ğ•©âˆŠ'0'+â†•10           # Number beginnings
  nr â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`ns)âŠ”ğ•© # Numbers to return
  ts â† nsâˆ¨ğ•©âˆŠ&quot;[]&quot;                 # Tokens
  âŸ¨ts/'0'Â¨âŒ¾((/ns)âŠ¸âŠ)ğ•©, nrâŸ©
}</code></pre>
<p>This of course also works with nested lists,
giving us a flat representation in <code>nr</code>:</p>
<pre class="bqn"><code>    Tokenise &quot;[1,[2,[3],4],[5,6]]&quot;
âŸ¨ &quot;[0[0[0]0][00]]&quot; âŸ¨ 1 2 3 4 5 6 âŸ© âŸ©</code></pre>
<p>Using the â€œblueprintâ€ <code>"[0[0[0]0][00]]"</code>,
the main job of the parser will be to turn the flat representation of <code>nr</code> back into a nested list.</p>
<h3 id="parsing">Parsing</h3>
<p>The end result we want looks like this:</p>
<pre class="bqn"><code>    Parse &quot;[1,[2,[3]],4]&quot;
âŸ¨ 1 âŸ¨ 2 âŸ¨ 3 âŸ© âŸ© 4 âŸ©</code></pre>
<p>For this post, letâ€™s define a function to compactly display some text,
so that I can use some more complicated arguments without <em>couple</em> taking up too much space.</p>
<pre class="bqn"><code>    DP â† { ğ•¨â‰'0'+ğ•© }
(function block)
    &quot;abc&quot; DP âŸ¨1,2,3âŸ©
â”Œâ”€
â•µ&quot;abc
  123&quot;
      â”˜</code></pre>
<p>The first thing we need to do is to get a depth ordering of the list;
i.e., make an opening bracket increase and have a closing one decrease the depth by one.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<pre class="bqn"><code>    inpâ†&quot;[1,[2,[3,4]],5,[6,7],8]&quot;
&quot;[1,[2,[3,4]],5,[6,7],8]&quot;
    tsâ€¿nums â† Tokenise inp # Tokens and numbers
âŸ¨ &quot;[0[0[00]]0[00]0]&quot; âŸ¨ 1 2 3 4 5 6 7 8 âŸ© âŸ©
    o â† '['=ts             # Opening brackets
âŸ¨ 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 âŸ©
    c â† ']'=ts             # Closing brackets
âŸ¨ 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 âŸ©
    ts DP +`o-c
â”Œâ”€
â•µ&quot;[0[0[00]]0[00]0]
  1122333211222110&quot;
                   â”˜</code></pre>
<p>We can obtain a depth ordering of the list by turning <code>+`o-c</code> into a permutation with <em>grade up</em>
and then indexing into the tokens with <em>select</em>.</p>
<pre class="bqn"><code>    d â† â‹+`o-c # Depth ordering
âŸ¨ 15 0 1 8 9 13 14 2 3 7 10 11 12 4 5 6 âŸ©
    dâŠts
&quot;][0]0]0[0][00[00&quot;</code></pre>
<p>This is pretty hard to read at first (and even later),
but itâ€™s really nothing more than a breadth-first ordering of the input.
Since <code>inp</code> is defined as <code>"[1,[2,[3,4]],5,[6,7],8]"</code>
and so in particular only contains one-digit numbers,
itâ€™s perhaps more instructive to look at</p>
<pre class="bqn"><code>    dâŠ(','âŠ¸â‰ )âŠ¸/inp
&quot;][1]5]8[2][67[34&quot;</code></pre>
<p>Drawing a picture often helps:</p>
<p>So <code>]</code> indicates that a new sublist be placed at a certain slot,
and <code>[</code> is the start of such a sublist.
Filling in the tree from the string proceeds from left to right,
and every time we encounter a <code>[</code> we look for the â€œoldestâ€ <code>]</code> that still isnâ€™t filled, and start there.</p>
<p>We now assign each sublist the depth in this tree representation.
This works much like the <code>+`o-c</code> trick above,
only we donâ€™t need to care about closing parentheses<!--
-->â€”they only show up when we are going a level deeper anyways.</p>
<pre class="bqn"><code>    '['=dâŠts
âŸ¨ 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 âŸ©
    l â† (â‹d)âŠ+`'['=dâŠts             # Nesting
âŸ¨ 1 1 2 2 4 4 4 2 1 1 3 3 3 1 1 0 âŸ©
    ts DP l
â”Œâ”€
â•µ&quot;[0[0[00]]0[00]0]
  1122444211333110&quot;
                   â”˜</code></pre>
<p>Compare this with the above tree.
One important detail is that we index with <code>â‹d</code> and not just <code>d</code>:
since <code>d</code> is a permutation already, we can invert it with another call to <em>grade up</em>.
This effectively allows us to translate back from the BFS ordering of <code>dâŠts</code>,
into the â€œordinaryâ€ ordering that we started with.</p>
<p>This is a lot to take in;
I would encourage you to play with these ideas for a while, until youâ€™re comfortable with them.</p>
<hr />
<p>Now that we know in which order to fill the sublists,
itâ€™s about time that we figure out which values to use for that very filling.</p>
<pre class="bqn"><code>    ln â† tsâˆŠ&quot;0]&quot;                 # Literals and nesting
âŸ¨ 0 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 âŸ©
    ts DP ln
â”Œâ”€
â•µ&quot;[0[0[00]]0[00]0]
  0101011111011111&quot;
                   â”˜
    (ln/ts='0') + 2Ã—ln/c
âŸ¨ 1 1 1 1 2 2 1 1 1 2 1 2 âŸ©
    vi â† â‹â‹ (ln/ts='0') + 2Ã—ln/c # Value indices
âŸ¨ 0 1 2 3 8 9 4 5 6 10 7 11 âŸ©
    (ln/ts) â‰ vi
â”Œâ”€
â•µ '0' '0' '0' '0' ']' ']' '0' '0' '0' ']' '0' ']'
   0   1   2   3   8   9   4   5   6   10  7   11
                                                  â”˜
    inp
&quot;[1,[2,[3,4]],5,[6,7],8]&quot;</code></pre>
<p>We separate out the literals,
as well as the â€œnesting indicatorâ€ <code>]</code>,
and then produce a list of â€œvalue indicesâ€
that should indicate the order in which the final output is to be filled.
We use the
<a href="https://mlochbaum.github.io/BQN/doc/order.html#ordinals">ordinals pattern</a>
<code>â‹â‹</code> to turn <code>ln</code> into something we can actually use to index into <code>ts</code>.
However, there is a problem:
the filling of the actual literals will be from left to right,
so the order is fine already,
but the closing brackets are all over the place.
For example, the second <code>]</code>, assigned to index <code>9</code>, is associated to the sublist <code>[6,7]</code> in the original input.
Since we will construct the final list bottom-up,
this should come after the list <code>[2,[3,4]]</code>,
the closing bracket of which is however assigned to index <code>10</code>.</p>
<p>To fix this, we use the nesting variable <code>l</code> defined above<!--
-->â€”there, weâ€™ve already associated a sublist to its depth in the breadth-first representation.
Looking at <code>l</code> again, we can find the index of the sublist that a given <code>]</code> is closing by looking at the index of the element in front of it:</p>
<pre class="bqn"><code>    ts DP l
â”Œâ”€
â•µ&quot;[0[0[00]]0[00]0]
  1122444211333110&quot;
                   â”˜
    c/Â»l
âŸ¨ 4 2 3 1 âŸ©</code></pre>
<p>Since the list with the highest index above will be constructed first,
we have to invert these numbers.
Then, we just have to add these to the rest of the literals.</p>
<pre class="bqn"><code>    c/Â»l
âŸ¨ 4 2 3 1 âŸ©
    â‰ âŠ¸- c/Â»l          # Deeply nested lists are constructed *first*
âŸ¨ 0 2 1 3 âŸ©
    (â‰ nums)+ â‰ âŠ¸- c/Â»l # Indices should not clash with literals
âŸ¨ 8 10 9 11 âŸ©
    (â†•â‰ nums)âˆ¾ (â‰ nums)+ â‰ âŠ¸- c/Â»l # Add to end
âŸ¨ 0 1 2 3 4 5 6 7 8 10 9 11 âŸ©
    vi â†© viâŠ(â†•â‰ nums)âˆ¾ (â‰ nums)+ â‰ âŠ¸- c/Â»l # Fix vi by indexing this new list
âŸ¨ 0 1 2 3 8 10 4 5 6 9 7 11 âŸ©</code></pre>
<p>This gives us fixed indices:</p>
<pre class="bqn"><code>    (ln/ts) â‰ vi
â”Œâ”€
â•µ '0' '0' '0' '0' ']' ']' '0' '0' '0' ']' '0' ']'
   0   1   2   3   8   10  4   5   6   9   7   11
                                                  â”˜</code></pre>
<p>This means we first construct <code>[3,4]</code>, then <code>[2,[3,4]]</code>, then <code>[6,7]</code>, and finally the whole list <code>[1,[2,[3,4]],5,[6,7],8]</code>.
For this, we simply have to <em>group</em> the indices of <code>vi</code> accordingly.</p>
<pre class="bqn"><code>    vi
âŸ¨ 0 1 2 3 8 10 4 5 6 9 7 11 âŸ©
    ln/l # Since vi also only contains indices for literals and nesting
âŸ¨ 1 2 4 4 2 1 1 3 3 1 1 0 âŸ©
    (ln/l)âŠ”vi
âŸ¨ âŸ¨ 11 âŸ© âŸ¨ 0 10 4 9 7 âŸ© âŸ¨ 1 8 âŸ© âŸ¨ 5 6 âŸ© âŸ¨ 2 3 âŸ© âŸ©
    1-Ëœln/l # Drop final ] for the whole list
âŸ¨ 0 1 3 3 1 0 0 2 2 0 0 Â¯1 âŸ©
    âŒ½(1-Ëœln/l)âŠ”vi # Reverse to build deeply nested lists sooner
âŸ¨ âŸ¨ 2 3 âŸ© âŸ¨ 5 6 âŸ© âŸ¨ 1 8 âŸ© âŸ¨ 0 10 4 9 7 âŸ© âŸ©</code></pre>
<p>Now all that is left is to build the whole list recursively.
We start with the list of literals,
construct the next list, and add it to the end of the list of literals.
This way, the later indices <code>8</code>, <code>9</code>, and <code>10</code> will refer to these sublists.</p>
<pre class="bqn"><code>    âŒ½(1-Ëœln/l)âŠ”vi
âŸ¨ âŸ¨ 2 3 âŸ© âŸ¨ 5 6 âŸ© âŸ¨ 1 8 âŸ© âŸ¨ 0 10 4 9 7 âŸ© âŸ©
    nums
âŸ¨ 1 2 3 4 5 6 7 8 âŸ©
    2â€¿3âŠnums
âŸ¨ 3 4 âŸ©
    nums âˆ¾â†© &lt;2â€¿3âŠnums
âŸ¨ 1 2 3 4 5 6 7 8 âŸ¨ 3 4 âŸ© âŸ©
    nums âˆ¾â†© &lt;5â€¿6âŠnums
âŸ¨ 1 2 3 4 5 6 7 8 âŸ¨ 3 4 âŸ© âŸ¨ 6 7 âŸ© âŸ©
    nums âˆ¾â†© &lt;1â€¿8âŠnums
â”Œâ”€
Â· 1 2 3 4 5 6 7 8 âŸ¨ 3 4 âŸ© âŸ¨ 6 7 âŸ© âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ©
                                                â”˜
    nums âˆ¾â†© &lt;0â€¿10â€¿4â€¿9â€¿7âŠnums
â”Œâ”€
Â· 1 2 3 4 5 6 7 8 âŸ¨ 3 4 âŸ© âŸ¨ 6 7 âŸ© âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ© â”Œâ”€
                                                Â· 1 âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ© 5 âŸ¨ 6 7 âŸ© 8
                                                                              â”˜
                                                                                â”˜
    Â¯1âŠ‘nums
â”Œâ”€
Â· 1 âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ© 5 âŸ¨ 6 7 âŸ© 8
                              â”˜</code></pre>
<p>More concisely:</p>
<pre class="bqn"><code>    res â† nums # Mutation is evil
âŸ¨ 1 2 3 4 5 6 7 8 âŸ©
    {res âˆ¾â†© &lt;ğ•©âŠres â‹„@}Â¨ âŒ½(1-Ëœln/l)âŠ”vi

    Â¯1âŠ‘res
â”Œâ”€
Â· 1 âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ© 5 âŸ¨ 6 7 âŸ© 8
                              â”˜</code></pre>
<p>One tiny change has to be made to the building of the sublists:
if our input is <code>"[]"</code>, then <code>1-Ëœln/l</code> will be <code>âŸ¨Â¯1âŸ©</code>,
to the list as a whole will be dropped!
We can hackily fix this by always appending the total number of closing brackets to the back of the list via <code>(+Â´c)âˆ¾Ëœ</code>.
If the list is empty, then this will accommodate for that case.
Otherwise, the left argument to <em>group</em> will be one element longer than the right one.
This is not a problem, however, because thatâ€™s actually a feature<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> of the function:
in that case, the last element specified the minimum length of the result.</p>
<pre class="bqn"><code>    0â€¿Â¯1â€¿1â€¿4 âŠ” &quot;abc&quot; # Padding
âŸ¨ &quot;a&quot; &quot;c&quot; âŸ¨âŸ© âŸ¨âŸ© âŸ©</code></pre>
<p>Putting everything together:</p>
<pre class="bqn"><code>Parse â† {
  tsâ€¿nums â† Tokenise ğ•©                 # Tokens and numbers
  o â† '['=ts                           # Opening brackets
  c â† ']'=ts                           # Closing brackets
  d â† â‹+`o-c                           # Depth ordering
  ln â† tsâˆŠ&quot;0]&quot;                         # Literals and nesting
  l â† (â‹d)âŠ+`'['=dâŠts                  # Sublist depth
  vi â† â‹â‹ (ln/ts='0') + 2Ã—ln/c         # Value indices
  r â† nums                             # Result
  vi âŠâ†© (â†•â‰ nums)âˆ¾(â‰ nums)+ â‰ âŠ¸- c/Â»l     # Fix value indices
  {r âˆ¾â†© &lt;ğ•©âŠr â‹„@}Â¨ âŒ½((+Â´c)âˆ¾Ëœ1-Ëœln/l)âŠ”vi # Build result
  Â¯1âŠ‘r
}</code></pre>
<p>Works like a charm:</p>
<pre class="bqn"><code>    Parse &quot;[1,[2,[3,4]],5,[6,7],8]&quot;
â”Œâ”€
Â· 1 âŸ¨ 2 âŸ¨ 3 4 âŸ© âŸ© 5 âŸ¨ 6 7 âŸ© 8
                              â”˜
    Parse &quot;[]&quot;
âŸ¨âŸ©
    Parse &quot;[1, [42, [[0], 2, 3]], 30]&quot;
â”Œâ”€
Â· 1 â”Œâ”€                   30
    Â· 42 âŸ¨ âŸ¨ 0 âŸ© 2 3 âŸ©
                       â”˜
                            â”˜
    Parse &quot;[1,2,[],[3,4,[5,6]],7,8,[9,[],10]]&quot;
â”Œâ”€
Â· 1 2 âŸ¨âŸ© âŸ¨ 3 4 âŸ¨ 5 6 âŸ© âŸ© 7 8 âŸ¨ 9 âŸ¨âŸ© 10 âŸ©
                                         â”˜</code></pre>
<h2 id="adding-strings">Adding strings</h2>
<p>Iâ€™d like to add one more literal,
so that we get a feeling for how to do that sort of extension;
strings sound like a good idea.</p>
<p>First, the lexer: getting the strings and their beginnings works almost the same as in the numbers case above.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<pre class="bqn"><code>    inp â† &quot;[1,&quot;&quot;a&quot;&quot;,2,&quot;&quot;b&quot;&quot;]&quot;
&quot;[1,&quot;&quot;a&quot;&quot;,2,&quot;&quot;b&quot;&quot;]&quot;
    s â† â‰ `'&quot;'=inp             # strings
âŸ¨ 0 0 0 1 1 0 0 0 0 1 1 0 0 âŸ©</code></pre>
<p>Before we move on, letâ€™s slightly change the definition of <code>DP</code>:
for syntax highlighting reasons, Iâ€™d like quotes to occupy a single character that is not the quote character itself.
Letâ€™s just substitute <code>'</code> for <code>"</code> in the left argument,
which should fix this issue and hopefully still be clear enough.</p>
<pre class="bqn"><code>    DP â† {((@+39)Â¨âŒ¾((ğ•¨='&quot;')âŠ¸/)ğ•¨) â‰ '0'+ğ•©}
(function block)
    inp DP s
â”Œâ”€
â•µ&quot;[1,'a',2,'b']
  0001100001100&quot;
                â”˜
    sb â† Â»âŠ¸&lt; s                # string beginnings
âŸ¨ 0 0 0 1 0 0 0 0 0 1 0 0 0 âŸ©
    inp DP sb
â”Œâ”€
â•µ&quot;[1,'a',2,'b']
  0001000001000&quot;
                â”˜</code></pre>
<p>Selecting the strings also works the same way;
do a sum <em>scan</em> on the string beginnings, punch out the actual strings, and then <em>group</em>.</p>
<pre class="bqn"><code>    1-ËœsÃ—+`sb
âŸ¨ Â¯1 Â¯1 Â¯1 0 0 Â¯1 Â¯1 Â¯1 Â¯1 1 1 Â¯1 Â¯1 âŸ©
    +`sb
âŸ¨ 0 0 0 1 1 1 1 1 1 2 2 2 2 âŸ©
    1-ËœsÃ—+`sb
âŸ¨ Â¯1 Â¯1 Â¯1 0 0 Â¯1 Â¯1 Â¯1 Â¯1 1 1 Â¯1 Â¯1 âŸ©
    (1-ËœsÃ—+`sb)âŠ”inp
âŸ¨ &quot;&quot;&quot;a&quot; &quot;&quot;&quot;b&quot; âŸ©
    1â†“Â¨ (1-ËœsÃ—+`sb)âŠ”inp
âŸ¨ &quot;a&quot; &quot;b&quot; âŸ©</code></pre>
<p>Actually, you can be a little bit smarter here;
instead of dropping the first element of every string,
we can instead make sure that they are never selected by <em>group</em>
by comparing when <code>s</code> is bigger than <code>sb</code>:
this will only be the case if one is truly inside of a string.</p>
<pre class="bqn"><code>    (s&gt;sb)Ã—+`sb               # Same as (sâˆ§Â¬sb)Ã—+`sb
âŸ¨ 0 0 0 0 1 0 0 0 0 0 2 0 0 âŸ©
    (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”inp
âŸ¨ &quot;a&quot; &quot;b&quot; âŸ©</code></pre>
<p>Putting this together in our tokeniser,
we now also need to make sure that we ignore everything thatâ€™s happening inside of a string.
To do that, we can introduce an â€œexclusionâ€ variable
<code>ex â† sâˆ¨ğ•©âˆŠ@+9â€¿10â€¿13â€¿32</code>
and thread it through to the respective definitions.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<pre class="bqn"><code>Tokenise â† {
  sb â† Â»âŠ¸&lt; sâ†â‰ `'&quot;'=ğ•©             # String beginnings
  sr â† (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”ğ•©        # Strings to return

  ex â† sâˆ¨ğ•©âˆŠ@+9â€¿10â€¿13â€¿32          # Exclude whitespace and strings
  nb â† Â»âŠ¸&lt; nâ† (Â¬ex)âˆ§ ğ•©âˆŠ'0'+â†•10   # Number beginnings
#             ^^^^^^
  nr â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`nb)âŠ”ğ•© # Numbers to return

  ts â† sbâˆ¨(Â¬ex)âˆ§nbâˆ¨ğ•©âˆŠ&quot;[]&quot;        # Tokens
#         ^^^^^^
  âŸ¨ts/ '0'Â¨âŒ¾(nbâŠ¸/) ğ•©, nr, srâŸ©
}</code></pre>
<pre class="bqn"><code>    Tokenise &quot;[1,&quot;&quot;a&quot;&quot;,2,&quot;&quot;b&quot;&quot;]&quot;
âŸ¨ &quot;[0&quot;&quot;0&quot;&quot;]&quot; âŸ¨ 1 2 âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; âŸ© âŸ©
    Tokenise &quot;[1,&quot;&quot;a,2,b&quot;&quot;]&quot;
âŸ¨ &quot;[0&quot;&quot;]&quot; âŸ¨ 1 âŸ© âŸ¨ &quot;a,2,b&quot; âŸ© âŸ©</code></pre>
<h3 id="parsing-1">Parsing</h3>
<p>Adjusting the parser is actually quite easy here:
we just have to add quotes to the allowed literals,
make the value indices aware of them,
and also feed them into the initial value of the result;
no further changes necessary.</p>
<pre class="bqn"><code>Parse â† {
  tsâ€¿numsâ€¿strs â† Tokenise ğ•©                    # Tokens, numbers, and strings
#        ^^^^^
  o â† '['=ts                                   # Opening, closing, depth
  c â† ']'=ts                                   # Closing brackets
  d â† â‹+`o-c                                   # Depth ordering
  ln â† tsâˆŠ&quot;&quot;&quot;0]&quot;                               # Literals and nesting
#          ^^
  l â† (â‹d)âŠ+`'['=dâŠts                          # Sublist depth
  vi â† â‹â‹ (ln/ts='0') + (2Ã—ln/ts='&quot;') + 3Ã—ln/c # Value indices
#                       ^^^^^^^^^^^^^
  r â† numsâˆ¾strs                                # Result
#         ^^^^^
  vi âŠâ†© (â†•â‰ r)âˆ¾(â‰ r)+ â‰ âŠ¸- c/Â»l                   # Fix value indices
  {r âˆ¾â†© &lt;ğ•©âŠr â‹„@}Â¨ âŒ½((+Â´c)âˆ¾Ëœ1-Ëœln/l)âŠ”vi         # Build result
  Â¯1âŠ‘r
}</code></pre>
<h3 id="escaping">Escaping</h3>
<p>To make things a little bitâ€”though not tooâ€”interesting, letâ€™s add some easy escaping.
By this I exclusively mean backslash-based escaping:
every time we encounter a backslash inside of a string,
we treat the following character (e.g., a quote) literally.
Thinking about semantics a bit, if we have a sequence of backslashes like <code>\\\\\</code>,
we want to alternate between treating them as the escapist and the escapee.
One way to do this is with a less-than <em>scan</em>:</p>
<pre class="bqn"><code>    inp â† &quot;[1,&quot;&quot;a&quot;&quot;,&quot;&quot;b_\\\&quot;&quot;\\_c&quot;&quot;]&quot;
&quot;[1,&quot;&quot;a&quot;&quot;,&quot;&quot;b_\\\&quot;&quot;\\_c&quot;&quot;]&quot;
    '\'=inp
âŸ¨ 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 âŸ©
    &lt;`'\'=inp
âŸ¨ 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 âŸ©
    inp DP &lt;`'\'=inp
â”Œâ”€
â•µ&quot;[1,'a','b_\\\'\\_c']
  00000000001010100000&quot;
                       â”˜</code></pre>
<p>We effectively check if the previous character of the string was escaped, but in a left-to-right fashion
(as in, earlier choices on the left affect those on the right).
To get the escaped values themselves, we can now simply <em>nudge</em> the string to the right.</p>
<pre class="bqn"><code>    inp DP Â»&lt;`'\'=inp
â”Œâ”€
â•µ&quot;[1,'a','b_\\\'\\_c']
  00000000000101010000&quot;
                       â”˜</code></pre>
<p>Finally, when selecting the strings, we just need to exclude the escaped quotes:</p>
<pre class="bqn"><code>    e â† Â»&lt;`'\'=inp     # Escapes
âŸ¨ 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 âŸ©
    s â† â‰ `(Â¬e)âˆ§'&quot;'=inp # Strings are in quotes that are not escaped
âŸ¨ 0 0 0 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 âŸ©
    sb â† Â»âŠ¸&lt; s
âŸ¨ 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 âŸ©
    (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”inp
âŸ¨ &quot;a&quot; &quot;b_\\\&quot;&quot;\\_c&quot; âŸ©</code></pre>
<p>As we are dealing with Boolean masks,
alternatively to <code>(Â¬e)âˆ§'"'=inp</code> one could also write the shorter,
though slightly more obscure,
<code>e&lt;'"'=inp</code>.
All in all, we have</p>
<pre class="bqn"><code>Tokenise â† {
  e  â† Â»&lt;`'\'=ğ•©                  # Escapes
  sb â† Â»âŠ¸&lt; sâ† â‰ `(Â¬e)âˆ§ '&quot;'=ğ•©      # String beginnings
  sr â† (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”ğ•©        # Strings to return

  ex â† sâˆ¨ ğ•©âˆŠ@+9â€¿10â€¿13â€¿32         # Exclude whitespace and strings
  nb â† Â»âŠ¸&lt; nâ† (Â¬ex)âˆ§ ğ•©âˆŠ'0'+â†•10   # Number beginnings
  nr â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`nb)âŠ”ğ•© # Numbers to return

  ts â† sbâˆ¨(Â¬ex)âˆ§nbâˆ¨ğ•©âˆŠ&quot;[]&quot;        # Tokens
  âŸ¨ts/ '0'Â¨âŒ¾(nbâŠ¸/) ğ•©, nr, srâŸ©
}</code></pre>
<pre class="bqn"><code>    Tokenise &quot;[1,&quot;&quot;a,2,b&quot;&quot;]&quot;
âŸ¨ &quot;[0&quot;&quot;]&quot; âŸ¨ 1 âŸ© âŸ¨ &quot;a,2,b&quot; âŸ© âŸ©
    Tokenise &quot;[1,&quot;&quot;a&quot;&quot;,&quot;&quot;b_\\\&quot;&quot;\\_c&quot;&quot;,2]&quot;
âŸ¨ &quot;[0&quot;&quot;&quot;&quot;0]&quot; âŸ¨ 1 2 âŸ© âŸ¨ &quot;a&quot; &quot;b_\\\&quot;&quot;\\_c&quot; âŸ© âŸ©</code></pre>
<p>The parser doesnâ€™t need to be adjusted at all this time and just works:</p>
<pre class="bqn"><code>    Parse &quot;[1,&quot;&quot;a&quot;&quot;,&quot;&quot;b_\\\&quot;&quot;\\_c&quot;&quot;,2]&quot;
âŸ¨ 1 &quot;a&quot; &quot;b_\\\&quot;&quot;\\_c&quot; 2 âŸ©
    Parse &quot;[1,[2,[&quot;&quot;[x,10]&quot;&quot;,4]],5,[&quot;&quot;a&quot;&quot;,7],8]&quot;
â”Œâ”€
Â· 1 âŸ¨ 2 âŸ¨ &quot;[x,10]&quot; 4 âŸ© âŸ© 5 âŸ¨ &quot;a&quot; 7 âŸ© 8
                                       â”˜</code></pre>
<h2 id="objects-and-their-ilk">Objects and their ilk</h2>
<p>Onto the second big type we have to support: objects.
They should look like</p>
<pre><code>{&quot;a&quot;: 1, &quot;b&quot;: [&quot;c&quot;, &quot;d&quot;]}</code></pre>
<p>and so on.</p>
<p>This time, lexing is the easy partâ€”we merely have to add curly braces to our list of tokens.
Actually, to keep things visually comprehensible,
letâ€™s go back on what I said at the beginning
and do the same for the comma as the array separator,
and the colon as the keyâ€“value separator.</p>
<pre class="bqn"><code>Tokenise â† {
  e  â† Â»&lt;`'\'=ğ•©                  # Escapes
  sb â† Â»âŠ¸&lt; sâ† â‰ `(Â¬e)âˆ§ '&quot;'=ğ•©      # String beginnings
  sr â† (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”ğ•©        # Strings to return

  ex â† sâˆ¨ ğ•©âˆŠ@+9â€¿10â€¿13â€¿32         # Exclude whitespace and strings
  nb â† Â»âŠ¸&lt; nâ† (Â¬ex)âˆ§ ğ•©âˆŠ'0'+â†•10   # Number beginnings
  nr â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`nb)âŠ”ğ•© # Numbers to return

  ts â† sbâˆ¨(Â¬ex)âˆ§nbâˆ¨ğ•©âˆŠ&quot;[]{},:&quot;    # Tokens
#                       ^^^^
  âŸ¨ts/ '0'Â¨âŒ¾(nbâŠ¸/) ğ•©, nr, srâŸ©
}</code></pre>
<pre class="bqn"><code>    Tokenise &quot;{&quot;&quot;a&quot;&quot;: 123, &quot;&quot;bcde&quot;&quot;: [1,&quot;&quot;42&quot;&quot;,30]}&quot;
âŸ¨ &quot;{&quot;&quot;:0,&quot;&quot;:[0,&quot;&quot;,0]}&quot; âŸ¨ 123 1 30 âŸ© âŸ¨ &quot;a&quot; &quot;bcde&quot; &quot;42&quot; âŸ© âŸ©</code></pre>
<p>Looks good.</p>
<h3 id="parsing-2">Parsing</h3>
<p>Since the parser will change quite a bit,
it is perhaps more instructive to build it up from scratch again.
Up to getting the depth, things donâ€™t really change much.</p>
<pre class="bqn"><code>    inp â† &quot;{&quot;&quot;a&quot;&quot;: 1, &quot;&quot;b&quot;&quot;: [&quot;&quot;1&quot;&quot;,2,{&quot;&quot;a&quot;&quot;:2}]}&quot;
&quot;{&quot;&quot;a&quot;&quot;: 1, &quot;&quot;b&quot;&quot;: [&quot;&quot;1&quot;&quot;,2,{&quot;&quot;a&quot;&quot;:2}]}&quot;
    tsâ€¿numsâ€¿strs â† Tokenise inp
âŸ¨ &quot;{&quot;&quot;:0,&quot;&quot;:[&quot;&quot;,0,{&quot;&quot;:0}]}&quot; âŸ¨ 1 2 2 âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; &quot;1&quot; &quot;a&quot; âŸ© âŸ©
    o â† tsâˆŠ&quot;{[&quot;  # Open
âŸ¨ 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 âŸ©
    c â† tsâˆŠ&quot;]}&quot;  # Close
âŸ¨ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 âŸ©
    cl â† ':'=ts  # Colon
âŸ¨ 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 âŸ©
    d â† â‹+`o-c   # Depth
âŸ¨ 18 0 1 2 3 4 5 6 17 7 8 9 10 11 16 12 13 14 15 âŸ©
    td â† dâŠts    # Tokens by depth
&quot;}{&quot;&quot;:0,&quot;&quot;:][&quot;&quot;,0,}{&quot;&quot;:0&quot;</code></pre>
<p>Since we now have two different â€œcontainerâ€ types,
we also need to be careful about how â€œnestingâ€ is definedâ€”<!--
-->sometimes we may only want the delimiters of one container to increase the level of nesting.
Letâ€™s start with getting a mask of the start of all new sublists<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>,
which are now defined by an opening brace or bracket:</p>
<pre class="bqn"><code>    s â† tdâˆŠ&quot;[{&quot;  # Sublist starts
âŸ¨ 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 âŸ©
    td DP s
â”Œâ”€
â•µ&quot;}{':0,':][',0,}{':0
  0100000001000001000&quot;
                      â”˜</code></pre>
<p>We also did the same thing in the original parser
when we defined the sublist depth <code>l â† (â‹d)âŠ+`'['=dâŠts</code>,
only we didnâ€™t give <code>'['=dâŠts</code>
(which now morphed to <code>(dâŠts)âˆŠ"[{"</code> due to the additional container types) a name.
However, defining the sublist depth still works as before:</p>
<pre class="bqn"><code>    n â† (â‹d)âŠ+`s  # Nesting
âŸ¨ 1 1 1 1 1 1 1 2 2 2 2 2 3 3 3 3 2 1 0 âŸ©
    ts DP n
â”Œâ”€
â•µ&quot;{':0,':[',0,{':0}]}
  1111111222223333210&quot;
                      â”˜</code></pre>
<p>Moving on, we can use the mask of sublists <code>s</code> to build a mask of sub-objects.</p>
<pre class="bqn"><code>    s
âŸ¨ 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 âŸ©
    td DP s
â”Œâ”€
â•µ&quot;}{':0,':][',0,}{':0
  0100000001000001000&quot;
                      â”˜
    of â† s/'{'=td  # Filter of sublists that are objects
âŸ¨ 1 0 1 âŸ©</code></pre>
<p>The <code>of</code> variable is to be read as something like â€œthere are three sublists, the first and third of which are sub-objectsâ€.
This is good, but doesnâ€™t yet take object nesting into account<!--
-->â€”the second <code>1</code> in <code>of</code>,
being nested inside of the first object,
is actually at depth two and should be treated accordingly.
To fix this, we proceed as before and do a sum <em>scan</em> across <code>of</code>,
with a subsequent stencil to make sure we only select the objects.</p>
<pre class="bqn"><code>    +`of
âŸ¨ 1 1 2 âŸ©
    on â† of Ã— +`of  # Object nesting
âŸ¨ 1 0 2 âŸ©
    on â† +`âŠ¸Ã— of    # Object nesting (prettier!)
âŸ¨ 1 0 2 âŸ©</code></pre>
<p>Next, letâ€™s get the keys of each object and <em>group</em> them by depth,
as this will make subsequent processing much easier.
That is, given an input like <code>{"a": 1, "b": [1, "c", {"a": 2}]}</code>,
we want to end up with <code>âŸ¨âŸ¨"a", "b"âŸ©, âŸ¨"a"âŸ©âŸ©</code>.
Actually, since strings can be values as well,
we probably want to separate those, too,
ending up with an array of the form <code>âŸ¨âŸ¨"c"âŸ©, âŸ¨"a", "b"âŸ©, âŸ¨"a"âŸ©âŸ©</code>.</p>
<p>Selecting the keys themselves is easy:
just go to the colons,
<em>nudge</em> them to consider the token before,
and <em>replicate</em> from all strings.</p>
<pre class="bqn"><code>    cl
âŸ¨ 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 âŸ©
    ts DP Â«cl
â”Œâ”€
â•µ&quot;{':0,':[',0,{':0}]}
  0100010000000100000&quot;
                      â”˜
    ('&quot;'=ts)/Â«cl
âŸ¨ 1 1 0 1 âŸ©</code></pre>
<p>A <code>0</code> stands for â€œthis string is a valueâ€,
and a <code>1</code> is for â€œthis string is a key somewhereâ€.
We already have a nesting variable <code>n</code>,
which however also increases the depth when hitting an array instead of an object.
If we had one only for objects, we could use that as a stencil to obtain a depth ordered list when combining it with the above.</p>
<p>Thereâ€™s (at least) two things we can do:
re-create <code>n</code> but only take into consideration objects,
or somehow use <code>n</code>, but punch holes into it for the arrays.
The first way is straightforward and essentially just copies the definition of <code>n</code>:</p>
<pre class="bqn"><code>    (â‹d)âŠ+`td='{'
âŸ¨ 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 1 1 0 âŸ©
    ts DP (â‹d)âŠ+`td='{'
â”Œâ”€
â•µ&quot;{':0,':[',0,{':0}]}
  1111111111112222110&quot;
                      â”˜
    (Â«cl)Ã— (â‹d)âŠ+`td='{'
âŸ¨ 0 1 0 0 0 1 0 0 0 0 0 0 0 2 0 0 0 0 0 âŸ©
    ('&quot;'=ts)/ (Â«cl)Ã— (â‹d)âŠ+`td='{'
âŸ¨ 1 1 0 2 âŸ©</code></pre>
<p>However, this seems quite inelegant to me;
thankfully, punching holes into <code>n</code> is not as hard as it sounds.
We already have an array <code>on</code> that tells us about the object nesting,
with a <code>0</code> standing in for â€œthis is the start of an arrayâ€.
That means if we simply use <code>n</code> to <em>select</em> from <code>on</code>,
this gives us what we want!<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<pre class="bqn"><code>    ts DP n
â”Œâ”€
â•µ&quot;{':0,':[',0,{':0}]}
  1111111222223333210&quot;
                      â”˜
    nâŠ0âˆ¾on
âŸ¨ 1 1 1 1 1 1 1 0 0 0 0 0 2 2 2 2 0 1 0 âŸ©
    ts DP nâŠ0âˆ¾on
â”Œâ”€
â•µ&quot;{':0,':[',0,{':0}]}
  1111111000002222010&quot;
                      â”˜
    ('&quot;'=ts) / (Â«cl)Ã—nâŠ0âˆ¾on
âŸ¨ 1 1 0 2 âŸ©</code></pre>
<p>All thatâ€™s left is to <em>group</em> the given strings!</p>
<pre class="bqn"><code>    (('&quot;'=ts)/(Â«cl)Ã—nâŠ0âˆ¾on) âŠ” strs         # Keys
âŸ¨ âŸ¨ &quot;1&quot; âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; âŸ© âŸ¨ &quot;a&quot; âŸ© âŸ©
    (('&quot;'=ts)/(Â«cl)Ã—(â‹d)âŠ+`td='{') âŠ” strs  # Same result
âŸ¨ âŸ¨ &quot;1&quot; âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; âŸ© âŸ¨ &quot;a&quot; âŸ© âŸ©</code></pre>
<p>There is but a small wrinkle yet to fix:
if the object is empty, it might be that
<code>(('"'=ts)/(Â«cl)Ã—(â‹d)âŠ+`td='{')</code> returns a nonsense answer,
which would yield an error when trying to <em>group</em> the strings.
This is much the same situation as before when we had to change <code>1-Ëœln/l</code> to <code>(+Â´c)âˆ¾Ëœ1-Ëœln/l</code> during the construction of the final array.
The fix here is similar, since with <code>of</code> we have an obvious quantity, the <em>length</em> of which is always the length we want to end up with,<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>
even when trying to parse <code>{}</code>.</p>
<pre class="bqn"><code>    ks â† ((1+Â´of)âˆ¾Ëœ ('&quot;'=ts)/(Â«cl)Ã—nâŠ0âˆ¾on)âŠ”strs # Keys, final definition
âŸ¨ âŸ¨ &quot;1&quot; âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; âŸ© âŸ¨ &quot;a&quot; âŸ© âŸ©</code></pre>
<p>Building up our initial list of values,
this now includes all numbers, as well as all strings that are not keys.
Conveniently, by the above argument the latter is exactly the first element of <code>ks</code>.</p>
<pre class="bqn"><code>    vs â† nums âˆ¾ âŠ‘ks # Initial values
âŸ¨ 1 2 2 &quot;1&quot; âŸ©</code></pre>
<p>Building up the value indices works exactly the same as before;
the only complication now is that a definition of <code>ln â† tsâˆŠ"""0]"</code> for literals and nesting does not work anymore, as we need to exclude the strings that are keys.
What seems to work best is to specify what <code>ln</code> should <em>not</em> be:
a comma, a colon, any opening parenthesis, and its token should not occur immediately before a colon.</p>
<pre class="bqn"><code>    ln â† Â¬ (Â«âŠ¸âˆ¨cl)âˆ¨oâˆ¨','=ts                       # Literals and nesting
âŸ¨ 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 âŸ©
    vi â† â‹â‹ (ln/ts='0') + (2Ã—ln/ts='&quot;') + 3Ã—ln/c  # Value indices
âŸ¨ 0 3 1 2 4 5 6 âŸ©
    vi âŠâ†© (â†•â‰ vs)âˆ¾(â‰ vs)+ â‰ âŠ¸- c/Â»n                  # Fix value indices
âŸ¨ 0 3 1 2 4 5 6 âŸ©</code></pre>
<p>Almost doneâ€”the only thing left is to build up the finished, nested, array.
This is also the time we have to decide upon the final representation of an object.
What turns out to be quite convenient for small-ish JSON<!--
-->â€”which, letâ€™s be honest, will be the only kind of JSON that <code>Parse</code> ever gets to seeâ€”<!--
-->is to use <em>rank</em> 2 arrays;
an object <code>{"a": 1}</code> gets parsed into <code>2â€¿1â¥Š"a"â€¿1</code>.
Further, when building the result we have to make sure to â€œrecogniseâ€ when to pull values and sublists out of the recursively built up <code>vs</code>,
and when to use <code>ks</code> to get keys instead.
This can be achieved by taking <code>on</code> into consideration:</p>
<pre class="bqn"><code>    âŒ½((â‰ on)âˆ¾Ëœ1-Ëœln/n)âŠ”vi  # How to build which sublist
âŸ¨ âŸ¨ 2 âŸ© âŸ¨ 3 1 4 âŸ© âŸ¨ 0 5 âŸ© âŸ©
    âŒ½on                   # Which sublist is an object?
âŸ¨ 2 0 1 âŸ©
    on â‰â—‹âŒ½ ((â‰ on)âˆ¾Ëœ1-Ëœln/n)âŠ”vi
â”Œâ”€
â•µ 2     0         1
  âŸ¨ 2 âŸ© âŸ¨ 3 1 4 âŸ© âŸ¨ 0 5 âŸ©
                         â”˜</code></pre>
<p>This means that the final shape is something like
<code>on BUILDÂ¨â—‹âŒ½ ((â‰ on)âˆ¾Ëœ1-Ëœln/l)âŠ”vi</code>,
where <code>BUILD</code> is a dyadic function,
taking as its left argument a number thatâ€™s zero if we are dealing with a list or literal,
and bigger than zero if we have an object and want to select at least one key.
The right argument first <em>select</em>s the required sublist or value from <code>vs</code>,
and then refines this selection by picking possible keys out of <code>ks</code>.
Putting this into code:</p>
<pre class="bqn"><code>    on {vs âˆ¾â†© &lt;ğ•¨Selğ•©âŠvs â‹„@}Â¨â—‹âŒ½ ((â‰ on)âˆ¾Ëœ1-Ëœln/l)âŠ”vi # Build result</code></pre>
<p>All thatâ€™s left to do is to write <code>Sel</code>.
Doing nothing when <code>ğ•¨</code> is zero can just be achieved with a
<a href="https://mlochbaum.github.io/BQN/doc/block.html#block-headers">header</a>.
If <code>ğ•¨</code> is a number, it represents the depth of the object, and directly corresponds with the indexing of <code>ks</code>,
so we can just <em>pick</em> the result and <em>couple</em> it to <code>ğ•©</code> to make things a <em>rank</em> 2 array.<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
<pre class="bqn"><code>    Sel â† {0ğ•Šx: x; iğ•Šx: (iâŠ‘ks)â‰x}  # Select
(function block)
    Sel â† âŠ‘âŸœksâŠ¸â‰âŸ(0&lt;âŠ£)             # Point-free and without blocks
âŠ‘âŸœâŸ¨ âŸ¨ &quot;1&quot; âŸ© âŸ¨ &quot;a&quot; &quot;b&quot; âŸ© âŸ¨ &quot;a&quot; âŸ© âŸ©âŠ¸â‰âŸ(0&lt;âŠ£)

# The object {&quot;a&quot;: 2} is the first non-literal that's constructed.
    inp
&quot;{&quot;&quot;a&quot;&quot;: 1, &quot;&quot;b&quot;&quot;: [&quot;&quot;1&quot;&quot;,2,{&quot;&quot;a&quot;&quot;:2}]}&quot;
    âŒ½((â‰ on)âˆ¾Ëœ1-Ëœln/n)âŠ”vi
âŸ¨ âŸ¨ 2 âŸ© âŸ¨ 3 1 4 âŸ© âŸ¨ 0 5 âŸ© âŸ©
    âŒ½on
âŸ¨ 2 0 1 âŸ©
    vs
âŸ¨ 1 2 2 &quot;1&quot; âŸ©
    2 Sel âŸ¨2âŸ©âŠvs
â”Œâ”€
â•µ &quot;a&quot;
   2
      â”˜</code></pre>
<p>And thatâ€™s pretty much itâ€”here are the last two lines, in all their glory:</p>
<pre class="bqn"><code>    on {vs âˆ¾â†© &lt;ğ•¨Selğ•©âŠvs â‹„@}Â¨â—‹âŒ½ ((â‰ on)âˆ¾Ëœ1-Ëœln/n)âŠ”vi  # Build result

    Â¯1âŠ‘vs                                           # Get result
â”Œâ”€
â•µ &quot;a&quot; &quot;b&quot;
   1   â”Œâ”€
       Â· &quot;1&quot; 2 â”Œâ”€
               â•µ &quot;a&quot;
                  2
                     â”˜
                       â”˜
                         â”˜
    inp
&quot;{&quot;&quot;a&quot;&quot;: 1, &quot;&quot;b&quot;&quot;: [&quot;&quot;1&quot;&quot;,2,{&quot;&quot;a&quot;&quot;:2}]}&quot;</code></pre>
<p>It works!</p>
<hr />
<p>At the risk of repeating myself, letâ€™s look at the entire parser as well as the tokeniser that weâ€™ve built over the course of this post.</p>
<pre class="bqn"><code>Tokenise â† {
  e  â† Â»&lt;`'\'=ğ•©                  # Escapes
  sb â† Â»âŠ¸&lt; sâ† â‰ `(Â¬e)âˆ§ '&quot;'=ğ•©      # String beginnings
  sr â† (1-Ëœ(s&gt;sb)Ã—+`sb)âŠ”ğ•©        # Strings to return

  ex â† sâˆ¨ ğ•©âˆŠ@+9â€¿10â€¿13â€¿32         # Exclude whitespace and strings
  nb â† Â»âŠ¸&lt; nâ† (Â¬ex)âˆ§ ğ•©âˆŠ'0'+â†•10   # Number beginnings
  nr â† â€¢ParseFloatÂ¨(1-ËœnÃ—+`nb)âŠ”ğ•© # Numbers to return

  ts â† sbâˆ¨(Â¬ex)âˆ§nbâˆ¨ğ•©âˆŠ&quot;[]{},:&quot;    # Tokens
  âŸ¨ts/ '0'Â¨âŒ¾(nbâŠ¸/) ğ•©, nr, srâŸ©
}

Parse â† {
  tsâ€¿numsâ€¿strs â† Tokenise ğ•©
  d  â† â‹+`(oâ†tsâˆŠ&quot;{[&quot;)-(câ†tsâˆŠ&quot;]}&quot;) # Closing, opening, depth
  td â† dâŠts                       # Tokens by depth
  s  â† tdâˆŠ&quot;[{&quot;                    # Sublist starts
  n  â† (â‹d)âŠ+`s                   # Nesting

  of â† s/'{'=td                   # Filter of subsists that are objects
  on â† +`âŠ¸Ã— of                    # Object nesting
  cl â† ':'=ts                     # Colon
  ks â† ((1+Â´of)âˆ¾Ëœ ('&quot;'=ts)/(Â«cl)Ã—nâŠ0âˆ¾on)âŠ”strs    # Keys

  vs â† nums âˆ¾ âŠ‘ks                 # Initial values
  ln â† Â¬ (Â«âŠ¸âˆ¨cl)âˆ¨oâˆ¨','=ts         # Literals and nesting
  vi â† â‹â‹ (ln/ts='0') + (2Ã—ln/ts='&quot;') + 3Ã—ln/c   # Value indices
  vi âŠâ†© (â†•â‰ vs)âˆ¾(â‰ vs)+ â‰ âŠ¸- c/Â»n                   # Fix value indices

  Sel â† {(ğ•¨âŠ‘ks)â‰ğ•©}âŸ(0&lt;âŠ£)          # Select
  on {vs âˆ¾â†© &lt;ğ•¨Selğ•©âŠvs â‹„@}Â¨â—‹âŒ½ ((â‰ on)âˆ¾Ëœ1-Ëœln/n)âŠ”vi # Build result
  Â¯1âŠ‘vs
}</code></pre>
<p>I donâ€™t know about you,
but I think itâ€™s pretty incredible that one can write a parser for a reasonable subset<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> of JSON,
using what are essentially only flat arrays of numbers,
and still have it be this compact.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I can probably offer the same conclusion as in the
<a href="https://tony-zorman.com/posts/bqn-csv.html">CSV post</a>:</p>
<blockquote>
<p>Q: Is writing (and reading) a parser in an array language unnecessarily hard?<br />
A: Yes.</p>
<p>Q: Is it the most fun Iâ€™ve had programming in a long time?<br />
A: Yes.</p>
</blockquote>
<p>Thereâ€™s really something to be said about this style of writing parsers.
To <a href="https://news.ycombinator.com/item?id=41756917">paraphrase</a>
Marshall Lochbaum, the creator of BQN: itâ€™s
hard to write,
hard to read,
hard to modify,
but an absolute joy to debug,
and I would have to agree on all points.
Especially the debugging part, though:
since thereâ€™s essentially no branching, control flow is trivial,
and furthermore everything is just a flat array of numbers.
Once that one <code>0</code> that should be a <code>1</code> is identified, going back to the source just involves reading backwards, with no logic to keep track of at all.</p>
<p>Interestingly, this feels quite different from ordinary array programmingâ€”<!--
-->especially the quite tricky task to give lots of names<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> to lots of concepts.
Still, I suppose this is much more readable than if one tried to make the names go away by using combinators.
At least there are comments, right?</p>
<p>I certainly wouldnâ€™t write allâ€”or even mostâ€”parsers in this style,
but honestly this whole thing was so refreshing that I canâ€™t help but recommend anyone to try at least getting the hang of a simplified form of one of the parsing libraries in <a href="https://github.com/mlochbaum/bqn-libs">bqn-libs</a>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>In case anyone not familiar with BQN finds itself reading this post: BQN is an array programming language in the APL-family.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>If you feel like Iâ€™m going too slow, or that I got something wrong, sorry!
As I said, this is more or less my way of learning and better understanding this style of parsing;
I am by no means the expert here.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>Although CBQN seems to have improved since then<!--
  -->â€”for me, even the nested array version is faster than the recursive approach now.<a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p>I will present many functions in a bottom-up kind of way,
where I gradually build them up in the REPL,
using an example input to showcase the behaviour of the individual array manipulations.
Usually, proper definitions of <code>Tokenise</code> or <code>Parse</code> (the two functions weâ€™re building)
will only be given at the very end of each section.
The input is always indented by four spaces, with the output flush to the left.
If I refer to an unknown variable further down, it was probably defined in such a block.<a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn5"><p>We could in fact also move <em>replicate</em>
into the calls to <code>ns</code> and <code>ğ•©</code>:</p>
<pre class="bqn"><code>    '0'Â¨âŒ¾((ts/ns)âŠ¸/) (ts/inp)
&quot;[0,0,0,0,0]&quot;</code></pre>
<p>Iâ€™m not super well-versed in the ins and outs of CBQNâ€™s performance,
but from a cursory benchmark with the <code>â€¢_timed</code> modifier,
it does not seem to make much of a difference.<a href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn6"><p>As you can see, an opening parenthesis is treated as being inside of the pair,
while a closing one is outside.
This is fine (even wanted) for this use-case;
if you want to treat both pairs as being inside of the pair you can use
<code>+`o-Â»c</code>.<a href="#fnref6" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn7"><p>A questionable API choice, for sure, but Iâ€™ll take it!<a href="#fnref7" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn8"><p>The double quotes <code>""</code> in the string are BQNâ€™s way of escaping quotes
(the same way that CSV does it).
<em>Everything</em> else is treated as a literal characters, even backslashes!<a href="#fnref8" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn9"><p>You will see repeated definitions of <code>Tokenise</code> and <code>Parse</code> throughout this article.
I figured that perhaps indicating changes in this way is more readable than giving you diffs,
if only because all context one needs is right there.
Thatâ€™s one of the advantages of the complete program fitting on a single screen!<a href="#fnref9" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn10"><p>I will use this as shorthand for â€œsub-object and sub-arrayâ€.
Not the best terminology, I suppose, but it will have to do.<a href="#fnref10" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn11"><p>Donâ€™t worry too much about having to use <code>0âˆ¾on</code> instead of <code>on</code> here;
this appears because we are starting at depth zero before reading anything.
Assuming well-formed JSON, this will appear only once at the very end.<a href="#fnref11" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn12"><p>Remember that questionable <em>group</em> API?<a href="#fnref12" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn13"><p>I find this process of treating values and keys separately,
but in a way that they eventually match up at the end,
almost magical.<a href="#fnref13" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn14"><p>With a simple extension to the tokeniser to recognise the constants <code>true</code>, <code>false</code>, and <code>null</code>,
this already parses the <code>cargo metadata</code> output of a few Rust crates that Iâ€™ve tried,
which is the sort of data I would characterise as â€œordinary JSONâ€.
The resulting representation is probably not super easy to work with<!--
  -->â€”thereâ€™s quite a lot of metadata and thus the nesting gets quite deepâ€”<!--
  -->but still, it works.<a href="#fnref14" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn15"><p>Short names at that, otherwise things just look too cumbersome in this style of programming.<a href="#fnref15" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>

      <!-- Body is included in the above file -->
    </section>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Parsing CSV in BQN</title>
    <link href="https://tony-zorman.com/posts/bqn-csv.html" />
    <id>https://tony-zorman.com/posts/bqn-csv.html</id>
    <published>2025-07-28T00:00:00Z</published>
    <updated>2025-07-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <div class="header">
      28th Jul 2025â€“18 Oct 2025
      
        &nbsp;&nbsp;Â·&nbsp;&nbsp;&nbsp;<span title="1852 words">8 min read</span>&nbsp;&nbsp;&nbsp;Â·&nbsp;&nbsp;
      
      
        <a title="All pages tagged '#BQN'." href="/tags/BQN.html" rel="tag">#BQN</a>Â Â Â <a title="All pages tagged '#array-lang'." href="/tags/array-lang.html" rel="tag">#array-lang</a>
      
    </div>
    <h1 class="post-title">Parsing CSV in BQN</h1>
    <div id="title-underline"></div>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  

<p>Letâ€™s write a CSV parser in <a href="https://mlochbaum.github.io/BQN">BQN</a>!</p>
<!--more-->
<p>Working my way towards a full blown JSON parser,
I thought it might be a good idea to start with something simpler<!--
-->â€”<a href="https://www.ietf.org/rfc/rfc4180.txt">RFC 4180</a> sounds like a good candidate.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Plus, there is also a great reference implementation available in
<a href="https://github.com/mlochbaum/bqn-libs/blob/master/csv.bqn">bqn-libs</a>.</p>
<p>This article will assume that you are already at least a little bit familiar with BQN as a language.
If not, I would recommend starting with the official <a href="https://mlochbaum.github.io/BQN/tutorial/index.html">tutorials</a>.
Iâ€™ve also written about my experience <a href="https://tony-zorman.com/posts/aoc-in-bqn.html">using BQN</a> for Advent of Code,
which certainly contains some amount of written words that talk about the language.</p>
<h2 id="the-simplest-case">The simplest case</h2>
<p>Weâ€™ll start with a subset of CSV in which we donâ€™t have to think about escaping at all.
That is, we only allow files that look like this:</p>
<pre><code>a,b,c,d
e,f,g,h</code></pre>
<p>Letâ€™s also permit lines of varying lengths;
this doesnâ€™t really change the implementation much, but I find it quite convenient sometimes.
This simple case is quite straightforward to implement:
we start with finding all occurrences of newlines and commas in the input string</p>
<pre class="bqn"><code>    inp
&quot;a,b,c,d
e,f,g,h&quot;
    [c,n] â† (','âˆ¾@+10) =âŒœ inp
â”Œâ”€
â•µ 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0
  0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
                                â”˜</code></pre>
<p>and then split the string accordingly:</p>
<pre class="bqn"><code>    s â† nâˆ¨c                          # Where to split
âŸ¨ 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 âŸ©
    (1-Ëœ(Â¬s)Ã—1+`s) âŠ” inp
âŸ¨ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; âŸ©</code></pre>
<p>Having all of the â€œtokensâ€ ready,
one just needs to split at the newlines while keeping the shorter list of all splits in mind.</p>
<pre class="bqn"><code>    (0âˆ¾s/+`n) âŠ” (1-Ëœ(Â¬s)Ã—1+`s) âŠ” inp
âŸ¨ âŸ¨ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; âŸ© âŸ¨ &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; âŸ© âŸ©</code></pre>
<p>Easy.</p>
<p>Now, this was probably quite fastâ€”if not, feel free to skip to the next section.
Letâ€™s go through that last line more carefully, as it contains lots of important concepts for array-oriented parsing.</p>
<p>First, we create a depth scan according to all characters weâ€™d like to split the string at:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre class="bqn"><code>    inpâ‰ 1+`s
â”Œâ”€
â•µ 'a' ',' 'b' ',' 'c' ',' 'd' '\n' 'e' ',' 'f' ',' 'g' ',' 'h'
   1   2   2   3   3   4   4   5    5   6   6   7   7   8   8
                                                              â”˜</code></pre>
<p>To single out all of the characters that weâ€™d like to delete<!--
-->â€”i.e., the ones we are splitting atâ€”<!--
-->we multiply the depth scan by <code>Â¬s</code>,
set all commas and newlines to <code>0</code>,
and then subtract one.</p>
<pre class="bqn"><code>    inpâ‰ 1-Ëœ(Â¬s)Ã—1+`s
â”Œâ”€
â•µ 'a' ',' 'b' ',' 'c' ',' 'd' '\n' 'e' ',' 'f' ',' 'g' ',' 'h'
   0  Â¯1   1  Â¯1   2  Â¯1   3   Â¯1   4  Â¯1   5  Â¯1   6  Â¯1   7
                                                              â”˜
    sl â† (1-Ëœ(Â¬s)Ã—1+`s) âŠ” inp
âŸ¨ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; âŸ©</code></pre>
<p>This is also why we gave the depth scan above an initial argument of <code>1</code>â€”otherwise, weâ€™d get</p>
<pre class="bqn"><code>    inpâ‰ 1-Ëœ(Â¬s)Ã—+`s
â”Œâ”€
â•µ 'a' ',' 'b' ',' 'c' ',' 'd' '\n' 'e' ',' 'f' ',' 'g' ',' 'h'
  Â¯1  Â¯1   0  Â¯1   1  Â¯1   2   Â¯1   3  Â¯1   4  Â¯1   5  Â¯1   6
                                                              â”˜</code></pre>
<p>Next on the agenda is splitting the split list <code>sl</code> itself according to line breaks.
For that we again do a depth scan, only this time we use the newline array <code>n</code>.</p>
<pre class="bqn"><code>    +`n
âŸ¨ 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 âŸ©</code></pre>
<p>Now we replicate the appropriate cells in this array according to <code>s</code>.
This yields a grouping of the different splitting characters into their respective lines.</p>
<pre class="bqn"><code>    inpâ‰+`n
â”Œâ”€
â•µ 'a' ',' 'b' ',' 'c' ',' 'd' '\n' 'e' ',' 'f' ',' 'g' ',' 'h'
   0   0   0   0   0   0   0    1   1   1   1   1   1   1   1
                                                              â”˜
    (s/inp)â‰(s/+`n)
â”Œâ”€
â•µ ',' ',' ',' '\n' ',' ',' ','
   0   0   0    1   1   1   1
                              â”˜</code></pre>
<p>Since we donâ€™t operate on the objects directly,
but rather on their â€œconnectionsâ€â€”I think of this a bit like a graphâ€”,
we additionally have to add a starting cell for the first object.</p>
<pre class="bqn"><code>    (0âˆ¾s/+`n) âŠ” sl
âŸ¨ âŸ¨ &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; âŸ© âŸ¨ &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; âŸ© âŸ©</code></pre>
<p>Putting it all together, we have something like</p>
<pre class="bqn"><code>CSV â† {
  [c,n] â† (','âˆ¾@+10) =âŒœ ğ•©
  s â† nâˆ¨c
  (0âˆ¾s/+`n) âŠ” (1-Ëœ(Â¬s)Ã—1+`s) âŠ” ğ•©
}</code></pre>
<p>which works as expected:<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<pre class="bqn"><code>    CSV &quot;aaaa,b,c,d&quot;âˆ¾(@+10)âˆ¾&quot;e,f&quot;
âŸ¨ âŸ¨ &quot;aaaa&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; âŸ© âŸ¨ &quot;e&quot; &quot;f&quot; âŸ© âŸ©</code></pre>
<h2 id="adding-escaping">Adding escaping</h2>
<p>If a field contains commas or newlines, they need to be escaped in some way.
The way that CSV handles this is that those fields are to be enclosed in double quotes:</p>
<pre><code>a,&quot;b,c
d,e&quot;</code></pre>
<p>This is a single line with two fields, one containing <code>a</code> and one containing <code>b,c,\nd,e</code>.
Within a quoted field, a <code>"</code> can be written as <code>""</code>;
the following example consists of a single field with value <code>"a","b"</code></p>
<pre><code>&quot;&quot;&quot;a&quot;&quot;,&quot;&quot;b&quot;&quot;&quot;</code></pre>
<p>In terms of parsing,
the first thing we need is to somehow figure out which characters are escaped.
Thankfully, this turns out to be pretty easyâ€”start in an unescaped setting,
and then every time a quote is encountered, flip some â€œare we quoted yet?â€-bit.
In code, this can rather beautifully be expressed as a not-equal scan:<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<pre class="bqn"><code>    inp â† &quot;a,&quot;&quot;b,&quot;&quot;&quot;&quot;b'&quot;&quot;&quot;&quot;,b''&quot;&quot;,c&quot;    # a,&quot;b,&quot;&quot;b&quot;&quot;,b''&quot;,c
&quot;a,&quot;&quot;b,&quot;&quot;&quot;&quot;b'&quot;&quot;&quot;&quot;,b''&quot;&quot;,c&quot;
    [q,c,n] â† ('&quot;'âˆ¾','âˆ¾@+10) =âŒœ inp
â”Œâ”€
â•µ 0 0 1 0 0 1 1 0 0 1 1 0 0 0 0 1 0 0   # quotes   q
  0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0   # commas   c
  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   # newlines n
                                      â”˜
    e â† â‰ `q                             # escaped
âŸ¨ 0 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 0 0 âŸ©
    inpâ‰e
â”Œâ”€
â•µ 'a' ',' '&quot;' 'b' ',' '&quot;' '&quot;' 'b' ''' '&quot;' '&quot;' ',' 'b' ''' ''' '&quot;' ',' 'c'
   0   0   1   1   1   0   1   1   1   0   1   1   1   1   1   0   0   0
                                                                         â”˜</code></pre>
<p>The next step is a little non obviousâ€”at least to me.
Instead of having a single variable <code>sâ†nâˆ¨c</code> that controls where to split the text,
we will instead have two: one for where to split, and one for which separators to drop.
The latter is needed because we donâ€™t actually want to keep all of the double quotes when parsing the CSV into a BQN type.
For example, the above <code>"a,""b,""""b'"""",b''"",c"</code> should parse to something like <code>âŸ¨"a"â€¿"b,""b'"",b''"â€¿"c"âŸ©</code>.</p>
<p>For splitting, we can use the exact same logic as in the first version of the parser,
now additionally taking into consideration the escaped flag.
Using the definitions from above:</p>
<pre class="bqn"><code>    inpâ‰ sâ†(Â¬e)âˆ§câˆ¨n  # split
â”Œâ”€
â•µ 'a' ',' '&quot;' 'b' ',' '&quot;' '&quot;' 'b' ''' '&quot;' '&quot;' ',' 'b' ''' ''' '&quot;' ',' 'c'
   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0
                                                                         â”˜</code></pre>
<p>Dropping is a little bit more finicky,
so letâ€™s start with something slightly simpler.
Essentially, we want to drop double quotes that are used to start an escaped field,
and only want to keep one pair of quotes on the inside of such a field.
The above mentioned transformation</p>
<pre><code>&quot;a,&quot;&quot;b,&quot;&quot;&quot;&quot;b'&quot;&quot;&quot;&quot;,b''&quot;&quot;,c&quot;   -&gt;   âŸ¨&quot;a&quot;â€¿&quot;b,&quot;&quot;b'&quot;&quot;,b''&quot;â€¿&quot;c&quot;âŸ©</code></pre>
<p>should illustrate what I mean.
One way to achieve this is to mark all last occurrences of double quotes,
along with all separators.</p>
<pre class="bqn"><code>    inpâ‰ dâ†sâˆ¨Â«âŠ¸&lt;q # what to drop
â”Œâ”€
â•µ 'a' ',' '&quot;' 'b' ',' '&quot;' '&quot;' 'b' ''' '&quot;' '&quot;' ',' 'b' ''' ''' '&quot;' ',' 'c'
   0   1   1   0   0   0   1   0   0   0   1   0   0   0   0   1   1   0
                                                                          â”˜</code></pre>
<p>Cutting up the input string now works essentially like the first version,
just that we have to take care where to insert <code>s</code> and where to insert <code>d</code> now.
Only â€œrealâ€ separators should increase the depth of an expression,
while for singling them out we have to consider all characters that are to be dropped.</p>
<pre class="bqn"><code>    1-Ëœ(Â¬d)Ã—1+`s
âŸ¨ 0 Â¯1 Â¯1 1 1 1 Â¯1 1 1 1 Â¯1 1 1 1 1 Â¯1 Â¯1 2 âŸ©
    (1-Ëœ(Â¬d)Ã—1+`s) âŠ” inp
âŸ¨ &quot;a&quot; &quot;b,&quot;&quot;b'&quot;&quot;,b''&quot; &quot;c&quot; âŸ©</code></pre>
<p>Likewise, when grouping the fields by line we have to be careful to only talk about unescaped newlines.</p>
<pre class="bqn"><code>    +`(Â¬e)âˆ§n
âŸ¨ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 âŸ©
    0âˆ¾s/+`(Â¬e)âˆ§n
âŸ¨ 0 0 0 âŸ©
    (0âˆ¾s/+`(Â¬e)âˆ§n) âŠ” (1-Ëœ(Â¬d)Ã—1+`s) âŠ” inp
âŸ¨ âŸ¨ &quot;a&quot; &quot;b,&quot;&quot;b'&quot;&quot;,b''&quot; &quot;c&quot; âŸ© âŸ©
</code></pre>
<p>All in all, the second version of our CSV function looks like this:</p>
<pre class="bqn"><code>CSV â‡ {
  [q,c,n] â† ('&quot;'âˆ¾','âˆ¾@+10) =âŒœ ğ•©        # Quote, comma, LF
  e â† â‰ `q                              # Escapes
  s â† (Â¬e)âˆ§nâˆ¨c                         # Where to split
  d â† sâˆ¨Â«âŠ¸&lt;q                           # What to drop
  (0âˆ¾s/+`(Â¬e)âˆ§n) âŠ” (1-Ëœ(Â¬d)Ã—1+`s) âŠ” ğ•©  # First split all, then split lines
}</code></pre>
<hr />
<p>This works in almost all cases already,
though there is some unexpected behaviour surrounding empty fields:</p>
<pre class="bqn"><code>    CSV &quot;a,,b&quot;
â”Œâ”€
Â· âŸ¨ &quot;a&quot; âŸ¨âŸ© &quot;b&quot; âŸ©
                 â”˜
    CSV &quot;a,&quot;&quot;&quot;&quot;,b&quot;
âŸ¨ âŸ¨ &quot;a&quot; &quot;&quot;&quot;&quot; &quot;b&quot; âŸ© âŸ©</code></pre>
<p>Those two expressions should probably be equivalent.
Since we already mark the last occurrences of each quote,
we just have to make sure that we additionally mark those that are also escaped.
Changing</p>
<pre class="bqn"><code>  d â† sâˆ¨Â«âŠ¸&lt;q                           # What to drop</code></pre>
<p>to</p>
<pre class="bqn"><code>  d â† sâˆ¨qâˆ§eâˆ¨Â«âŠ¸&lt;q                       # What to drop</code></pre>
<p>now parses both cases correctly:</p>
<pre class="bqn"><code>    (CSV &quot;a,,b&quot;) â‰¡ CSV &quot;a,&quot;&quot;&quot;&quot;,b&quot;
1</code></pre>
<hr />
<p>Here are some exercises for the interested reader:</p>
<ol type="1">
<li><p>Generalise the <code>CSV</code> function to take arbitrary separators instead of just a comma.
This can rather elegantly be achieved by making it an ambivalent function,
with the monadic case just being <code>',' CSV ğ•©</code>.</p></li>
<li><p>Add some failure states, like actually honouring</p>
<blockquote>
<p>Each line should contain the same number of fields throughout the file.</p>
</blockquote>
<p>from the RFC.
This could just use
<a href="https://mlochbaum.github.io/BQN/doc/assert.html">assert</a>
to print an error message to the user.</p></li>
<li><p>Iâ€™ve very efficiently ignored that CRLF line endings exist, so I guess that oneâ€™s still missing?</p></li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>Q: Is writing (and reading) a parser in an array language unnecessarily hard?<br />
A: Yes.</p>
<p>Q: Is it the most fun Iâ€™ve had programming in a long time?<br />
A: Yes.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>For the sake of convenience, I will interpret the RFC somewhat loosely in places,
though hopefully still implementing the gist of it.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>BQN doesnâ€™t actually escape non-double-quote characters in strings,
but Iâ€™ve chosen to write <code>\n</code> here instead of a literal newline for readability.</p>
<p>Also, I will use
<a href="https://mlochbaum.github.io/BQN/doc/couple.html">couple</a>
quite a bit to visualise the different masks in relation to the original character array going in,
in case you were wondering what that glyph meant.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>Since BQN doesnâ€™t do escaping in strings,
I make use of
<a href="https://mlochbaum.github.io/BQN/doc/types.html#characters">character arithmetic</a>
here, to represent the line feed by its decimal value.<a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p>As you can see, escaping isâ€¦ fun.
Every character save a double quote is verbatim in BQN strings,
and double quotes are also escaped using two of them in succession.
This means that to input the CSV <code>"a"</code>, one would write <code>"""a"""</code>,
and for <code>"""a"",""b"""</code> we have the wonderful
<code>"""""""a"""",""""b"""""""</code>.<a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>

      <!-- Body is included in the above file -->
    </section>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Integer Volutes in BQN</title>
    <link href="https://tony-zorman.com/posts/volutes-in-bqn.html" />
    <id>https://tony-zorman.com/posts/volutes-in-bqn.html</id>
    <published>2024-11-08T00:00:00Z</published>
    <updated>2024-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <div class="header">
      8th Nov 2024â€“13 Nov 2024
      
        &nbsp;&nbsp;Â·&nbsp;&nbsp;&nbsp;<span title="3093 words">13 min read</span>&nbsp;&nbsp;&nbsp;Â·&nbsp;&nbsp;
      
      
        <a title="All pages tagged '#BQN'." href="/tags/BQN.html" rel="tag">#BQN</a>Â Â Â <a title="All pages tagged '#array-lang'." href="/tags/array-lang.html" rel="tag">#array-lang</a>
      
    </div>
    <h1 class="post-title">Integer Volutes in BQN</h1>
    <div id="title-underline"></div>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  

<p>On <a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-3">day 3</a>
of my post about doing some
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html">Advent of Code problems in BQN</a>,
the task was to walk along some <em>integer volutes</em>:
spirals, either spiralling inwardsâ€”involutesâ€”or outwardsâ€”evolutesâ€”in either direction.
While the specific problem didnâ€™t require it,
I think itâ€™s a pretty neat exercise to think about how to generate these things.
Letâ€™s talk about that.</p>
<!--more-->
<p>For example, the following is a left-spiraling evolute.</p>
<pre class="bqn"><code>    Evolute 9
â”Œâ”€
â•µ 64 63 62 61 60 59 58 57 56
  65 36 35 34 33 32 31 30 55
  66 37 16 15 14 13 12 29 54
  67 38 17  4  3  2 11 28 53
  68 39 18  5  0  1 10 27 52
  69 40 19  6  7  8  9 26 51
  70 41 20 21 22 23 24 25 50
  71 42 43 44 45 46 47 48 49
  72 73 74 75 76 77 78 79 80
                             â”˜</code></pre>
<p>Quite pretty, isnâ€™t it?</p>
<p>Before we start, a big disclaimer:
this is neither my work, nor did I come up with any of the novel insights presented here.
Rather, there is an article by Eugene McDonnell (available
<a href="https://code.jsoftware.com/wiki/Doc/Articles/Play132">here</a>
or <a href="https://www.jsoftware.com/papers/play132.htm">here</a>)
who talks about a solution to this problem by Joey Tuttle.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
Both of the links above are not entirely satisfactory digitisations of the original article,
so in writing this post Iâ€™m trying to contribute a perhaps more palatable version.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>This post is written in the REPL-like fashion that Iâ€™ve already used above:
input is indented by four spaces,
and output is flush to the left.
As such, there will be lots of examples that highlight certain aspects of the current sub-problem to be solved.</p>
<p>Finally, the article probably wonâ€™t make much sense unless you know a little bit of BQN already,
the basics of which are probably best learned from the
<a href="https://mlochbaum.github.io/BQN/">official website</a>.</p>
<h2 id="the-coordinate-based-solution">The coordinate based solution</h2>
<p>Letâ€™s initially produce a coordinate-based solution.
Our first sub-goal is to generate the correct indices in order.
Put the origin <code>âŸ¨0 0âŸ©</code> into the middle, at the number <code>0</code>.
Our coordinate system will be that of indexing into the array; i.e.,
<code>0â€¿1</code>, <code>Â¯1â€¿0</code>, <code>0â€¿Â¯1</code>, and <code>1â€¿0</code> represent east, north, west, and south, respectively.
Looking at the 9Ã—9 spiral above,
letâ€™s think about what kind of steps weâ€™re taking:</p>
<pre><code>0  -E-&gt;  1  -N-&gt;  2  -W-&gt;  3  -W-&gt;  4  -S-&gt;  5  -S-&gt;  6  -E-&gt;  7  -E-&gt;  8 â€¦</code></pre>
<p>Just writing out the directions yields something like <code>ENWWSSEEENNNWWWWSSSSâ€¦</code>.
We alternate between east, north, west, and south in that order,
and always bunch up two of them with the same frequencyâ€”first one, then two, etc.
In particular, we â€œbreak intoâ€ a new iteration in the spiralling
every time a number is increased:</p>
<pre><code>0     0 1       2     4 3 2     4 3 2     4 3 2
              0 1       0 1     5 0 1     5 0 1
                                6         6 7 8 9</code></pre>
<p>If we want to end up with a square,
our sequence would look like <span class="math inline">1, 1, 2, 2, â€¦ k-1, k-1, k, k, k</span>;
repeating the last number three times instead of continuing with <span class="math inline">k+1</span>.</p>
<p>All in all, we need to generate two sequences of numbers:
the coordinates, and their associated frequencies.
Given a grid of size <span class="math inline">n</span>, some quick maths tells us that
we have to generate a sequence with <span class="math inline">2n - 1</span> directions.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<pre class="bqn"><code>    { (1-Ëœğ•©Ã—2)â¥ŠâŸ¨0â€¿1,Â¯1â€¿0,0â€¿Â¯1,1â€¿0âŸ© } 3 # Generate this many indices
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 0 1 âŸ© âŸ©
    {(ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1} 3 # Double with an extra bit at the end
âŸ¨ 1 1 2 2 2 âŸ©</code></pre>
<p>For doubling a given vector of numbers,
we can conveniently use
<em>replicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/replicate.html"><code>/</code></a>),
and then manually add the number that should be repeated three times to the end.</p>
<pre class="bqn"><code>    { ğ•Šn: # Smush everything together.
      ((n-1)âˆ¾Ëœ2/1+â†•n-1){&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨(1-ËœnÃ—2)â¥ŠâŸ¨0â€¿1,Â¯1â€¿0,0â€¿Â¯1,1â€¿0âŸ©
    } 3
â”Œâ”€
Â· âŸ¨ âŸ¨ 0 1 âŸ© âŸ© âŸ¨ âŸ¨ Â¯1 0 âŸ© âŸ© âŸ¨ âŸ¨ 0 Â¯1 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ© âŸ¨ âŸ¨ 1 0 âŸ© âŸ¨ 1 0 âŸ© âŸ© âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 0 1 âŸ© âŸ©
                                                                                         â”˜
    { ğ•Šn: # Flatten.
      âˆ¾((n-1)âˆ¾Ëœ2/1+â†•n-1){&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨(1-ËœnÃ—2)â¥ŠâŸ¨0â€¿1,Â¯1â€¿0,0â€¿Â¯1,1â€¿0âŸ©
    } 3
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 âŸ© âŸ©</code></pre>
<p>Smushing everything together works by
<em>reshaping</em> (<a href="https://mlochbaum.github.io/BQN/doc/reshape.html"><code>â¥Š</code></a>)
the vector of length two into an array with two columns,
and as many rows as the desired frequency.
Flattening everything is done by calling
<em>enclose</em> (<a href="https://mlochbaum.github.io/BQN/doc/enclose.html"><code>&lt;</code></a>)
on each major cell.</p>
<pre class="bqn"><code>    3 {ğ•¨â€¿2â¥Šğ•©} Â¯1â€¿0
â”Œâ”€
â•µ Â¯1 0
  Â¯1 0
  Â¯1 0
       â”˜
    3 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©} Â¯1â€¿0
âŸ¨ âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ©</code></pre>
<p>This yields the function to generate a vector of directions.</p>
<pre class="bqn"><code>    Dirs â† { ğ•Šn: # Directions for an nÃ—n grid
      âˆ¾((ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1){&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨(1-ËœnÃ—2)â¥ŠâŸ¨0â€¿1,Â¯1â€¿0,0â€¿Â¯1,1â€¿0âŸ©
    }
(function block)</code></pre>
<p>To get the coordinates, we just have to â€œwalk the pathâ€â€”that is,
compute the
<code>+</code>-<em>scan</em> (<a href="https://mlochbaum.github.io/BQN/doc/scan.html"><code>`</code></a>)
and add the origin.</p>
<pre class="bqn"><code>    Coords â† { (&lt;0â€¿0)âˆ¾ +` Dirsğ•© }
(function block)
    Coords 3
âŸ¨ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ Â¯1 1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 Â¯1 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ¨ 1 Â¯1 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ©</code></pre>
<p>These coordinates are associated to the numbers that their respective index represents:
<code>0</code> for <code>âŸ¨0 0âŸ©</code>, <code>1</code> for <code>âŸ¨0 1âŸ©</code>, and so on.</p>
<pre class="bqn"><code>    (â†•9) â‰ Coords 3
â”Œâ”€
â•µ 0       1       2        3        4         5        6        7       8
  âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ Â¯1 1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 Â¯1 âŸ© âŸ¨ 0 Â¯1 âŸ© âŸ¨ 1 Â¯1 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ©
                                                                                â”˜</code></pre>
<p>All thatâ€™s left to do is to <em>reshape</em> the argument into the correct form.
This uses the fact that coordinates have a nice lexicographic ordering.</p>
<pre class="bqn"><code>    â†•3â€¿3          # Origin top left
â”Œâ”€
â•µ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ©
  âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ©
  âŸ¨ 2 0 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 2 2 âŸ©
                          â”˜
    (â†•3â€¿3) - &lt;1â€¿1 # Origin in the middle, where we want it
â”Œâ”€
â•µ âŸ¨ Â¯1 Â¯1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 1 âŸ©
  âŸ¨ 0 Â¯1 âŸ©  âŸ¨ 0 0 âŸ©  âŸ¨ 0 1 âŸ©
  âŸ¨ 1 Â¯1 âŸ©  âŸ¨ 1 0 âŸ©  âŸ¨ 1 1 âŸ©
                              â”˜</code></pre>
<p>We first order the coordinates by their columns (the first number), and then by their rows (the second).
A verbose way of doing that would be the following:<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<pre class="bqn"><code>    (Coords 3) â‹ˆÂ¨ â†•9        # Zip coordinates to indices
â”Œâ”€
Â· âŸ¨ âŸ¨ 0 0 âŸ© 0 âŸ© âŸ¨ âŸ¨ 0 1 âŸ© 1 âŸ© âŸ¨ âŸ¨ Â¯1 1 âŸ© 2 âŸ© âŸ¨ âŸ¨ Â¯1 0 âŸ© 3 âŸ© âŸ¨ âŸ¨ Â¯1 Â¯1 âŸ© 4 âŸ©
  âŸ¨ âŸ¨ 0 Â¯1 âŸ© 5 âŸ© âŸ¨ âŸ¨ 1 Â¯1 âŸ© 6 âŸ© âŸ¨ âŸ¨ 1 0 âŸ© 7 âŸ© âŸ¨ âŸ¨ 1 1 âŸ© 8 âŸ©
                                                                            â”˜
    âˆ§ (Coords 3) â‹ˆÂ¨ â†•9      # Sort
â”Œâ”€
Â· âŸ¨ âŸ¨ Â¯1 Â¯1 âŸ© 4 âŸ© âŸ¨ âŸ¨ Â¯1 0 âŸ© 3 âŸ© âŸ¨ âŸ¨ Â¯1 1 âŸ© 2 âŸ© âŸ¨ âŸ¨ 0 Â¯1 âŸ© 5 âŸ© âŸ¨ âŸ¨ 0 0 âŸ© 0 âŸ©
  âŸ¨ âŸ¨ 0 1 âŸ© 1 âŸ© âŸ¨ âŸ¨ 1 Â¯1 âŸ© 6 âŸ© âŸ¨ âŸ¨ 1 0 âŸ© 7 âŸ© âŸ¨ âŸ¨ 1 1 âŸ© 8 âŸ©
                                                                            â”˜
    1âŠ‘Â¨ âˆ§ (Coords 3) â‹ˆÂ¨ â†•9  # Get indices
âŸ¨ 4 3 2 5 0 1 6 7 8 âŸ©
    3â€¿3â¥Š1âŠ‘Â¨âˆ§(Coords 3)â‹ˆÂ¨â†•9  # Reshape
â”Œâ”€
â•µ 4 3 2
  5 0 1
  6 7 8
        â”˜</code></pre>
<p>This works, but feels a bit unsatisfactory.
We seem to be doing a lot of extra work just to get the correct ordering of the indices.
Luckily, BQN has a primitive functionâ€”two, actuallyâ€”that exactly encapsulates operations like the above:
a <em>grade</em>.
Briefly,
given an array with major cells <span class="math inline">(c_1, \dots, c_n)</span>,
<em>grade up</em> (<a href="https://mlochbaum.github.io/BQN/doc/order.html#grade"><code>â‹</code></a>)
returns a permutation <span class="math inline">(i_1, \dots, i_n)</span> of the indices,
which yields the order that would sort the cells:
<span class="math inline">c_{i_1}</span> is the smallest element, <span class="math inline">c_{i_2}</span> is the second smallest, and so on.
This can be used to sort the vector by <em>picking</em> each <span class="math inline">i_j</span> in order.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<pre class="bqn"><code>    a â† âŸ¨3,1,0,4,4,6,7,19,16âŸ©
âŸ¨ 3 1 0 4 4 6 7 19 16 âŸ©
    g â† â‹a
âŸ¨ 2 1 0 3 4 5 6 8 7 âŸ©
    (âŠ‘g)âŠ‘a    # smallest element
0
    (Â¯1âŠ‘g)âŠ‘a  # Largest element
19
    gâŠa       # Sort: g is a vector of indices into a
âŸ¨ 0 1 3 4 4 6 7 16 19 âŸ©
    # Grading is the same as sorting and getting the indices
    (â‹a) â‰¡ 1âŠ‘Â¨âˆ§aâ‹ˆÂ¨â†•9
1</code></pre>
<p>Putting everything together, we can write the first version of <code>Evolute</code>.</p>
<pre class="bqn"><code>    Evolute â† { ğ•©â€¿ğ•©â¥Š â‹ Coordsğ•© }
(function block)
    Evolute 3
â”Œâ”€
â•µ 4 3 2
  5 0 1
  6 7 8
        â”˜
    Evolute 5
â”Œâ”€
â•µ 16 15 14 13 12
  17  4  3  2 11
  18  5  0  1 10
  19  6  7  8  9
  20 21 22 23 24
                 â”˜</code></pre>
<p>Nice.</p>
<h2 id="a-flat-solution">A flat solution</h2>
<p>While I think <code>Evolute</code> is quite neat,
a fun aspect of array programming is to come up with
<a href="https://saltysylvi.github.io/blog/flat1.html">completely</a>
<a href="https://saltysylvi.github.io/blog/flat2.html">flat</a>
solutions to problems.
That is, solutions that do not use any nested arraysâ€”like vectors of coordinatesâ€”whatsoever.
This is often much more efficient,
and may yield new insights in how the problem actually works.
Plus, working in a more constrained setting can be fun just in and of itself.</p>
<p>Letâ€™s start with the flat version of the completed spiral.</p>
<pre class="bqn"><code>    spiral â† â¥ŠEvolute 3
âŸ¨ 4 3 2 5 0 1 6 7 8 âŸ©</code></pre>
<p>Naively, the general strategy is this:
throw transformations <code>fáµ¢</code> at <code>spiral</code>
until we arrive at some vector <code>v</code> that is reasonably easy to generate;
i.e., <code>v â‰¡ fâ‚ â€¦ fâ‚™ spiral</code>.
Then, invert all of the <code>fáµ¢</code> to re-generate the original vector:
<code>spiral â‰¡ fâ‚™â»Â¹ â€¦ fâ‚â»Â¹ v</code>.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>
As far as I can tell, one just needs enough intuition about these flat arrays to guess nice enough functions.</p>
<p>Now, from the first solution we already know that <code>spiral</code> is the <em>grade</em> of some list of coordinates,
which we however have no hope of recovering.
After enough staring, one notices that <code>spiral</code> itself looks like a permutation<!--
-->â€”why not try to find the inverse of that?
Thankfully this is very easy, as <em>grade up</em> is self-inverse in this case:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<pre class="bqn"><code>    â‹â‹spiral
âŸ¨ 4 3 2 5 0 1 6 7 8 âŸ©
    spiralâ‰¡â‹â‹spiral
1
    â‹spiral # This is the permutation we want.
âŸ¨ 4 5 2 1 0 3 6 7 8 âŸ©</code></pre>
<p>I think that <code>â‹spiral</code> doesnâ€™t look any less random than <code>spiral</code>,
but Tuttle evidently saw something,
and instead checked whether this list was the running sum of a good one;
i.e., whether there exists some nice <code>y</code> such that <code>(â‹spiral) â‰¡ +`y</code>.
This in particular means that we have to compute the inverse of <code>+`</code>:
subtract each element from its predecessor, or <code>-âŸœÂ»</code> for short.</p>
<pre class="bqn"><code>    -âŸœÂ» â‹spiral
âŸ¨ 4 1 Â¯3 Â¯1 Â¯1 3 3 1 1 âŸ©
    +` -âŸœÂ» â‹spiral
âŸ¨ 4 5 2 1 0 3 6 7 8 âŸ©
    (â‹spiral) â‰¡ (+`-âŸœÂ»â‹spiral)
1</code></pre>
<p>In fact, we can even ask BQN to do this for us by means of
<em>undo</em> (<a href="https://mlochbaum.github.io/BQN/doc/undo.html"><code>â¼</code></a>).</p>
<pre class="bqn"><code>    +`â¼ â‹spiral
âŸ¨ 4 1 Â¯3 Â¯1 Â¯1 3 3 1 1 âŸ©</code></pre>
<p>Finally, this looks like something we can generate!
Letâ€™s take a look at a 5Ã—5 grid, so the structure becomes even more obvious:</p>
<pre class="bqn"><code>    +`â¼â‹â¥ŠEvolute 5
âŸ¨ 12 1 Â¯5 Â¯1 Â¯1 5 5 1 1 1 Â¯5 Â¯5 Â¯5 Â¯1 Â¯1 Â¯1 Â¯1 5 5 5 5 1 1 1 1 âŸ©</code></pre>
<p>Ignoring the number at the start, we have an alternation of <code>1 Â¯n Â¯1 n</code>, where <code>n</code> is the size of the evolute.
Disregarding multiple occurrences and the first number,
there are exactly <code>(2Ã—n)-1</code> â€œprimitiveâ€ numbers
to which we need to associate frequencies,
which matches with the coordinate generation from before.</p>
<pre class="bqn"><code>    { (1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© } 3
âŸ¨ 1 Â¯3 Â¯1 3 1 âŸ©
    { (1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© } 5
âŸ¨ 1 Â¯5 Â¯1 5 1 Â¯5 Â¯1 5 1 âŸ©</code></pre>
<p>These numbers grow in their frequency in blocks of two; first one of each, then two, and so on.
Everything here is entirely analogous to the coordinate case,
including the fact that we need to repeat the last number three times in order to obtain a square grid.</p>
<pre class="bqn"><code>    { 2/1+â†•ğ•©-1 } 5
âŸ¨ 1 1 2 2 3 3 4 4 âŸ©
    { (ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1 } 5 # Need correcting term at the end
âŸ¨ 1 1 2 2 3 3 4 4 4 âŸ©
    { ((ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1)/(1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© } 3
âŸ¨ 1 Â¯3 Â¯1 Â¯1 3 3 1 1 âŸ©</code></pre>
<p>As for the first number that we ignored so far: itâ€™s not actually important!
What we do with this list is a <code>+</code>-<em>scan</em>, followed by a <em>grade up</em> to sort the indices.
This means that only the relative value of the <em>scan</em> is important for the following <em>grade</em>,
so outside of special cases like <code>âˆ</code>, the first number could be almost anything.</p>
<pre class="bqn"><code>    { 0âˆ¾((ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1)/(1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© } 5
âŸ¨ 0 1 Â¯5 Â¯1 Â¯1 5 5 1 1 1 Â¯5 Â¯5 Â¯5 Â¯1 Â¯1 Â¯1 Â¯1 5 5 5 5 1 1 1 1 âŸ©</code></pre>
<p>In particular, this opens up a nice shortcut.
Instead of manually adding <code>ğ•©-1</code> to the back and <code>0</code> to the front,
we can just add <code>ğ•©</code> itself to the back,
and then <em>nudge</em> the whole array to the right,
inserting the filler <code>0</code> as the first element.</p>
<pre class="bqn"><code>    { 0âˆ¾((ğ•©-1)âˆ¾Ëœ2/1+â†•ğ•©-1) } 5
âŸ¨ 0 1 1 2 2 3 3 4 4 4 âŸ©
    { Â»(ğ•©âˆ¾Ëœ2/1+â†•ğ•©-1) } 5
âŸ¨ 0 1 1 2 2 3 3 4 4 âŸ©
    { Â»(Â¯1â†“2/1+â†•ğ•©) } 5
âŸ¨ 0 1 1 2 2 3 3 4 4 âŸ©
    { Â»(Â¯1â†“2/1+â†•ğ•©)/(1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© } 5
âŸ¨ 0 1 Â¯5 Â¯1 Â¯1 5 5 1 1 1 Â¯5 Â¯5 Â¯5 Â¯1 Â¯1 Â¯1 Â¯1 5 5 5 5 1 1 1 1 âŸ©</code></pre>
<p>We obtain a completely flat version of <code>Evolute</code>,
which works just like the original function.</p>
<pre class="bqn"><code>    EvoluteFlat â† { ğ•©â€¿ğ•©â¥Šâ‹+`Â»(Â¯1â†“2/1+â†•ğ•©)/(1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ© }
(function block)
    EvoluteFlat 3
â”Œâ”€
â•µ 4 3 2
  5 0 1
  6 7 8
        â”˜
    EvoluteFlat 5
â”Œâ”€
â•µ 16 15 14 13 12
  17  4  3  2 11
  18  5  0  1 10
  19  6  7  8  9
  20 21 22 23 24
                 â”˜</code></pre>
<p>Getting a rightwards spiral just involves
twiddling with the vector <code>âŸ¨1,-ğ•©,Â¯1,ğ•©âŸ©</code> a little bit.
Iâ€™ll leave that as an exercise for the interested reader.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Here are complete definitions of both solutions.</p>
<pre class="bqn"><code>E1 â† {ğ•©â€¿ğ•©â¥Šâ‹(&lt;0â€¿0)âˆ¾+`âˆ¾((2/1+â†•ğ•©-2)âˆ¾3â¥Šğ•©-1){&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨(1-Ëœğ•©Ã—2)â¥ŠâŸ¨0â€¿1,Â¯1â€¿0,0â€¿Â¯1,1â€¿0âŸ©}
E2 â† {ğ•©â€¿ğ•©â¥Šâ‹+`Â»(Â¯1â†“2/1+â†•ğ•©)/(1-Ëœ2Ã—ğ•©)â¥ŠâŸ¨1,-ğ•©,Â¯1,ğ•©âŸ©}</code></pre>
<p>I certainly think that <code>E2</code> is much prettier than <code>E1</code>;
not only because itâ€™s shorter, but also because there seems to be less wrangling to get everything to line up correctly.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
Seeing these side by side does reveal that they use a lot of the same techniques,
however, which I think is interesting.</p>
<hr />
<p>As a bonus, here is the mandatory golfed solution,
this time as an involute.</p>
<pre class="bqn"><code>    G â† {(âŠ’Ëœâˆ¾â‰âˆ˜âŒ½+â‰ )âŸ2âŸğ•©â†•0â€¿0}
(function block)
    SLG â† {(â†•âˆ˜â‰ âˆ¾â‰âˆ˜âŒ½+â‰ )âŸ(2Ã—ğ•©)â†•0â€¿0} # Slighly less golfed
(function block)
    G 5
â”Œâ”€
â•µ  0  1  2  3 4
  15 16 17 18 5
  14 23 24 19 6
  13 22 21 20 7
  12 11 10  9 8
                â”˜
    (SLG 5) â‰¡ G 5
1</code></pre>
<p>I will leave it to the interested reader to figure out that oneâ€”or to consult the
<a href="https://codegolf.stackexchange.com/questions/241803/print-a-nxn-integer-involute">relevant StackExchange thread</a>,
which I perhaps should have looked up before writing this whole thing.
Still, all of this transposing and reversing the matrix means that this solution is on the slower side.
Hereâ€™s a quick an dirty comparison:</p>
<pre class="bqn"><code>    )time G   1000  # Golfed version
1.0114s
    )time G   2000
13.885s
    )time SLG 1000  # Slightly less golfed version
651.3ms
    )time SLG 2000
8.1603s
    )time E1  1000  # Using indices
218ms
    )time E1  2000
950.2ms
    )time E2  1000  # Flat
4.197ms
    )time E2  2000
12.98ms</code></pre>
<p>While both are cubic and thus degrade fast,
<code>SLG</code> is faster than <code>G</code> because <code>â†•â‰ </code> to generate a list of integers is much quicker than some <em>progressive index of</em> shenanigans to do the same thing.
At the end of the day, I think I prefer the flat solution :)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Special thanks to Marshall Lochbaum for providing these links.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>Plus, I donâ€™t know any J, so reading the article in detail is a lot more work than just writing it in BQN myself.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>The frequencies have to add up to <span class="math inline">n^2 - 1</span>, covering all points but the origin.
A given sequence <span class="math inline">1, 1, 2, 2, \dots, k-1, k-1, k, k, k</span> has <span class="math inline">2k + 1</span> members
and sums up to <span class="math inline">k^2 + 2k</span>.
Solving <span class="math inline">k^2 + 2k = n^2 - 1</span> for <span class="math inline">k</span> has sensible roots,
<span class="math inline">\pm n - 1</span>, of which we of course pick <span class="math inline">n-1</span>.
Substituting <span class="math inline">k=n-1</span>,
we have to generate <span class="math inline">2n - 1</span> frequencies,
the values of which indeed sum up to <span class="math inline">(n-1)^2 + 2(n-1) = n^2 - 1</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p>Line breaks in the output for clarity.<a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn5"><p>In fact, in APL this is the only way to do thisâ€”there is no other sorting primitive!<a href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn6"><p>Note that, in particular, we are interested in left inverses of all the <code>fáµ¢</code>.
This is a bit in opposition to the facilities that BQN provides by default, like
<em>undo</em> to find the right inverse.
However, weâ€™ll manage.<a href="#fnref6" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn7"><p>A quick justification:
suppose that we have a vector <span class="math inline">n \defeq (n_1, \dots, n_k)</span> of natural numbers,
such that every number from <span class="math inline">0</span> to <span class="math inline">k-1</span> appears exactly once.
Using <em>grade up</em>, we obtain a permutation <span class="math inline">\sigma \defeq (i_1, \dots, i_k)</span>.
If one <em>grades</em> that permutation in the same direction,
then whatever index <span class="math inline">i_j</span> has value <span class="math inline">0</span>
will be the very first element of the new permutation <span class="math inline">\tau \defeq (i_j, \dots, i_\ell)</span>,
and likewise for the other numbers.
Thus, <span class="math inline">\tau \sigma (n) = n</span>.</p>
<p>Of course, <code>â‹â‹</code> it not the identity in general, but it is a useful operation nonetheless:
it â€œranksâ€ the elements of the input,
with <code>0</code> corresponding to the smallest element, and so on.
This is known as the
<a href="https://mlochbaum.github.io/BQN/doc/order.html#ordinals">ordinal idiom</a>.<a href="#fnref7" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn8"><p>Looking at <a href="https://mlochbaum.github.io/bqncrate/">BQNcrate</a>,
one could even shorten <code>E2</code> a little further:</p>
<pre class="bqn"><code>E3 â† {ğ•©â€¿ğ•©â¥Šâ‹+`Â»(Â¯1â†“2/1+â†•ğ•©)(âŠ£/â‰ âŠ¸â¥Š)âŸ¨1,-ğ•©,Â¯1,ğ•©âŸ©}</code></pre>
<p>This <em>reshapes</em> the list <code>âŸ¨1,-ğ•©,Â¯1,ğ•©âŸ©</code> according to the length of <code>Â¯1â†“2/1+â†•ğ•©</code>,
without us having to explicitly specify that it will be <code>1-Ëœ2Ã—ğ•©</code>.
I think, however, that arriving at this number yields some insights that one would otherwise not have had,
so I prefer leaving it in the final solution.<a href="#fnref8" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>

      <!-- Body is included in the above file -->
    </section>
    
</article>
]]></summary>
</entry>
<entry>
    <title>BQNing Advent of Code</title>
    <link href="https://tony-zorman.com/posts/aoc-in-bqn.html" />
    <id>https://tony-zorman.com/posts/aoc-in-bqn.html</id>
    <published>2024-10-27T00:00:00Z</published>
    <updated>2024-10-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <div class="header">
      27th Oct 2024â€“28 Oct 2024
      
        &nbsp;&nbsp;Â·&nbsp;&nbsp;&nbsp;<span title="22372 words">90 min read</span>&nbsp;&nbsp;&nbsp;Â·&nbsp;&nbsp;
      
      
        <a title="All pages tagged '#BQN'." href="/tags/BQN.html" rel="tag">#BQN</a>Â Â Â <a title="All pages tagged '#array-lang'." href="/tags/array-lang.html" rel="tag">#array-lang</a>
      
    </div>
    <h1 class="post-title">BQNing Advent of Code</h1>
    <div id="title-underline"></div>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  

<p>I did all of Advent of Code 2017 in <a href="https://mlochbaum.github.io/BQN">BQN</a> so you donâ€™t have to.
Let me tell you about that in as few as 20â€™000 words.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<!--more-->
<h2 id="the-setup">The setup</h2>
<p>Advent of Code is a yearly puzzle-coding-challenge-thing,
in which one has to solve two riddles every day from the 1st until the 25th of December,
with the second part of each puzzle being unknown until one solves the first one.
Iâ€™ve found it to be a great way to learn the basics of a languageâ€”how it â€œfeelsâ€.</p>
<p>The puzzles are accompanied by an endearingâ€”and at times pretty funnyâ€”story.
I will, however, leave out most of it for this post,
as I feel like it would distract too much from the point Iâ€™m trying to make.</p>
<h3 id="conventions-throughout-the-article">Conventions throughout the article</h3>
<p>One thing I will not leave out is the full solution for every day.
Normally this would result in a rather large amount of code having to be shown for the later days,
but BQNâ€™s terseness saves us here:
excluding comments and empty lines, all days combined are just under 300 lines of code!
I will be a tiny bit economical with the different parts, though;
think of every heading as introducing its own namespace.
For example,
in the code block solving the first part of every day I will generally include parsing the input.</p>
<pre class="bqn"><code>inp â† â€¦
# Hypothetical solution for first part
inp - 1</code></pre>
<p>The second part will then freely refer to <code>inp</code> without me having to define it again.</p>
<pre class="bqn"><code># Second part
inp + 1</code></pre>
<h3 id="who-reads-all-of-this-anyways">Who reads all of this anyways?</h3>
<p>A surprisingly hard question is who this article is for.
Someone new to Advent of Code, but familiar with BQN?
The other way around?
New to both?
Familiar with both?
The answerâ€”as is so often the caseâ€”is that I donâ€™t know.
Realistically, Iâ€™m actually talking to my present and future self here<!--
-->â€”writing about things is a great way to solidify understandingâ€”<!--
-->so the article will be structured accordingly:
I will talk about BQNâ€™s core concepts and language features,
but put the more dreary parts of that exposition in collapsible boxes,
for people who either already know, or donâ€™t care.</p>
<p>Keep in mind that I started solving these puzzles to learn the language.
Further, BQN is my very first array programming language,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
so my understanding of a lot of concepts is still quite shallow.
The official documentation is really quite good, so I will link to it a lot.
As mentioned, the tangents in which I talk about language features are more for my own understanding.
Still, perhaps they are useful in case someone who does not know BQN has somehow found their way here,
and didnâ€™t run away after seeing the Unicode characters.
As such, the focus of this post should be on how I<!--
-->â€”as a total newcomer to this kind of thingâ€”<!--
-->approach solving problems in such an unusual language;
what works and what doesnâ€™t, that kind of thing.
In short, I want to impart the <em>vibe</em> of the language to the reader<!--
-->â€”and that AOC is actually a lot of fun!<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>I want to explicitly thank the super welcoming
<a href="https://mlochbaum.github.io/BQN/community/index.html">community</a>
that this language has!
Next to fantastic sites such as <a href="https://mlochbaum.github.io/bqncrate/">BQNcrate</a><!--
-->â€”a great way to pick up on idiomatic ways to write certain thingsâ€”<!--
-->there is a
<a href="https://app.element.io/#/room/%23bqn:matrix.org">#bqn:matrix.org</a>
matrix room, which is part of the larger
<a href="https://app.element.io/#/room/%23array:matrix.org">#array:matrix.org</a> space.
Someone knowledgeable is always there to answer your stupid questions.
Special thank to
Marshall Lochbaum (the creator of the language!),
dzaima, and
brian_e.
Without them a lot of solutions presented here would be even uglier than they already are.
A separate big thanks goes out to dzaima (again!)
for sending me lots of code improvements and suggestions for this post.</p>
<h2 id="a-crash-course-on-syntax">A crash course on syntax</h2>
<p>Here is an entirely too short crash course on the syntax of the language,
with a bit of semantics sprinkled in here and there.
Throughout, I will present most examples in a REPL-esque fashion;
input is indented by 4 spaces, and output is flush to the left.
Line comments in BQN start with <code>#</code>.</p>
<pre class="bqn"><code>    1+4+6 # Everything normal so farâ€¦
11
    2Ã—4+6 # â€¦but actually not!
20</code></pre>
<p>That last one probably already needs explanation.
First, multiplication is <code>Ã—</code>, instead of <code>*</code> as in most other languages.
More importantly, however: there is no precedence for mathematical operators!
BQN is evaluated (strictly) from right to left,
and most of the time this is also the direction you should read expressions in.</p>
<p>Assigning values to variables works with <em>define</em> (<code>â†</code>):</p>
<pre class="bqn"><code>    v â† 2Ã—4+6
20</code></pre>
<p>A block is something in between curly braces,
containing several assignments and expressions separated by line breaks, or, alternatively, the <code>â‹„</code> character.
Further, a block starts its own <a href="https://mlochbaum.github.io/BQN/doc/namespace.html">namespace</a>;
nothing all that surprising coming from almost any other language.</p>
<pre class="bqn"><code>    v â† 2Ã—4+6
20
    {vâ†0 â‹„ v}
0
    v
20</code></pre>
<p>I will talk a little bit more about namespaces later,
but letâ€™s not get too hung up on that right now.
Instead, letâ€™s talk about functions.
A user-defined function is something in curly braces that mentions the special names <code>ğ•¨</code> and <code>ğ•©</code>,
standing in for the left and right argument to it.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>
Functions are always infix, and can only be called with either one or two arguments.
In the former case, the function takes its argument on the right and <code>ğ•¨</code> will be given a special value:
<em>nothing</em> (<a href="https://mlochbaum.github.io/BQN/doc/expression.html#nothing"><code>Â·</code></a>)!.</p>
<pre class="bqn"><code>    1 {ğ•¨+ğ•©} 2
3
    1 {ğ•¨-ğ•©} 2
Â¯1
    2 {ğ•¨â‹†ğ•©} 8  # Careful: exponentiation!
256
    {âˆšğ•©} 9     # Could also just write âˆš9
3</code></pre>
<p>I should note that the <code>â‹†</code> above is the Unicode code point <code>0x22C6</code> (STAR OPERATOR),
and not just a normal asterisk.</p>
<p>Because Greek is much cooler than Latin,
BQN calls functions taking one argument <em>monadic</em>,<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>
and ones taking two arguments <em>dyadic</em>.
When in doubt, just substitute â€œunaryâ€ and â€œbinaryâ€ in your head.
One thing that might seem very confusing at the start is that
many functions are actually overloaded depending on whether they are called monadically or dyadically<!--
-->â€”often with seemingly unrelated (or only barely so) functions!</p>
<pre class="bqn"><code>    # Dyadic Ã—; N.b. we use the upper minus Â¯ here because Â¯2 is its own
    # number literal. We could also use the function -, but then (because
    # remember everything is evaluated right to left) we would have to
    # use parentheses: (-2)Ã—4. Otherwise, the expression would be parsed
    # as -(2Ã—4).
    Â¯2Ã—4
Â¯8
    Ã—Â¯2 # Monadic Ã— is the signum function!
Â¯1
    Ã—2
1
    Ã—0
0</code></pre>
<p>The signum function hints at a fundamental design decision that basically all array languages share:
instead of a name,
all builtin functions are given a unique symbol.
However, the documentation of each of them does mention a pronounceable name as well,
so that itâ€™s easier to talk to other people about a given piece of code.</p>
<pre class="bqn"><code>    â†•9                 # Monadic â†•: Range. Gives you the integer range [0, ğ•©-1].
âŸ¨ 0 1 2 3 4 5 6 7 8 âŸ©
    7â†•(â†•9)             # Dyadic â†•: Windows. Create all windows of size ğ•¨ in ğ•©.
                       # N.b: the parentheses are not technically needed.
â”Œâ”€
â•µ 0 1 2 3 4 5 6
  1 2 3 4 5 6 7
  2 3 4 5 6 7 8
                â”˜</code></pre>
<p>In particular, the above examples showcase how BQN displays <em>vectors</em> (or <em>lists</em>) and <em>arrays</em>.
Definitionally, vectors are â€œrank 1 arraysâ€â€”we will talk about what exactly this means when we talk about major cells.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>
We can define our own arrays in a few different ways,
the two most important ones being</p>
<pre class="bqn"><code>    âŸ¨1,2,3,4âŸ© # Using list notation
âŸ¨ 1 2 3 4 âŸ©
    1â€¿2â€¿3â€¿4   # Using strand notation
âŸ¨ 1 2 3 4 âŸ©</code></pre>
<p>Hereâ€™s another example of monadic and dyadic uses of functions:</p>
<pre class="bqn"><code>    râ†â†•9
âŸ¨ 0 1 2 3 4 5 6 7 8 âŸ©
    âŒ½r                 # Monadic âŒ½: Reverse.
âŸ¨ 8 7 6 5 4 3 2 1 0 âŸ©
    3âŒ½r                # Dyadic âŒ½: Rotate. Rotates ğ•© by ğ•¨ places to the
                       # left (to the right if ğ•¨ is negative).
âŸ¨ 3 4 5 6 7 8 0 1 2 âŸ©</code></pre>
<p>This takes some time getting used to.
However, after a while you really start to think that
<a href="https://dl.acm.org/doi/pdf/10.1145/1283920.1283935">notation as a tool for thought</a>
has a point.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>
I believe BQNâ€™s creator once called the syntax â€œscribbles on a whiteboardâ€, and honestly thatâ€™s my feeling about it too<!--
-->â€”with the slight addendum that blackboards are obviously vastly superior to whiteboards.</p>
<p>One more piece of syntax that we have to discuss before diving into day 1: modifiers.
These are <em>things</em> that take either one or two functions, and spit out a new, modified, one.
I would imagine that this comes from the APL tradition and is actually not strictly needed,
given that BQN supports <a href="https://mlochbaum.github.io/BQN/doc/functional.html">higher order functions</a>.
However, since these things have their own precedence and binding rules, the separate concept may nonetheless be useful.</p>
<p>We can write our own modifiers by using <code>ğ”½</code> and <code>ğ”¾</code> inside of a block,
but for most of this article we will only use the builtin ones.
Monadic modifiers take their function argument <em>to the left</em>,
and are not called monadic any longer,
but 1-modifiers.
Likewise, modifiers taking two functions are called 2-modifiers.</p>
<pre class="bqn"><code>    1 - 3  # Normal subtraction
Â¯2

    1 -Ëœ 3 # Ëœ is the *flip* or *swap* 1-modifier:
           # it takes a dyadic function and returns
           # one with its arguments flipped.
2
    3 - 1
2

    -Ëœ 3  # If a flipped function is called with
          # only one argument, it gets duplicated.
0
    3 - 3
0

    {ğ•©+1}âˆ˜{ğ•©-3} 4 # âˆ˜ is the function composition 2-modifier called *atop*.
                  # Called monatically, ğ”½âˆ˜ğ”¾ ğ•© is just ğ”½ğ”¾ğ•©
2
    1 {ğ•©+1}âˆ˜{ğ•©-ğ•¨} 4 # Called dyadically, ğ•¨ ğ”½âˆ˜ğ”¾ ğ•© transforms to ğ”½(ğ•¨ğ”¾ğ•©)
4
    1 +âŸœ1âˆ˜- 4     # âŸœ is *after*: ğ”½âŸœğ”¾ ğ•© evaluates to ğ•©ğ”½(ğ”¾ğ•©).
                  # If a constant or variable is given as ğ”½ or ğ”¾,
                  # it is promoted to its constant function.
                  # The whole expression associates as 1 (+âŸœ1)âˆ˜- 4,
                  # and so evaluates to (+âŸœ1) (1-4) = (1-4)+1.
Â¯2</code></pre>
<p>Besides this being quite a lot to take in,
you might have already noticed something strange in the last example:
how come <code>+âŸœ1âˆ˜-</code> is parsed like <code>(+âŸœ1)âˆ˜-</code> when I previously said everything is evaluated right to left?
While there are no precedence rules among functions or among modifiers,
the latter does <a href="https://mlochbaum.github.io/BQN/doc/syntax.html#precedence">bind tighter</a> than the former.
Additionally, modifiers associate left to right, instead of right to left:
given functions <code>F</code>, <code>G</code>, and <code>H</code>, then <code>Fâˆ˜Gâˆ˜H</code> is parsed as <code>(Fâˆ˜G)âˆ˜H</code> instead of <code>Fâˆ˜(Gâˆ˜H)</code>.
As you can imagine, getting used to reading BQN expressions takes quite some time.
It gets better, though, I promise.</p>
<p>Something to ease the pain:
there is a purely syntactic way to decide whether a given symbol is a (builtin) function, 1-, or 2-modifier!<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
Thankfully, someone thought about this, and there is a consistent morphology to the chosen symbols:</p>
<ul>
<li>1-modifiers are always superscripts;</li>
<li>2-modifiers always contain an <em>unbroken</em> circle; and</li>
<li>everything else is a function.</li>
</ul>
<p>For example, <code>Ã— + - â‹† âŒ½ â‰ âŠ” â‰¢</code> are functions (remember the unbroken part),
<code>Ë˜ Â¨ â¼ Â´</code> are 1-modifiers,
and <code>âˆ˜ âŸ âš‡ â—¶ âŒ¾</code> are 2-modifiers.
Quite neat, I think.</p>
<p>This should be plenty to get a feeling for the language.
Anything more will be introduced as needed.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<h2 id="days-15">Days 1â€“5</h2>
<h3 id="day-1"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day01.bqn">Day 1</a></h3>
<p>Letâ€™s get into the swing of things!
Day 1 starts with us getting sucked into Santaâ€™s computer,
where we have to solve a captcha, proving weâ€™re not human.</p>
<p>For part one,
we are given a (circular) list of numbers,
and are asked to identify repeating digits, starting from the beginning
(i.e., all digits that match the next element).
For example, in <code>311223</code> this would be <code>1</code>, <code>2</code>, and <code>3</code> (in that order).
Our input is a long string of digits
that we first have to convert to a long string of numbers:</p>
<pre class="bqn"><code>inp â† '0'-Ëœ âŠ‘ â€¢FLines&quot;../inputs/day01.txt&quot;</code></pre>
<p>Reading the input line-by-line and converting it to a vector works via the builtin <code>â€¢FLines</code> function.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>
The only other function we havenâ€™t see so far is
<em>first</em> <a href="https://mlochbaum.github.io/BQN/doc/pick.html"><code>âŠ‘</code></a>,
which gives us the first element in the listâ€”our input is on a single long line.
Much more interesting is the <code>'0'-Ëœ</code> part,
which immediately gives me a chance to talk about characterâ€“number conversions in BQN.</p>
<details>
<summary>
Affine characters in BQN
</summary>
<p>The <a href="https://mlochbaum.github.io/BQN/tutorial/expression.html#character-arithmetic">documentation</a>
says that characters reside in an affine space,<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
which is a good guide on what kinds of operations we have access to:</p>
<ol type="1">
<li><p><code>(+) : Num  â†’ Char â†’ Char</code>, adding a number to a character gives a character:</p>
<pre class="bqn"><code>    97+@   # @ is the literal &quot;null&quot; character;
           # i.e., '\0' in most other languages.
'a'</code></pre></li>
<li><p><code>(-) : Char â†’ Num  â†’ Char</code>, subtracting a number from a character gives a character:</p>
<pre class="bqn"><code>    'a'-32
'A'</code></pre></li>
<li><p><code>(-) : Char â†’ Char â†’ Num</code>, subtracting two characters gives a number:</p>
<pre class="bqn"><code>    'a'-@
97
    '0'-@
48
    'a'-'0'
49</code></pre></li>
</ol>
<p>Since the numbers from 0 to 9 are ordered sequentially in UTF-8,
this in particular gives a neat way to transform a vector of characters<!--
-->â€”also known as a stringâ€”<!--
-->into a vector of digits:
simply subtract <code>'0'</code> from them!</p>
<pre class="bqn"><code>    '9'-'0'
9
    &quot;1939102&quot;-'0'
âŸ¨ 1 9 3 9 1 0 2 âŸ©</code></pre>
The last example shows another important feature of pretty much all array oriented languages:
<a href="https://mlochbaum.github.io/BQN/doc/arithmetic.html#pervasion">scalar pervasion</a>.
Simply put, arithmetic functions like <code>-</code> know how to â€œpenetrateâ€ arrays,
in that they apply to each element individually, instead of to the whole thing as one.
In this case, the scalar <code>'0'</code> is â€œduplicatedâ€ and supplied to all elements of the string <code>"1939102"</code>.
</details>
<p>After the input is parsed, the solution is not so complicated:<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<pre class="bqn"><code>+Â´ inp/Ëœ inp= Â¯1âŒ½inp</code></pre>
<p>We <em>rotate</em> (<a href="https://mlochbaum.github.io/BQN/doc/reverse.html#rotate"><code>âŒ½</code></a>)
the whole list by 1 to the right,
and then compare it with its original (<code>inp= -1âŒ½inp</code>).
This creates a <em>Boolean mask</em>: a list with the same length as <code>inp</code>, only consisting of zeros and ones.
We can use this to pick the elements of the list corresponding to 1 with
<em>replicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/replicate.html#replicate"><code>/</code></a>).</p>
<pre class="bqn"><code>    # &quot;Only give me the elements of ğ•©
    # that correspond to 1's in ğ•¨&quot;.
    âŸ¨1,1,0,1,1,0âŸ© / â†•6
âŸ¨ 0 1 3 4 âŸ©</code></pre>
<p>All thatâ€™s left is to sum up the numbers by using
+-<em>fold</em> (<a href="https://mlochbaum.github.io/BQN/doc/fold.html#fold"><code>`</code></a>),
which is just a right fold over the list.
A few more notes:</p>
<ol type="1">
<li><p>Boolean masks are an important concept to internalise,
and will often be used to filter results, or serve as control flow<!--
-->â€”BQN does not have a builtin if-then-else expression!</p></li>
<li><p><em>Swap</em> (<a href="https://mlochbaum.github.io/BQN/doc/swap.html"><code>Ëœ</code></a>),
as seen in the <a href="#a-crash-course-on-syntax">crash course on syntax</a> makes an appearance again.
Recall that this 1-modifier simply takes a function, and returns a function with its arguments flipped,
so <code>X fËœ Y</code> is the same as <code>Y f X</code>.
When given only one argument, <em>swap</em> becomes <em>self</em> and duplicates its argument: <code>fËœ Y</code> is <code>Y f Y</code>.
The modifier mostly exists to allow the reading order to flow more naturally from right to left.
Without it, we would have to write the above expression as <code>+Â´(inp=-1âŒ½inp)/inp</code>.<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p></li>
</ol>
<hr />
<p>Part two is basically the same,
only a number doesnâ€™t consider its first successor,
but the one thatâ€™s exactly halfway around the list.
Adjusting for this just means that we have to adjust how much we shift before comparing:</p>
<pre class="bqn"><code>+Â´ inp/Ëœ inp= (Â¯2Ã·Ëœâ‰ inp)âŒ½inp</code></pre>
<p>Even in this simple example,
one can already see what goes into writing code in this language:
aim for branchless, array-based, solutions rather than iterating through elements.
However, if you ever miss <code>if-then-else</code> or <code>while</code> constructs,
<a href="https://mlochbaum.github.io/BQN/doc/control.html">you can make your own</a>.</p>
<h3 id="day-2"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day02.bqn">Day 2</a></h3>
<p>Today we have to help some programs repair a corrupted spreadsheet.
Our puzzle input is a table of numbers, like so:</p>
<pre><code>5 9 2 8
9 4 7 3
3 8 6 5</code></pre>
<p>For part one we have to calculate the smallest and largest values of all rows in the table.
This is easy enough once we have the data in a usable format;
however, getting to that format is actually the much more interesting part of the day.
For one, we have to learn how to split strings!
For these kinds of partitioning tasks, BQN sports the very general
<em>group</em> (<a href="https://mlochbaum.github.io/BQN/doc/group.html"><code>âŠ”</code></a>)
function.
Briefly, <code>XâŠ”Y</code> groups <code>Y</code> according to the indices supplied by <code>X</code>,
while omitting elements that are associated to <code>Â¯1</code>.
For example, in</p>
<pre class="bqn"><code>    1â€¿0â€¿Â¯1â€¿1 âŠ” &quot;abcd&quot;
âŸ¨ &quot;b&quot; &quot;ad&quot; âŸ©</code></pre>
<p>both <code>a</code> and <code>d</code> are associated to the same index, <code>1</code>, so they are grouped together;
<code>b</code> is alone (and in front of <code>a</code> and <code>d</code> because it is associated to index <code>0</code>);
and <code>c</code> is omitted.
The strategy is, then, to somehow associate <code>Â¯1</code> to the separator in the input, and have all digits of a number be associated to the same index.
If you want you can black box that such a <code>Split</code> function exists;
if not, feel free to peruse the insert below.</p>
<details>
<summary>
The long and painful walkthrough
</summary>
<p>We start by checking which elements of the given string match the separator,
and call it <code>ws</code>.
I will use a string with a space separator for illustrative purposes, but the function itself is really quite general.</p>
<pre class="bqn"><code>    ' ' { wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ 0 0 1 0 0 0 1 0 0 0 0 0 1 0 âŸ©</code></pre>
<p>Now, a
+-<em>scan</em> (<a href="https://mlochbaum.github.io/BQN/doc/scan.html"><code>`</code></a>)
yields a running sum, indicating when we encounter a separator.</p>
<pre class="bqn"><code>    ' ' { +`wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ 1 1 2 2 2 2 3 3 3 3 3 3 4 4 âŸ©</code></pre>
<p>This looks a bit weird, but the <code>wsâ†ğ•¨=ğ•©</code> is an inline assignmentâ€”we do the comparison <code>ğ•¨=ğ•©</code>, call the result <code>ws</code>, and then scan over it.
In this way, we can refer to <code>ws</code> again at a later point.
Itâ€™s not the best style to write code this way, but here it kind of fits.
If we just <em>group</em>ed the string now, we
would get the separators â€œattachedâ€ to the word that follows them:</p>
<pre class="bqn"><code>    ' ' { ğ•©âŠ”Ëœ+`wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ &quot;13&quot; &quot; 259&quot; &quot; 39999&quot; &quot; 4&quot; âŸ©</code></pre>
<p>One thing we can do,
since <code>ws</code> gives us the positions of the separators,
is to
<em>negate</em> (<a href="https://mlochbaum.github.io/BQN/doc/logic.html"><code>Â¬</code></a>)
the entire vector and multiply it with what we already have.
This would turn all separators into zeros in the output:</p>
<pre class="bqn"><code>    ' ' { (Â¬ws)Ã—+`wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ 0 0 0 1 1 1 0 2 2 2 2 2 0 3 âŸ©</code></pre>
<p>Now we canâ€™t differentiate between the separators and our first word!
However, there is an easy fix for this;
we just take the original <code>ws</code>, whichâ€”rememberâ€”contains the positions of the separators,
and subtract it from the result that we have:</p>
<pre class="bqn"><code>    ' ' { ws-Ëœ(Â¬ws)Ã—+`wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ 0 0 Â¯1 1 1 1 Â¯1 2 2 2 2 2 Â¯1 3 âŸ©</code></pre>
<p>And thatâ€™s it!</p>
<pre class="bqn"><code>    ' ' { ğ•©âŠ”Ëœws-Ëœ(Â¬ws)Ã—+`wsâ†ğ•¨=ğ•© } &quot;13 259 39999 4&quot;
âŸ¨ &quot;13&quot; &quot;259&quot; &quot;39999&quot; &quot;4&quot; âŸ©</code></pre>
<p>If you wanted to make it unreadable (see the bit on trains below), you could also write it as</p>
<pre class="bqn"><code>    ' ' ((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢) &quot;13 259 39999 4&quot;
âŸ¨ &quot;13&quot; &quot;259&quot; &quot;39999&quot; &quot;4&quot; âŸ©</code></pre>
We can bind that to a function <code>Split</code> and be on our way!<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>
</details>
<p>The input separates each number by a tab,
so we just need <code>'\t' Split input</code>, right?</p>
<p>Wrong!</p>
<p>BQNâ€™s characters and strings are almost completely void of any kind of escaping mechanism.
That is to say, besides for double quotes, which are inserted by duplicating them,
every character entered into a string it interpreted verbatim.
Indeed, <code>'\t'</code> is not even a valid character,
as it actually comprises two characters: <code>'\'</code> and <code>'t'</code>!
To write a tab we either need to actually insert a tab character,<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>
or make use of the â€œaffineâ€ part of affine characters:</p>
<pre class="bqn"><code>    '	'
'	'
    @+9
'	'</code></pre>
<p>Because both <code>Split</code> and <code>tabâ†@+9</code> will be needed quite a few times this year,
letâ€™s put it into a small utility file.
We can use BQNâ€™s system function <code>â€¢Import</code> to import a namespace<!--
-->â€”which I donâ€™t want to get into right now, but it works as one would expectâ€”<!--
-->from somewhere.
Parsing the input and solving part one is straightforward:</p>
<pre class="bqn"><code>âŸ¨Split, tabâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
inp â† &gt;(â€¢ParseFloatÂ¨ tabâŠ¸Split)Â¨ â€¢FLines &quot;../inputs/day02.txt&quot;

+Â´ (âŒˆÂ´-âŒŠÂ´)Ë˜ inp</code></pre>
<p>â€¦except that this solution uses two new concepts that we havenâ€™t seen before:
multidimensional arrays, and tacit programming!</p>
<details>
<summary>
Arrays
</summary>
<p>The fateful day has come that we need to talk about arrays in this array language.
I will probably not do this topic justice here, so <a href="https://mlochbaum.github.io/BQN/doc/array.html">have a link</a> to the BQN array docs.
For now, letâ€™s look at an array as a blob with the following properties:</p>
<ul>
<li><p>It has a <em>rank</em>, which is its number of axes.
Pictorially, it is the number of dimensions one can walk in.
The <em>leading axis</em> is the first one.</p></li>
<li><p>It has a <em>shape</em>, which is the number of positions that it has along each of its axes.</p></li>
<li><p>It has <em>elements</em>, which are the values at every position.</p></li>
</ul>
<p>One can query the <em>rank</em> of an array with monadic
<a href="https://mlochbaum.github.io/BQN/doc/shape.html"><code>=</code></a>
and the <em>shape</em> with monadic
<a href="https://mlochbaum.github.io/BQN/doc/shape.html"><code>â‰¢</code></a>.</p>
<p>For example,</p>
<pre class="bqn"><code>    10+â†•9
âŸ¨ 10 11 12 13 14 15 16 17 18 âŸ©</code></pre>
<p>is an array of <em>rank</em> <code>1</code> with <em>shape</em> <code>âŸ¨9âŸ©</code>.
At every possible position (0â€“9), we find a corresponding element: <code>10</code> for 0, <code>11</code> for 1, etc.</p>
<p>We can use <em>reshape</em> to create a higher-dimensional array from a flat vector:</p>
<pre class="bqn"><code>    3â€¿3â¥Šâ†•9
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
        â”˜</code></pre>
<p>This is an array of <em>rank</em> <code>2</code> with <em>shape</em> <code>âŸ¨3 3âŸ©</code>.
The element at position <code>1â€¿1</code> (notice how we have two indices to specify) is <code>4</code>.</p>
<p>Why am I blabbering on about this when everyone intuitively knows what an array is?
Because this is <em>really</em> important:
arrays are an intrinsic concept.
Many things that seem intuitive at first,
coming from another language, are just not true in BQN.</p>
<ul>
<li><p>Lists of lists are not equivalent to higher-dimensional arrays:</p>
<pre class="bqn"><code>    a â† âŸ¨âŸ¨1,2âŸ©,âŸ¨3,4âŸ©âŸ©
âŸ¨ âŸ¨ 1 2 âŸ© âŸ¨ 3 4 âŸ© âŸ©
    b â† &gt;a              # monadic &gt; is called *merge*
                        # and creates an array from a list
â”Œâ”€
â•µ 1 2
  3 4
      â”˜
   bâ‰¡a
0</code></pre></li>
<li><p>Piggybacking off of that: â€œdepth is not rankâ€.
The type of the elements is not at all important in determining the arrays rank.</p>
<pre class="bqn"><code>   =1â€¿2â€¿3â€¿4â€¿5 # vector
1
   =3â€¿3â¥Šâ†•9    # matrix
2
   mâ†1â€¿(3â€¿4)â€¿(2â€¿2â¥Šâ†•4) # Nested array
â”Œâ”€
Â· 1 âŸ¨ 3 4 âŸ© â”Œâ”€
            â•µ 0 1
              2 3
                  â”˜
                    â”˜
   =m # The rank of the elements does
      # *not* affect the rank of the array.
1</code></pre></li>
</ul>
<p>A <em>cell</em> of an array is just a subarray of any size.
Now, a <em>major cell</em> of an array of rank <code>n</code> is a cell of rank <code>n-1</code> that leaves out the leading axis.
For example, <code>3â€¿3â¥Šâ†•9</code> has three major cells, <code>âŸ¨0 1 2âŸ©</code>, <code>âŸ¨3 4 5âŸ©</code>, and <code>âŸ¨6 7 8âŸ©</code>.</p>
<p>This concept is quite central to the way a lot of array primitives work,
in that they often only apply to the first axis of the argument.
The 1-modifier
<em>cells</em> (<a href="https://mlochbaum.github.io/BQN/doc/rank.html"><code>Ë˜</code></a>)
changes a function to instead operate on the major cells of its argument.
For example, we already saw that <em>reverse</em> reverses lists.
If we have more dimensions, we instead reverse along the leading axis:</p>
<pre class="bqn"><code>    mâ†3â€¿3â¥Šâ†•9
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
        â”˜
    âŒ½m   # Reverse the first axis of m
â”Œâ”€
â•µ 6 7 8
  3 4 5
  0 1 2
        â”˜
    âŒ½Ë˜m  # Reverse each major cell separately
â”Œâ”€
â•µ 2 1 0
  5 4 3
  8 7 6
        â”˜</code></pre>
</details>
<details>
<summary>
Tacit programming
</summary>
<p>If you, after reading this far,
thought that BQN was really a little too verbose for you,
<a href="https://mlochbaum.github.io/BQN/doc/tacit.html">youâ€™re in luck</a>!</p>
<p>The basic idea of trains is deceptively simple.
Pick your favourite algebraic structure with a binary operation, say an abelian monoid.
Given two morphisms <span class="math inline">f, g \colon M \to N</span> of such structures, we can define another map
<span class="math display">
  f \cdot g \colon M \to N, \qquad (f \cdot g)(x) \defeq f(x) \cdot_N g(x).
</span>
It is an easy exercise to prove that this is again a morphism of abelian monoids.<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<p>What BQN now does is twofold:
first, it takes the expression <span class="math inline">f \cdot g</span>, and allows it to be called both monadically and dyadically.
Second, it allows one to replace the operation in the middle with any dyadic function whatsoever.</p>
<p>Train syntax is essentially just â€œwriting functions after each otherâ€.<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>
This in particular does not use any blocks, so you canâ€™t refer to named arguments at all.
More explicitly, we have the following two relationships:</p>
<pre><code>(FGH)y  â‰¡  (Fy)G(Hy)   and   x(FGH)y  â‰¡  (xFy)G(xHy)</code></pre>
<p>Replace <code>G</code> with <span class="math inline">\cdot</span> in the first of these and you essentially have the above mathematical notation.</p>
<p>Since this train is composed of three functions, it is called a <em>3-train</em>.
Naturally, <em>2-trains</em> also exist; these are just 3-trains in which the function <code>F</code> is <em>nothing</em>
(<a href="https://mlochbaum.github.io/BQN/doc/expression.html#nothing"><code>Â·</code></a>):</p>
<pre><code>(GH)y  â‰¡  GHy   and   x(GH)y  â‰¡  G(xHy)</code></pre>
<p>For example, suppose we wanted to write a function that takes two arrays <code>X</code> and <code>Y</code> and gives us back only those major cells of <code>X</code> that do not exist in <code>Y</code>.<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>
Sort of like a set difference for arrays.
We just need a few functions for this purpose:
<em>negate</em> (<a href="https://mlochbaum.github.io/BQN/doc/logic.html"><code>Â¬</code></a>) and
<em>member of</em> (<a href="https://mlochbaum.github.io/BQN/doc/search.html#member-of"><code>âˆŠ</code></a>),
which do what you would expect them to.</p>
<p>Additionally, we will make use of the scalar pervasion of <em>member of</em>,
where for every element in <code>ğ•¨</code>, we test whether it is in <code>ğ•©</code>.</p>
<pre class="bqn"><code>    &quot;.b#d.#zz#&quot; âˆŠ &quot;.#&quot;
âŸ¨ 1 0 1 0 1 1 0 0 1 âŸ©</code></pre>
<p>Letâ€™s now write the function with and without trains:</p>
<pre class="bqn"><code>    W1 â† {(Â¬ğ•¨âˆŠğ•©)/ğ•¨}   # no trains at all
    W2 â† (Â¬âˆŠ)/âŠ£       # A 3-train whose left argument is a 2-train
    W3 â† Â¬âˆ˜âˆŠ/âŠ£        # A single 3-train because of precedence

    3â€¿1â¥ŠâŸ¨(â†•9)W1âŸ¨2,5,1âŸ©, (â†•9)W2âŸ¨2,5,1âŸ©, (â†•9)W3âŸ¨2,5,1âŸ©âŸ©
â”Œâ”€
â•µ âŸ¨ 0 3 4 6 7 8 âŸ©
  âŸ¨ 0 3 4 6 7 8 âŸ©
  âŸ¨ 0 3 4 6 7 8 âŸ©
                  â”˜</code></pre>
<p>That last example used the
<em>atop</em> (<a href="https://mlochbaum.github.io/BQN/doc/compose.html#atop"><code>âˆ˜</code></a>)
2-modifier; one of several
<a href="https://mlochbaum.github.io/BQN/doc/tacit.html#combinators">combinators</a>
that BQN sports to complement this syntax.
I will generally introduce them on a call by need basis;
<em>atop</em> is basically a 2-train as a modifier:</p>
<pre><code>Fâˆ˜Gğ•©  â‰¡  FGğ•©   and   ğ•¨Fâˆ˜Gğ•©  â‰¡  F(ğ•¨Gğ•©)</code></pre>
<p>The <code>(Â¬âˆŠ)/âŠ£</code> example above shows that trains can â€œstackâ€.
Parentheses are really important here, by the way, since
depending on whether the overall length of an expression is even or odd
things may get parsed as a 2- or 3- train!
This is horribly confusing at first, but thankfully BQN has an <code>)explain</code> system function that prints the parse tree of an expression:</p>
<pre><code>    )explain (Â¬âˆŠ)/âŠ£
 (Â¬âˆŠ)/âŠ£
   â”‚  â”‚
  Â¬âˆŠ  â”‚
  â””â”€â”€/âŠ£
â•¶â”€â”€â”€â”€â”˜

    )explain Â¬âˆ˜âˆŠ/âŠ£
 Â¬âˆ˜âˆŠ/âŠ£
 â”‚ â”‚ â”‚
 Â¬âˆ˜âˆŠ â”‚
  â””â”€/âŠ£
â•¶â”€â”€â”€â”˜</code></pre>
Playing around with this was immensely helpful for me in the beginning.
</details>
<p>The 1-modifier
<em>each</em> (<a href="https://mlochbaum.github.io/BQN/doc/map.html"><code>Â¨</code></a>)
does what it says on the tinâ€”itâ€™s comparable to <code>map</code> in many other languages.
Parsing the input works as expected,
in that we split each line on the tab character,
and parse all the resulting sequences of digits as numbers.
All thatâ€™s left to do is to assembly the table in to a rank two array.
By means of <em>cells</em> we get the maximum and minimum for every row<!--
-->â€”using the <code>âŒˆÂ´-âŒŠÂ´</code> train, which is a great one to reason throughâ€”<!--
-->and sum up the resulting vector to get our answer.</p>
<hr />
<p>Part two asks a bit of a different question:
instead of the smallest and largest number in each row,
we instead need to find the two (unique) numbers such that one evenly divides the other,
and take the result of that division.</p>
<p>I didnâ€™t think too hard about this and just decided to brute-force a solution.
The idea is to proceed row-wise and first create a division table for each row with <code>Ã·âŒœËœ</code>.
This uses the 1-modifier
<em>table</em> (<a href="https://mlochbaum.github.io/BQN/doc/map.html#table"><code>âŒœ</code></a>),
which is essentially a generalised outer product in the sense of linear algebra.
Written out explicitly, this definition is equivalent to <code>{ ğ•©Ã·âŒœğ•© }</code>:
it applies the given function to every element of <code>ğ•©</code> on the left and all of <code>ğ•©</code> on the right
and makes that one row in a new matrix (or, table, hence the name).
Since arithmetic functions support scalar pervasion,
this ends up giving us the division table we want:</p>
<pre><code>    (Ã·âŒœËœ) âŸ¨2, 4, 8, 16âŸ©
â”Œâ”€
â•µ 1 0.5 0.25 0.125    # 2Ã·2  2Ã·4  2Ã·8  2Ã·16
  2   1  0.5  0.25    # 4Ã·2  â€¦
  4   2    1   0.5    # 8Ã·2  â€¦
  8   4    2     1    # 16Ã·2 â€¦
                   â”˜</code></pre>
<p>As the problem explicitly says,
there will be exactly one pair of <em>different</em> numbers where one evenly divides the other.
As such, we just need to select an integer<!--
-->â€”e.g., some number thatâ€™s equal to its floorâ€”<!--
-->that is not one:</p>
<pre class="bqn"><code>Two â† {
  t â† Ã·âŒœËœğ•©            # Division table
  âŠ‘((1â‰ t)âˆ§t=âŒŠt)(/â—‹â¥Š)t # Select integer that is not 1
}
+Â´ TwoË˜ inp</code></pre>
<p>As before, selection is done with <code>/</code> (<em>replicate</em>).
We use <em>over</em>, <code>â—‹</code>, which is one of the combinators mentioned earlier, to
<em>deshape</em> (<a href="https://mlochbaum.github.io/BQN/doc/reshape.html#deshape"><code>â¥Š</code></a>)
the array beforehand,
as <em>replicate</em> only operates on vectors and not arrays.<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>
Briefly, one has that <code>ğ•¨(ğ”½â—‹ğ”¾)ğ•©</code> is <code>(ğ”¾ğ•¨)ğ”½(ğ”¾ğ•©)</code>.
We then just have to pick the first element of the array,
which we know will have exactly one match.
All thatâ€™s left to do is to apply the function <code>Two</code> to all rows of <code>inp</code>,
which is but a <em>cells</em> away, and sum up the result.</p>
<h3 id="day-3"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day03.bqn">Day 3</a></h3>
<p>Day 3 asks us to implement an experimental memory layout: an infinite spiral grid.</p>
<pre><code>17  16  15  14  13
18   5   4   3  12
19   6   1   2  11
20   7   8   9  10
21  22  23---&gt; ...</code></pre>
<p>Part one is all about calculating the
<a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>
between the start point <code>1</code> in the middle of the grid, and wherever we end up with after taking
as many steps as our puzzle input demands.
As such, parsing is straightforward.</p>
<pre class="bqn"><code>inp â† â€¢ParseFloatâŠ‘â€¢FLines&quot;../inputs/day03.txt&quot;</code></pre>
<p>I found no good array solution for this,
so I just stared hard at the spiral until noticing the general pattern in which we are moving:
<code>R U 2L 2D 3R 3U 4L 4D 5R 5Uâ€¦</code>.
The function that outputs all of the coordinates weâ€™ve been to looks like this:</p>
<pre class="bqn"><code>Coords â† { # 2Ã—ğ•©: Number of steps to go.
  dirs â† (2Ã—ğ•©)â¥ŠâŸ¨0â€¿1, 1â€¿0, 0â€¿Â¯1, Â¯1â€¿0âŸ© # r u l d
  natnat â† âˆ¾(â†•â‹ˆÂ¨â†•)ğ•©                   # 0 0 1 1 2 2 3 3 â€¦
  +`âˆ¾natnat{&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨dirs             # expand
}</code></pre>
<p>We create the <code>R U 2L 2Dâ€¦</code> pattern in two steps,
first assembling the directions and then the associated numbers.
Notice that if <code>ğ•¨</code> is larger than the length of <code>ğ•©</code>, <em>reshape</em> duplicates <code>ğ•©</code> until it fits:</p>
<pre class="bqn"><code>    5â¥ŠâŸ¨1,2,3âŸ©
âŸ¨ 1 2 3 1 2 âŸ©
    {(2Ã—â‰ ğ•©)â¥Šğ•©} â†•5       # Monadic â‰  is *length*
âŸ¨ 0 1 2 3 4 0 1 2 3 4 âŸ©
    (2Ã—â‰ )âŠ¸â¥Š â†•5          # Bonus: the same thing tacitly
âŸ¨ 0 1 2 3 4 0 1 2 3 4 âŸ©</code></pre>
<p>The train <code>â†•â‹ˆÂ¨â†•</code> is interesting because of the middle component, <code>â‹ˆÂ¨</code>.
Itâ€™s what one might call <code>zip</code> in other languages.<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>
In the last line, we first use <em>reshape</em> to replicate the vector <code>ğ•©</code> exactly <code>ğ•¨</code> times:</p>
<pre class="bqn"><code>    3 {ğ•¨â€¿2â¥Šğ•©} 0â€¿1
â”Œâ”€
â•µ 0 1
  0 1
  0 1
      â”˜</code></pre>
<p>Then, since we actually want a nested vector instead of a rank two array,
<em>enclosing</em> (<a href="https://mlochbaum.github.io/BQN/doc/enclose.html"><code>&lt;</code></a>)
every major cell creates
<a href="https://mlochbaum.github.io/BQN/doc/enclose.html">unit arrays</a>
out of the individual cells.
Each of these is an array of shape <code>âŸ¨âŸ©</code> containing the thing we enclosed as its only element.
This reduces the rank of the outer array by one, yielding the desired flat structure.</p>
<pre class="bqn"><code>    3 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©} 0â€¿1
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 1 âŸ© âŸ©
    = 3 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©} 0â€¿1         # rank
1
    â‰¢ 3 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©} 0â€¿1         # shape
âŸ¨ 3 âŸ©
    â‰¡ 3 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©} 0â€¿1         # depth
2</code></pre>
<p>Walking around the grid can now be simulated by summing up every individual move.
Scanning over the array keeps all intermediate steps,
which is useful since we are looking for a specific index:</p>
<pre class="bqn"><code>    steps â† âˆ¾ 3â€¿2 {&lt;Ë˜ğ•¨â€¿2â¥Šğ•©}Â¨ âŸ¨0â€¿1, Â¯1â€¿0âŸ©
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ¨ Â¯1 0 âŸ© âŸ©
   +`steps
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ Â¯1 3 âŸ© âŸ¨ Â¯2 3 âŸ© âŸ©</code></pre>
<p>All thatâ€™s left is to <em>pick</em> the right coordinate
(keeping in mind we skip the starting position),
and calculate the Manhattan distance.</p>
<pre class="bqn"><code>+Â´| (inp-2) âŠ‘ Coords 1000 # â‡’ 552</code></pre>
<p>The <code>1000</code> above is a magic number,
because the whole thing is really naturally a lazy infinite stream,<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>
but thatâ€™s not how BQN works.</p>
<hr />
<p>Part two modifies how the spiral is constructed.
Instead of just being the ascending natural numbers,
a more elaborate iterative process is given:
for every number,
sum up the values of all the neighbours of a cell at the time of its creation.
With an initial seed of <code>1</code>, this would look like</p>
<pre><code>    147  142  133  122   59
    304    5    4    2   57
    330   10    1    1   54
    351   11   23   25   26
    362  747  806---&gt;   ...</code></pre>
<p>Our task is to find the first number thatâ€™s bigger than our input.</p>
<p>Again, no array-oriented solution presented itself to me,
so I just did the obvious thing: for the point under consideration,
generate a list of all neighbours,
see whether they appear in the grid already,
sum the values of those that do,
and associate the point with that value in the grid.</p>
<p>In this case, â€œgridâ€ actually means hash mapâ€”yup, we have those.
BQN exposes a simple interface under the <code>â€¢HashMap</code> system value.
The function namesâ€”<code>Has</code>, <code>Get</code>, <code>Set</code>, and so onâ€”are relatively self-explanatory.</p>
<pre class="bqn"><code>N â† { xâ€¿y: â¥Š(x+âŸ¨Â¯1, 0, 1âŸ©)â‹ˆâŒœ(y+âŸ¨Â¯1, 0, 1âŸ©) }</code></pre>
<p>We first calculate all of the neighbours of a given point,
represented as a vector with two elements.
The <code>xâ€¿y:</code> part at the start of the function is a
<a href="https://mlochbaum.github.io/BQN/doc/block.html#block-headers">header</a>,
which I guess I should go into now.</p>
<details>
<summary>
Headers
</summary>
<p>At the most basic level,
headers can be used to name the arguments of, say, a function,
instead of using the special names <code>ğ•¨</code> and <code>ğ•©</code>:</p>
<pre class="bqn"><code>    17 {left_arg ğ•Š right_arg: left_arg} 42
17
    17 {left_arg ğ•Š right_arg: right_arg} 42
42</code></pre>
<p>The colon ends the header, and begins the body of the block.
The <code>ğ•Š</code> here is just a way to signal that the block is a function, instead of something else.
Recursion can then be done by calling <code>ğ•Š</code> with some arguments, the same as with â€œanonymousâ€ blocks.
We can also give the function a name:</p>
<pre class="bqn"><code>    { Fib n: n&lt;2? n;
      Fib n: (Fib n-1) + Fib n-2
    } 17
1597</code></pre>
<p>This example already highlights a few more featuresâ€”and shortcomingsâ€”of blocks.
First, a block can contain multiple bodies, separated by <code>;</code>, as well as multiple headers associated to them.
When such a block is called,
its headers are checked for compatibility with the arguments,
until something appropriate is found (otherwise you get an error).</p>
<p>Additionally, predicates in the form of <code>n&lt;2?</code> appear.
Basically, this only evaluates the rest of the body if the predicate is true; otherwise, it jumps to the next header.
Control flow!
This is at the same time syntactically nice (chaining is quite concise: <code>ğ•©&lt;2? 6=+Â´ğ•©? â€¦</code>),
but also forces us to repeat the header in the â€œelseâ€ branch,
as everything after <code>;</code> is in a new scope.
This is especially annoying with more elaborate headers,
but even here it feels unnecessarily verbose.</p>
<p>Headers can also do some light destructuring:</p>
<pre class="bqn"><code>    {xâ€¿y: x} âŸ¨1, 2âŸ©    # Ok, vector should have exactly two elements
1
    {xâ€¿y: x} âŸ¨1, 2, 3âŸ© # Too long
Error: No header matched argument
    {xâ€¿y: x} âŸ¨1âŸ©       # Too short
Error: No header matched argument</code></pre>
</details>
<p>The rest of <code>N</code> is straightforward.
Add all possible directions to every coordinate individually,
pair them up again in a table,
and flatten everything down to a vector with coordinate entries.</p>
<pre class="bqn"><code>    â¥Š(2+âŸ¨Â¯1, 0, 1âŸ©)â‹ˆâŒœ(3+âŸ¨Â¯1, 0, 1âŸ©)
âŸ¨ âŸ¨ 1 2 âŸ© âŸ¨ 1 3 âŸ© âŸ¨ 1 4 âŸ© âŸ¨ 2 2 âŸ© # Line break for clarity
  âŸ¨ 2 3 âŸ© âŸ¨ 2 4 âŸ© âŸ¨ 3 2 âŸ© âŸ¨ 3 3 âŸ© âŸ¨ 3 4 âŸ© âŸ©</code></pre>
<p>Letâ€™s get to simulating!</p>
<pre class="bqn"><code>Sim â† { # ğ•¨ = grid = (xâ€¿y)â†’n, â€¦; ğ•© = coords = âŸ¨xâ€¿y, â€¦âŸ©
  (Â¯1âŠ‘ğ•¨.Values@)&gt;inp?           # Newest value larger than input?
    Â¯1âŠ‘ğ•¨.Values@;
  grid ğ•Š coords:
    pâ€¿cs â† 1(â†‘â‹ˆâ†“)coords â‹„ pâŠ‘â†©   # Point and rest
    p grid.Set +Â´0âŠ¸grid.GetÂ¨N p # Get neighbour sums and set for point
    grid ğ•Š cs                   # Recurse
}</code></pre>
<p>We smuggle a bit of control flow into <code>Sim</code> via the header <code>(Â¯1âŠ‘ğ•¨.Values@)&gt;inp?</code>
that checks whether the value added last is larger than the input,
in which case we are done.
Otherwise, we divide the list into a head and a tail with <code>1(â†‘â‹ˆâ†“)</code>,
compute the neighbours for the head,
look each of them up in the grid,
sum the results together,
and assign that to the point under consideration.
Then we just recurse to handle the other coordinates.</p>
<p>All thatâ€™s left to do is to supply a source of coordinates, and a fresh hash map with <code>1</code> at index <code>0â€¿0</code>.</p>
<pre class="bqn"><code>{hâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ© â‹„ 0â€¿0 h.Set 1 â‹„ h} Sim Coords 10 # â‡’ 330785</code></pre>
<h3 id="day-4"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day04.bqn">Day 4</a></h3>
<p>Today we are asked to validate some passphrases (our puzzle input).
One such phrase comprises some completely lowercase words separated by spaces: <code>x y</code>, <code>aa bb eix</code>, and so on.
Our input is a list of these things</p>
<pre><code>sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp
xmuf znkhaes pggrlp zia znkhaes znkhaes
nti rxr bogebb zdwrin
sryookh unrudn zrkz jxhrdo gctlyz</code></pre>
<p>Part one wants us to calculate how many passphrases do not contain duplicate words.
BQN essentially gives us everything we need for this: we
<em>sort</em> (<a href="https://mlochbaum.github.io/BQN/doc/order.html#sort"><code>âˆ§</code></a>)
each passphrase,
use
<em>mark firsts</em> (<a href="https://mlochbaum.github.io/BQN/doc/selfcmp.html#mark-firsts"><code>âˆŠ</code></a>)
to mark the first occurrences of every element,
and then check that the resulting vector we get is all ones:</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
+Â´ âˆ§Â´âˆ˜âˆŠâˆ˜(' 'âŠ¸Split)Â¨ â€¢FLines&quot;../inputs/day04.txt&quot; # â‡’ 383</code></pre>
<p>Easy.</p>
<hr />
<p>Part two slightly expands on this;
instead of being unique, words in a passphrase now only have to be unique up to permutation.
This means that no word may be the anagram of another word.
Solving this only requires a small adjustment to the above solution,
in that we now have to sort every word before using <em>mark firsts</em>:</p>
<pre class="bqn"><code>+Â´ âˆ§Â´âˆ˜âˆŠâˆ˜(âˆ§Â¨)âˆ˜(' 'âŠ¸Split)Â¨ â€¢FLines&quot;../inputs/day04.txt&quot; # â‡’ 265</code></pre>
<p>The actually interesting bit about this day was how to combine these two solutions,
which involved writing my first real 1-modifier:</p>
<pre class="bqn"><code>_Sol â† { +Â´ (âˆ§Â´âˆŠâˆ˜ğ”½âˆ˜(' 'âŠ¸Split))Â¨ â€¢FLines &quot;../inputs/day04.txt&quot; }
âŠ¢  _Sol # â‡’ 383
âˆ§Â¨ _Sol # â‡’ 265</code></pre>
<details>
<summary>
The underscore in the name is syntactically relevant.
</summary>
<p>Iâ€™ve not mentioned this until now,
but BQN has a pretty cute system in order to achieve its
<a href="https://mlochbaum.github.io/BQN/doc/context.html">context free grammar</a>;
namely, <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">syntactic roles</a>.
Think of it sort of like a language enforced version of
<a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a><!--
-->â€”trust me, itâ€™s not as horrendous as it sounds!</p>
<p>First, hereâ€™s a fun one:
the following variants all refer to <em>the same</em> identifier: <code>foo</code>, <code>fOo</code>, <code>FOO</code>, <code>___f_o____o</code>, <code>_foo_</code>.
Quite outrageous, but the only way this system can work.</p>
<p>There are just a few roles one needs to keep track of:
subjects like variables, spelled with an initial lower case letter;
functions, featuring an initial upper case letter;
1-modifiers, starting with an underscore;
and 2-modifiers, starting and ending with an underscore.
Keep in mind that builtin functions, 1-modifiers, and 2-modifiers also have consistent syntactic features.
This means that you can decide to which role any identifier belongs by just looking at it,
which can be very useful when trying to decide how an expression should be parenthesised.</p>
<p>The roles themselves are pretty self-explanatory;
functions take variables as their right and left inputs,
modifiers operate on functions, and so on.
The fact that roles can change is how
<a href="https://mlochbaum.github.io/BQN/doc/functional.html">functional programming</a>
works in BQN:</p>
<pre class="bqn"><code>    âŸ¨Ã—Ëœ,âˆšâŸ© {ğ•ğ•©}âŒœ 1â€¿4â€¿9
â”Œâ”€
â•µ 1 16 81
  1  2  3
          â”˜</code></pre>
<p>The function <code>{ğ•ğ•©}</code> a priori takes two subjectsâ€”as all functions doâ€”but then just turns around and treats the left one as a function.
Since we give it a list of functions, this works and we can apply it to the right arguments.
Itâ€™s important that we supplied a list here, btw; <code>Ã—Ëœ {ğ•ğ•©} 4</code> would not work, since <code>Ã—Ëœ</code> has a function role.
In that case, we need to work with variables:</p>
<pre class="bqn"><code>    Square â† Ã—Ëœ
Ã—Ëœ
    square {ğ•ğ•©} 4
16</code></pre>
<p>Honestly, I find this system super interesting,
and quite expressive.
It might be a bit confusing at first,
so I would encourage the reader who made it this far to peruse BQNâ€™s entire
<a href="https://mlochbaum.github.io/BQN/doc/expression.html">expression syntax article</a>.</p>
</details>
<p>We can supply a function to <code>_Sol</code> that additionally transforms the individual words, before doing the uniqueness check.
Then, for part one the supplied function may simply be
<em>identity</em> (<a href="https://mlochbaum.github.io/BQN/doc/identity.html"><code>âŠ¢</code></a>),
which does what it says on the tin.</p>
<h3 id="day-5"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day05.bqn">Day 5</a></h3>
<p>Day 5 asks us to walk through a maze of self-rewriting jump instructions.
Concretely, this means that we are given a vector of numbers,
indicating how far (and in which direction) the jump is; for example,</p>
<pre><code>2
0
0
1
2
0
1
-4</code></pre>
<p>After having jumped, the number at the last instruction is increased by one.
For part one we have to find out when we would exit the vector.
There is no real algorithm to speak of here, so we can just verbatim do what the instructions ask of us:</p>
<pre class="bqn"><code>inp â† â€¢ParseFloatÂ¨ â€¢FLines &quot;../inputs/day05.txt&quot;
Â¯1âŠ‘{ ğ•Šiâ€¿s: # indexâ€¿step
  inp (1âŠ¸+)âŒ¾(iâŠ¸âŠ‘)â†©  # Increase offset
  âŸ¨1-Ëœi+iâŠ‘inp, s+1âŸ© # Subtract one from new index; we just increased the offset
}â€¢_while_{ ğ•Šiâ€¿s: (i&lt;â‰ inp)âˆ§iâ‰¥0 } 0â€¿0   # â‡’ 351282</code></pre>
<p>There are nevertheless a few interesting things about the solution:
<code>inp Fâ†©ï¸</code> <em>modifies</em> <code>inp</code> with the result of calling <code>F inp</code>.<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>
Much more interestingly, however, we can use
<em>under</em> (<a href="https://mlochbaum.github.io/BQN/doc/under.html"><code>âŒ¾</code></a>)
to change only a part of the input vector.
How it works in this â€œstructural modeâ€<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> is that <code>ğ”½âŒ¾ğ”¾ ğ•©</code>
replaces the part of <code>ğ•©</code> thatâ€™s picked out by <code>ğ”¾ğ•©</code>
with the result of <code>ğ”½ğ”¾ğ•©</code>.
As such, it first focuses in on the structure with <code>ğ”¾</code>, applies <code>ğ”½</code>,
and then somehow â€œundoesâ€ the first transformation,
such that the result of <code>ğ”½</code> gets embedded into the original array.</p>
<p>The <code>â€¢_while_</code> 2-modifier is used for iteration:
<code>ğ”½â€¢_while_ğ”¾ ğ•©</code> checks <code>ğ”¾v</code>, where <code>v</code> is initially <code>ğ•©</code>, to see if it should keep iterating;
if yes, it essentially does <code>v ğ”½â†©ï¸</code> and goes back to <code>ğ”¾v</code> (where <code>v</code> is now updated!).
I have to say that I would much rather think in terms of recursive functions,
butâ€”alasâ€”the standard implementation of BQN, <code>cbqn</code>, does not support tail call optimisation.</p>
<hr />
<p>With that done, we have part two waiting for us.
Now, how an instruction changes after we jumped depends on its value:
if itâ€™s three or more, we decrease it by one;
otherwise, we proceed as before and increase it by one.</p>
<pre class="bqn"><code>Â¯1âŠ‘ {ğ•Š iâ€¿s: # indexâ€¿step
  n â† i+iâŠ‘inp
  inp ((3â‰¤iâŠ‘inp)âŠ‘âŸ¨1âŠ¸+, Â¯1âŠ¸+âŸ©)âŒ¾(iâŠ¸âŠ‘)â†©
  âŸ¨ n, s+1 âŸ©
}â€¢_while_{ ğ•Šiâ€¿s: (i&lt;â‰ inp)âˆ§iâ‰¥0 } 0â€¿0  # â‡’ 24568703</code></pre>
<p>This is another neat example of how to use Boolean expressions for control flow:
depending on the result of <code>3â‰¤iâŠ‘inp</code>, we <em>pick</em> the correct function to apply.</p>
<p>Wrapping this in a function that works for both days is not super interesting,
only that we need to find a value <code>t</code> such that <code>tâ‰¤iâŠ‘inp</code> will always be false.
BQN has the aptly named <code>âˆ</code> for that,
which is an infinity according to IEEE 754â€”BQN really only deals with <code>f64</code>â€™s.
While weâ€™re at it, we can add the instruction set as an additional argument to <code>Sim</code>,
so that we donâ€™t have to mutate the input directly.</p>
<pre class="bqn"><code>Sim â† { thresh ğ•Š insâ€¿iâ€¿s: # instructionsâ€¿indexâ€¿step
  n â† i+iâŠ‘ins
  ins ((thresh â‰¤ iâŠ‘ins)âŠ‘âŸ¨1âŠ¸+, Â¯1âŠ¸+âŸ©)âŒ¾(iâŠ¸âŠ‘)â†©
  insâ€¿nâ€¿(s+1)
}
Â¯1âŠ‘ âˆ Sim â€¢_while_ { Â·ğ•Šinsâ€¿iâ€¿s: (i&lt;â‰ ins)âˆ§iâ‰¥0 } inpâ€¿0â€¿0 # â‡’ 351282
Â¯1âŠ‘ 3 Sim â€¢_while_ { Â·ğ•Šinsâ€¿iâ€¿s: (i&lt;â‰ ins)âˆ§iâ‰¥0 } inpâ€¿0â€¿0 # â‡’ 24568703</code></pre>
<h2 id="days-610">Days 6â€“10</h2>
<h3 id="day-6"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day06.bqn">Day 6</a></h3>
<p>Today we are tasked with redistributing blocks in a memory bank.
Concretely, we are given a vector like <code>âŸ¨0, 2, 7, 0âŸ©</code> and,
in every step,
we look for the maximal element <code>m</code>, and â€œredistributeâ€ its value by adding one to each successor in the circular list until <code>m</code> steps have been taken.
For example, the first few redistributions with the above start look like this:</p>
<pre class="bqn"><code>âŸ¨0, 2, 7, 0âŸ©  â†’  âŸ¨2, 4, 1, 2âŸ©  â†’  âŸ¨3, 1, 2, 3âŸ©</code></pre>
<p>Notice in particular that the redistribution starts by â€œemptyingâ€ the bank with the highest value,
so <code>âŸ¨0, 2, 7, 0âŸ©</code> is first transformed into <code>âŸ¨0, 2, 0, 0âŸ©</code>, then into <code>âŸ¨0, 2, 0, 1âŸ©</code>, then into <code>âŸ¨1, 2, 0, 1âŸ©</code>, and so on.
At some point, we willâ€”so the problem saysâ€”reach a configuration that we were already in before,
and part one asks us to find the number of cycles before that happens.</p>
<p>Parsing is the easy part, as the input just comprises a bunch of numbers on the first line:</p>
<pre class="bqn"><code>âŸ¨Split, tabâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
inp â† â€¢ParseFloatÂ¨ tab Split âŠ‘â€¢FLines &quot;../inputs/day06.txt&quot;</code></pre>
<p>The only interesting part of the solution is, I guess,
the encoding of the redistribution.
The basic idea is to take a number <code>n</code> at position <code>i</code>,
create a vector of 1â€™s of length <code>n</code>,
pad with <code>i</code> zeros on the left,
and then press that into the length of the vector.</p>
<pre class="bqn"><code>    vâ†âŸ¨0,2,7,0âŸ©         # Test vector with max 7 at position 2
âŸ¨ 0 2 7 0 âŸ©
    Â¯7âˆ¾7â¥Š1              # Shape of 1's and Â¯7
âŸ¨ Â¯7 1 1 1 1 1 1 1 âŸ©
    (2â¥Š0)âˆ¾Â¯7âˆ¾7â¥Š1        # Pad with zeros up to index
âŸ¨ 0 0 Â¯7 1 1 1 1 1 1 1 âŸ©
    â†‘â€¿4â¥Š(2â¥Š0)âˆ¾Â¯7âˆ¾7â¥Š1    # Reshape to dimensions of v, and use fills
â”Œâ”€
â•µ 0 0 Â¯7 1
  1 1  1 1
  1 1  0 0
           â”˜
   +Ëâ†‘â€¿4â¥Š(2â¥Š0)âˆ¾Â¯7âˆ¾7â¥Š1   # Sum up columns
âŸ¨ 2 2 Â¯6 2 âŸ©
    v + âŸ¨ 2, 2, Â¯6, 2 âŸ© # And we get the second step!
âŸ¨ 2 4 1 2 âŸ©</code></pre>
<details>
<summary>
Fills and special symbols for <em>reshape</em>
</summary>
<p>As you may have noticed, we gave the symbol <code>â†‘</code> to <em>reshape</em> above.
Ordinarily, this is the <em>take</em> (or <em>prefixes</em>) function, but here it stands in as a special symbol to alter the behaviour of <em>reshape</em>.
This, as well as various other values, is documented
<a href="https://mlochbaum.github.io/BQN/doc/reshape.html#computed-lengths">here</a>,
the relevant excerpt being</p>
<blockquote>
<p><code>â†‘</code> rounds the length up, but uses the argumentâ€™s fill for the needed extra elements.</p>
</blockquote>
<hr />
<p><a href="https://mlochbaum.github.io/BQN/doc/fill.html">Fill elements</a>
are basically certain â€œdefaultâ€ values of a given array.
Operations on the array might make use of them if the array would otherwise end up having holes in it.
Atomically, they are either <code>0</code> (for numbers) or <code>' '</code> (for characters),
and higher dimensional arraysâ€”being inductively defined in BQNâ€”can inherit from this.
A canonical example is <em>take</em> when the number of elements to be taken is longer than the length of the argument:</p>
<pre class="bqn"><code>    3â€¿3â¥Šâ†•9
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
        â”˜
   4â†‘3â€¿3â¥Šâ†•9
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
  0 0 0
        â”˜</code></pre>
<p>This is also how things like <em>nudge</em> decide what to pad the array with.</p>
<pre class="bqn"><code>    1+â†•9
âŸ¨ 1 2 3 4 5 6 7 8 9 âŸ©
    Â»1+â†•9
âŸ¨ 0 1 2 3 4 5 6 7 8 âŸ©
    Â«1+â†•9
âŸ¨ 2 3 4 5 6 7 8 9 0 âŸ©</code></pre>
<hr />
<p>Reshaping may also use a fill element,
if the dimensions of the reshape are not exactly divisible by the shape of the original array:</p>
<pre class="bqn"><code>  3â€¿â†‘ â¥Š 7â¥Š1 # After running out of 1's, use 0's for padding
â”Œâ”€
â•µ 1 1 1
  1 1 1
  1 0 0
        â”˜</code></pre>
</details>
<p>To keep track of the already seen configurations,
we could again use a hash map as in <a href="#day-3">day 3</a>.
However, the number of configurations isnâ€™t actually that large, so a normal list suffices.
Appropriately generalising the above construction nets us the result for part one:</p>
<pre class="bqn"><code>sâ€¿d â† { seenâ€¿xs:
    m â† âŒˆÂ´xs              # max elements -&gt; to be redistributed
    âŸ¨ seenâˆ¾&lt;xs, xs+ +Ëâ†‘â€¿(â‰ xs)â¥Š(0â¥ŠËœâŠ‘xsâŠm)âˆ¾âŸ¨-mâŸ©âˆ¾mâ¥Š1 âŸ©
    #                 reshape  before     at  after
  } â€¢_while_ {
    seenâ€¿xs: âŠ‘Â¬(&lt;xs)âˆŠseen # while not seen
  } âŸ¨âŸ©â€¿inp
â‰ s                        # â‡’ 7864</code></pre>
<hr />
<p>Part two is just a slight variation on this idea:
we now also have to calculate the exact cycle length.
Since <code>â€¢_while_</code> does not actually add the last memory bank state <code>d</code> to the vector <code>s</code>,
this just involves checking for <code>d</code>â€˜s index in <code>s</code>
and subtracting that from the vectorsâ€™ length:</p>
<pre class="bqn"><code>âŠ‘(â‰ s)-sâŠ&lt;d # â‡’ 1695</code></pre>
<p>Notice how we need to <em>enclose</em> <code>d</code> before using
<em>index of</em> (<a href="https://mlochbaum.github.io/BQN/doc/search.html#index-of"><code>âŠ</code></a>).
Since <code>d</code> is a vector itself, the pervasive aspect of <em>index of</em> would otherwise ruin our day.</p>
<h3 id="day-7"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day07.bqn">Day 7</a></h3>
<p>This day has us study a tree of programs.
To every program, one associates a weight and a (possibly empty) number of children.
Our input is in the form of an adjacency list:</p>
<pre><code>ktlj (57)
fwft (72) -&gt; ktlj, cntj, xhth
qoyq (66)
padx (45) -&gt; pbga, havc, qoyq</code></pre>
<p>More visually, such a tree can be written as</p>
<pre><code>                gyxo
              /
         ugml - ebii
       /      \
      |         jptl
      |
      |         pbga
     /        /
tknk --- padx - havc
     \        \
      |         qoyq
      |
      |         ktlj
       \      /
         fwft - cntj
              \
                xhth</code></pre>
<p>Part one asks us for the root node.
Parsing is a bit ad-hoc, but not all that complicated:
for a single line of the form <code>a (7) -&gt; b, c</code>,
we first split every line by whitespace,
use the first and second entry in the resulting vector verbatim,
drop the <code>-&gt;</code>, and
split the rest on <code>,</code>.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
inp â† {
  ws â† ' ' Split ğ•©
  âŸ¨ âŠ‘ws, â€¢BQN 1âŠ‘ws, ','Splitâˆ¾3â†“ws âŸ© # nameâ€¿weightâ€¿children
}Â¨ â€¢FLines&quot;../inputs/day07.txt&quot;
# â‡’ âŸ¨ âŸ¨&quot;mmqyju&quot; 156 âŸ¨&quot;rjzvwv&quot; &quot;noybkx&quot;âŸ©âŸ© â€¦ âŸ©</code></pre>
<p>The <code>â€¢BQN</code> function is something like <code>eval</code> in lisps, or <code>â</code> in APL:
it evaluates the given string
(though, unlike APL, it does so in an isolated environment)
and returns the result, whatever it may be.
This is how we get away with parsing <code>"(8)"</code> to <code>8</code>,
which is something that an ordinary <code>â€¢ParseFloat</code> would fail at.</p>
<p>The root node can be found without thinking about the tree at all:
just check which node does not appear as a child of another one.</p>
<pre class="bqn"><code>root â† âŠ‘ (âŠ‘Â¨inp)(Â¬âˆ˜âˆŠ/âŠ£)(âˆ¾Â¯1âŠ‘Â¨inp) # â‡’ &quot;svugo&quot;
#        nodes  not-in  children</code></pre>
<p>Recall the â€œnot-inâ€ idiom <code>Â¬âˆ˜âˆŠ/âŠ£</code> from when we talked about trains.</p>
<hr />
<p>Part two now makes use of the weights, which we havenâ€™t at all needed so far.
Our goal is to balance the tower of programs, so that the children of every node sum up to the same value.
For example, given the input</p>
<pre><code>pbga (66)
xhth (57)
ebii (61)
havc (66)
ktlj (57)
fwft (72) -&gt; ktlj, cntj, xhth
qoyq (66)
padx (45) -&gt; pbga, havc, qoyq
tknk (41) -&gt; ugml, padx, fwft
jptl (61)
ugml (68) -&gt; gyxo, ebii, jptl
gyxo (61)
cntj (57)</code></pre>
<p>for the root, <code>tknk</code>, we would get the following sums of children:</p>
<ul>
<li><code>ugml</code> + (<code>gyxo</code> + <code>ebii</code> + <code>jptl</code>) = 68 + (61 + 61 + 61) = 251</li>
<li><code>padx</code> + (<code>pbga</code> + <code>havc</code> + <code>qoyq</code>) = 45 + (66 + 66 + 66) = 243</li>
<li><code>fwft</code> + (<code>ktlj</code> + <code>cntj</code> + <code>xhth</code>) = 72 + (57 + 57 + 57) = 243</li>
</ul>
<p>The problem tells us that, actually, only one program has the wrong weight.
Above, thatâ€™d be <code>ugml</code>, which would have to change from weight <code>68</code> to <code>60</code>â€”the answer.</p>
<pre class="bqn"><code>h â† âŸ¨âŸ©â€¢HashMapâŸ¨âŸ© â‹„ { nâ€¿wâ€¿ch: n h.Set wâ€¿ch }Â¨inp # name -&gt; weight, children
M â† =Â´2â†‘âŠ‘Â¨ # Do the first two elements have matching cumulative weights?
SpotOutlier â† {
  wâ€¿ch â† h.Get ğ•©
  sums â† âˆ§ğ•ŠÂ¨ch       # Sort by ascending w+wc
  { ğ•ŠâŸ¨âŸ©: wâ€¿w;        # No children
    ğ•Šs : M s? MâŒ½s?   # All child nodes's weights match
      âŸ¨w++Â´âŠ‘Â¨s, wâŸ©;
    ğ•Šs : M s?        # Last weight is higher than the [o]ther[w]eights
      wwcâ€¿mwâ†Â¯1âŠ‘s â‹„ owâ€¿Â·â†  âŠ‘s â‹„ (mw-wwc-ow)!0;
    ğ•Šs : MâŒ½s?        # First weight is lower than the [o]ther[w]eights
      wwcâ€¿mwâ†  âŠ‘s â‹„ owâ€¿Â·â†Â¯1âŠ‘s â‹„ (mw-wwc-ow)!0
  } sums
}

SpotOutlierâŠâ€¢CurrentError root # â‡’ 1152</code></pre>
<p>This looks like a lot of code, but the underlying recursive algorithm is not so complicated:</p>
<ul>
<li>For all children of the given node,
create tuples of the total weight of each child <code>c</code> (including <code>c</code>â€™s children) and <code>c</code>â€™s own weight,
and sort the resulting list in ascending order.
This split of â€œweightâ€ and â€œweight with childrenâ€ is necessary,
since we want to adjust the weight of the node at the end.</li>
<li>Then, we check for the only conditions that can occur.<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>
<ul>
<li>If the list is empty that means there are no children and the node is leaf,
so we hit the base case.</li>
<li>If the weights of all children match,
then we return the weight of the node and its children.</li>
<li>Otherwise, the weight that doesnâ€™t match is singled out,
and the correct weight the node should have is thrown as an exception.</li>
</ul></li>
</ul>
<p>Yes, feeling like a Python programmer, exceptions are used for control flow!
Since we immediately want to exit the function, no questions asked,
this seems as good a time as any to do something like that.
The <em>assert</em> function <a href="https://mlochbaum.github.io/BQN/doc/assert.html#assert"><code>!</code></a>
throws an exception if its right argument is not <code>1</code>.
In case itâ€™s supplied a left argument, this is the value of the exception.
In the call to <code>SpotOutlier</code>, we can use the
<em>catch</em> (<a href="https://mlochbaum.github.io/BQN/doc/assert.html#catch"><code>âŠ</code></a>) 2-modifier to catch the exception.
Since <em>catch</em> doesnâ€™t actually know anything about the error<!--
-->â€”only that one occurredâ€”<!--
-->we need the system value <code>â€¢CurrentError</code> to access it.</p>
<h3 id="day-8"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day08.bqn">Day 8</a></h3>
<p>Today we have to help the CPU simulate a small language,
consisting of simple register instructions like the following:</p>
<pre><code>b inc 5 if a &gt; 1
a inc 1 if b &lt; 5
c dec -10 if a &gt;= 1
c inc -20 if c == 10</code></pre>
<p>The instructions are given in a pretty rigid form;
abstractly, one has something like</p>
<pre><code>Â«registerÂ» Â«operationÂ» Â«numberÂ» if Â«registerÂ» Â«comparisonÂ» Â«numberÂ»</code></pre>
<p>where <code>Â«operationÂ»</code> is one of <code>inc dec</code>, and <code>Â«comparisonÂ»</code> is one of <code>&gt; &lt; &gt;= == &lt;= !=</code>.
Part one asks us what the largest value in any register is after executing each instruction once.</p>
<p>Perhaps unexpectedly, there is a relatively obvious bijection between the instruction syntax and the relevant BQN code!</p>
<ul>
<li>A number is a number.
Due to the right hand side only being zero or one,
we donâ€™t even need to change <code>-20</code> into <code>Â¯20</code>,
but can keep <code>-</code> as a function.</li>
<li>A register is a variable holding a number.</li>
<li>A register operation is a call to <em>modify</em> for that register.</li>
<li>A comparison is a comparison.</li>
<li>An <code>if</code> instruction is a multiplication of the condition with the â€œthen branchâ€.
Since BQN is evaluated right to left,
this works on-the-nose and no extra parentheses are needed.</li>
</ul>
<p>Here are some sample translations:</p>
<pre><code>b inc 5   if a  &gt; 1   â†”  b+â†©5   Ã— a&gt;1
a inc 1   if b  &lt; 5   â†”  a+â†©1   Ã— b&lt;5
c dec -10 if a &gt;= 1   â†”  c-â†©-10 Ã— aâ‰¥1
c inc -20 if c == 10  â†”  c+â†©-20 Ã— c=10</code></pre>
<p>Pretty neat, huh?
The plan is clear: transform every line into its equivalent BQN code,
and evaluate everything with <code>â€¢BQN</code>.
We have previously seen this function on <a href="#day-7">day 7</a>,
where itâ€™s essentially used as a shorthand for <code>â€¢ParseFloat</code>â€”now we really want it to execute some code!
Letâ€™s first split every instruction into a list of its constituent words.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ©â†â€¢Import&quot;../../util/bqn_util/util.bqn&quot;
inp â† ' 'âŠ¸SplitÂ¨ â€¢FLines&quot;../inputs/day08.txt&quot;
# e.g., &quot;c inc -20 if c == 10&quot; â†’ âŸ¨&quot;c&quot;, &quot;inc&quot;, &quot;-20&quot;, &quot;if&quot;, &quot;c&quot;, &quot;==&quot;, &quot;10&quot;âŸ©</code></pre>
<p>Now we can replace every element with its BQN equivalent.</p>
<pre class="bqn"><code>C â† { # Convert instruction ğ•© to BQN code
  from â† âŸ¨&quot;if&quot;, &quot;dec&quot;, &quot;inc&quot;, &quot;&gt;=&quot;, &quot;==&quot;, &quot;&lt;=&quot;, &quot;!=&quot;âŸ©
  to   â† âŸ¨&quot;Ã—&quot; , &quot;-â†©&quot; , &quot;+â†©&quot; , &quot;â‰¥&quot; , &quot;=&quot; , &quot;â‰¤&quot; , &quot;â‰ &quot; , âŠ¢âŸ© # last is fallthrough
  {âŠ‘fromâŠ&lt;ğ•©}â—¶toÂ¨ğ•©
}</code></pre>
<p>This can be conveniently done with the
<em>choose</em> (<a href="https://mlochbaum.github.io/BQN/doc/choose.html"><code>â—¶</code></a>) 2-modifier.
Abstractly, <code>ğ”½â—¶ğ•˜ ğ•©</code> applies <code>ğ”½</code> to <code>ğ•©</code>, which should return an index.
It then <em>picks</em> that index from the list <code>ğ•˜</code> (remember syntactic roles?).
This should result in a function <code>G</code>, which is then applied to <code>ğ•©</code>, yielding the final result:</p>
<pre class="bqn"><code>_choose_ â† {
  g â† (ğ”½ğ•©)âŠ‘ğ•˜
  Gğ•©
}</code></pre>
<p>In this specific example, for each string in <code>ğ•©</code>,
we first get its index in the <code>from</code> vector.
If the element is not found, then <em>index of</em> returns the length of the vectorâ€”an invalid indexâ€”instead.
Then, we apply the picked function in <code>to</code> to the element we started with.
In almost all cases, whatâ€™s being picked from <code>to</code> is actually a string, which is interpreted as the constant function on that value, so nothing happens.
In case the element is not found, however, we apply <em>identity</em>, in order to not lose any information.</p>
<pre class="bqn"><code>    {âŠ‘fromâŠ&lt;ğ•©}Â¨âŸ¨ &quot;d&quot;, &quot;dec&quot;, &quot;683&quot;, &quot;if&quot;, &quot;qn&quot;, &quot;==&quot;, &quot;0&quot; âŸ©
âŸ¨ 7 1 7 0 7 4 7 âŸ©
    {âŠ‘fromâŠ&lt;ğ•©}â—¶toÂ¨âŸ¨ &quot;d&quot;, &quot;dec&quot;, &quot;683&quot;, &quot;if&quot;, &quot;qn&quot;, &quot;==&quot;, &quot;0&quot; âŸ©
âŸ¨ &quot;d&quot; &quot;-â†©&quot; &quot;683&quot; &quot;Ã—&quot; &quot;qn&quot; &quot;=&quot; &quot;0&quot; âŸ©</code></pre>
<p>Letâ€™s get to simulating!
As I said before, <code>â€¢BQN</code> evaluates everything in a rather sandboxed environment.
While itâ€™s possible to inject some variable definitions into the namespace it uses,
it seemed easiest to me to just shove everything we need into a single invocation of the function.
That means lots of tasty string manipulation.</p>
<pre class="bqn"><code>r â† âˆŠâŠ¸/ âŠ‘Â¨inp        # all registers   â‡’ âŸ¨ &quot;d&quot; &quot;rak&quot; â€¦ âŸ©
â€¢BQN âˆ¾âŸ¨
  âˆ¾ âˆ¾âŸœ&quot;â†0â‹„&quot;Â¨r        # zero everything â‡’ &quot;dâ†0 â‹„ rakâ†0 â‹„ â€¦&quot;
  (âˆ¾âŸœ&quot;â‹„&quot;âŠ¸âˆ¾)Â´(âˆ¾C)Â¨inp # instructions    â‡’ &quot;d-â†©683Ã—qn=0 â‹„ d-â†©-220Ã—h=0 â‹„ â€¦&quot;
  &quot;â‹„âŒˆÂ´&quot;âˆ¾(âˆ¾âŸœ&quot;â€¿&quot;âŠ¸âˆ¾)Â´r  # get max         â‡’ &quot;â‹„âŒˆÂ´dâ€¿rakâ€¿â€¦&quot;
âŸ© # â‡’ 4416</code></pre>
<hr />
<p>Part two instead asks us for the largest value that is ever held in any register during the execution of the program.
This introduces some notational, if not conceptual, difficultiesâ€”but nothing we canâ€™t manage!
Simply introduce an additional register that contains this information,
and update it after every â€œnormalâ€ instruction.</p>
<pre class="bqn"><code>â€¢BQN âˆ¾âŸ¨
  &quot;h_râ†0â‹„&quot;âˆ¾âˆ¾âˆ¾âŸœ&quot;â†0â‹„&quot;Â¨r # zero everything â‡’ &quot;h_râ†0 â‹„ dâ†0 â‹„ rakâ†0 â‹„ â€¦&quot;
  (âˆ¾âŸœ&quot;â‹„&quot;âŠ¸âˆ¾)Â´({âˆ¾ğ•©âˆ¾&quot;â‹„h_râŒˆâ†©&quot;âˆ¾âŠ‘ğ•©}C)Â¨inp
                      # Check highest after every instruction
                      # â‡’ &quot;d-â†©683Ã—qn=0 â‹„ h_râŒˆâ†©d â‹„ d-â†©-220Ã—h=0 â‹„ h_râŒˆâ†©dâ€¦&quot;
  &quot;â‹„ h_r&quot;
âŸ© # â‡’ 5199</code></pre>
<h3 id="day-9"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day09.bqn">Day 9</a></h3>
<p>Today, we need to clean up garbage from a stream of characters like <code>{&lt;{o"i!a,&lt;{i&lt;a&gt;e}</code>.
There are a few special characters that one needs to watch out for:
<code>{</code> and <code>}</code> delimit a group,
<code>&lt;</code> and <code>&gt;</code> start and end garbage,
and <code>!</code> ignores the next symbol.
We are given a few examples of self-contained pieces of garbage:</p>
<blockquote>
<ul>
<li><code>&lt;&lt;&lt;&lt;&gt;</code>, because the extra &lt; are ignored.</li>
<li><code>&lt;{!&gt;}&gt;</code>, because the first &gt; is canceled.</li>
<li><code>&lt;!!&gt;</code>, because the second ! is canceled, allowing the &gt; to terminate the garbage.</li>
<li><code>&lt;!!!&gt;&gt;</code>, because the second ! and the first &gt; are canceled.</li>
</ul>
</blockquote>
<p>By assumption, the whole input is one big group;
part one asks how many small groups are contained in it.
Groups are counted according to their depth, so <code>{{{}}}</code> gets a score of <code>1+2+3</code>,
and <code>{{},{}}</code> gets a score of <code>1+2+2</code>.</p>
<p>My solution here is actually quite crude and not all that interesting.
My first idea was to use regular expressions to clean up the stream<!--
-->â€”seems like a good fitâ€”<!--
-->but, alas, <code>cbqn</code> does not support any sort of regexp, as far as I can tell.
Oh well.
Doing it in a single pass would be nice, though,
so letâ€™s do what any psychopath would,
and simply pattern match on the hard-coded invariants:</p>
<pre class="bqn"><code>Solve â† {
  ğ•©âŠ‘ 0â€¿0â€¿0â€¿0â€¿0 { # char ğ•Š inGarbage?â€¿ignored?â€¿depthâ€¿scoreâ€¿garbageCount
    '{' ğ•Š 0â€¿iâ€¿dâ€¿sâ€¿c: 0â€¿0â€¿(d+Â¬i)â€¿sâ€¿c;
    '}' ğ•Š 0â€¿iâ€¿dâ€¿sâ€¿c: 0â€¿0â€¿(d-Â¬i)â€¿(s+dÃ—Â¬i)â€¿c;
    '!' ğ•Š gâ€¿0â€¿dâ€¿sâ€¿c: gâ€¿1â€¿dâ€¿sâ€¿c;
    '&lt;' ğ•Š 0â€¿0â€¿dâ€¿sâ€¿c: 1â€¿0â€¿dâ€¿sâ€¿c;
    '&gt;' ğ•Š 1â€¿iâ€¿dâ€¿sâ€¿c: iâ€¿0â€¿dâ€¿sâ€¿c;
    cr  ğ•Š gâ€¿iâ€¿dâ€¿sâ€¿c: gâ€¿0â€¿dâ€¿sâ€¿(c+gâˆ§Â¬i)
  }Â´ âŒ½â€¢FChars&quot;../inputs/day09.txt&quot;
}
Solve Â¯2 # â‡’ 16869</code></pre>
<p>It works, I guess.
Some of the invariants are packed inside of one clause;
e.g., the line</p>
<pre class="bqn"><code>'{' ğ•Š 0â€¿iâ€¿dâ€¿sâ€¿c: 0â€¿0â€¿(d+Â¬i)â€¿sâ€¿c;</code></pre>
<p>adds one to the depth only if the character is not ignored
(<code>d+Â¬i</code> evaluates to <code>d</code> for <code>i=1</code>, and to <code>d+1</code> in case <code>i=0</code>).</p>
<hr />
<p>Part two asks us to find all non-cancelled characters hiding within the garbage.
There are some special rules in that we donâ€™t want to count the enclosing <code>&lt;&gt;</code>â€™s,
but other than that this is pretty straightforward (and already included in <code>Solve</code>):</p>
<pre class="bqn"><code>Solve Â¯1 # â‡’ 7284</code></pre>
<h3 id="day-10"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day10.bqn">Day 10</a></h3>
<p>On day 10 we are asked to implement a custom hashing algorithm, based on knots.
The basis of the algorithm is a â€œpinch and twistâ€ move.</p>
<pre><code>  4--5   pinch   4  5           4   1
 /    \  5,0,1  / \/ \  twist  / \ / \
3      0  --&gt;  3      0  --&gt;  3   X   0
 \    /         \ /\ /         \ / \ /
  2--1           2  1           2   5</code></pre>
<p>Rather bravely, the problemâ€¦ just gives us the instructions on how to do this with a flat list.</p>
<blockquote>
<p>To achieve this, begin with a list of numbers from 0 to 255, a current position which begins at 0 (the first element in the list), a skip size (which starts at 0), and a sequence of lengths (your puzzle input). Then, for each length:</p>
<ul>
<li>Reverse the order of that length of elements in the list, starting with the element at the current position.</li>
<li>Move the current position forward by that length plus the skip size.</li>
<li>Increase the skip size by one.</li>
</ul>
</blockquote>
<p>Part one essentially asks us to simulate our input,
and to multiply the first two numbers in the resulting list.
As written above, the puzzle input looks like <code>3, 4, 1, 5</code>, and represents the sequence of lengths.
We can (ab)use <code>â€¢BQN</code> again to directly parse this into a vector.</p>
<pre class="bqn"><code>inp â† â€¢BQN 'âŸ¨'âˆ¾'âŸ©'âˆ¾Ëœ âŠ‘â€¢FLines&quot;../inputs/day10.txt&quot;</code></pre>
<p>Simulating one round works as described above.</p>
<pre class="bqn"><code># One round; ğ•¨: one length; ğ•©: âŸ¨list of marks, position, skip sizeâŸ©
R â† { n ğ•Š xsâ€¿pâ€¿ss:
  lâ†â‰ xs
  âŸ¨ âŒ½âŒ¾((l|p+â†•n)âŠ¸âŠ)xs , l|p+n+ss , ss+1 âŸ©
}
Ã—Â´ 2â†‘ âŠ‘ (â†•256)â€¿0â€¿0 RÂ´ âŒ½inp # â‡’ 13760</code></pre>
<p>The only thing we have to keep in mind is that indexing has to be circular.
Due to the fantastic <em>under</em> 2-modifier, this is all pretty ergonomic.</p>
<hr />
<p>Part two now wants us to implement the whole hashing algorithm.
Hereâ€™s essentially what we have to do:</p>
<ul>
<li>Treat our input a bit differently, to get a different â€œlengthâ€ vector;</li>
<li>repeat the algorithm from part one exactly 64 times, keeping the index and skip size intact across runs;</li>
<li>from the 256 numbers in the vector, create blocks of 16 numbers each and XOR them together; and</li>
<li>convert each of the resulting 16 bytes into their hex representation.</li>
</ul>
<p>Regarding the first point: we now treat every characterâ€”including the commasâ€”of the input string as a separate input number.
So given <code>1,2,3</code> as an input, we would first transform it to <code>49 44 50 44 51</code> before continuing.
Additionally, we have to append the magic numbers <code>17 31 73 47 23</code> to the input.
This neatly showcases one of the many uses for affine characters:<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a></p>
<pre class="bqn"><code>inp2 â† âŒ½ âŸ¨17, 31, 73, 47, 23âŸ©âˆ¾Ëœ @-Ëœ âŠ‘â€¢FLines&quot;../inputs/day10.txt&quot;</code></pre>
<p>Since BQN does not have any format strings,
one has to implement base conversions from scratch.
Here is one from decimal to hexadecimal, specialised to one byteâ€”always two characters, padded with <code>0</code> if need be:<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a></p>
<pre class="bqn"><code>DecToHex â† { &quot;0123456789abcdef&quot; âŠËœ 16(âŒŠâˆ˜Ã·Ëœ â‹ˆ |)ğ•© }</code></pre>
<p>Finally, we get to XORing!
One thing that bit me here is that BQN does not support bit operations on unsigned types, only signed and float.
As such, even though all of the numbers are 8-bit unsigned integers, we have to operate on 16-bit <em>signed</em> integers instead.</p>
<pre class="bqn"><code>X â† âŠ‘â‹ˆâŠ¸(16â€¢bit._xor)Â´ # XOR two 16 bit signed ints together</code></pre>
<p><em>Enlist</em>
(<a href="https://mlochbaum.github.io/BQN/doc/pair.html"><code>â‹ˆ</code></a>)
is needed here because at least one of the inputs to <code>â€¢bit.xor</code> should have rank larger than zero
(no, I donâ€™t know why).
We can now assemble all the pieces together:</p>
<pre class="bqn"><code>âˆ¾ DecToHexâˆ˜XÂ¨ 16(/â¥ŠËœ)âŠ¸âŠ” âŠ‘ RÂ´âŸœinp2âŸ64 (â†•256)â€¿0â€¿0
# â‡’ &quot;2da93395f1a6bb3472203252e3b17fe5&quot;</code></pre>
<p>I think the <code>n (/â¥ŠËœ)âŠ¸âŠ” xs</code> is quite cute.
We first <em>reshape</em> the number <code>n</code> into a vector <code>n n â€¦</code> of length <code>n</code>,
and then use <em>indices</em> to create a list like <code>0 0 0 â€¦ 1 1 1 â€¦ n n n â€¦</code>,
with each number appearing exactly <code>n</code> times.
Then we can use the vanilla <em>group</em> function to partition the given list into that many chunks.
This obviously only makes sense in this specific scenario; still, cute.</p>
<h2 id="days-1115">Days 11â€“15</h2>
<h3 id="day-11"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day11.bqn">Day 11</a></h3>
<p>This day wants us to walk some steps on a <a href="https://en.wikipedia.org/wiki/Hexagonal_tiling">hexagonal grid</a>.
The coordinate system is defined like this:</p>
<pre><code>  \ n  /
nw +--+ ne
  /    \
-+      +-
  \    /
sw +--+ se
  / s  \</code></pre>
<p>Part one asks us to follow our input<!--
-->â€”which is a string of instructions where to walk, like <code>ne,sw,ne,s,â€¦</code>â€”<!--
-->and then calculate a Manhattan-type distance from from the origin to the stopping point.</p>
<p>The difficult part here would be to find a comprehensible coordinate system to represent hexagonal grids.
Thankfullyâ€”or sadly?â€”I remember doing the exact same thing in a previous year.
I wanted to use
<a href="https://en.wikipedia.org/wiki/Hexagonal_Efficient_Coordinate_System">HECS</a>
just for the name, but since all we really do is to calculate neighbours,
an <a href="https://www.redblobgames.com/grids/hexagons/#coordinates-axial">axial</a><a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> coordinate system seems like a safer bet.
Basically, since a hex grid has three major axes that one can walk along,
we embed the grid in a cube with standard Cartesian coordinates <code>x y z</code>, with the additional constraint that <code>0=x+y+z</code>.
This in particular means that we donâ€™t actually have to care about <code>z</code> at all.
Given any coordinate, itâ€™s neighbours have the following offsets:</p>
<pre><code>    \ 0,Â¯1 /
     \    /
Â¯1,0  +--+  1,Â¯1
     /    \
 ---+      +---
     \    /
Â¯1,1  +--+  1,0
     /    \
    / 0, 1 \</code></pre>
<p>The Manhattan distance in this encoding is just the sum of the two coordinates.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
dirs â† &quot;n&quot;â€¿&quot;ne&quot;â€¿&quot;se&quot;â€¿&quot;s&quot;â€¿&quot;sw&quot;â€¿&quot;nw&quot;
movs â† âŸ¨ 0â€¿Â¯1, 1â€¿Â¯1, 1â€¿0, 0â€¿1, Â¯1â€¿1, Â¯1â€¿0 âŸ©
pts â† {âŠ‘movs/Ëœ(&lt;ğ•©)â·dirs}Â¨ ','Split âŠ‘â€¢FLines &quot;../inputs/day11.txt&quot;
+Â´| +Â´pts # â‡’ 707</code></pre>
<p>We immediately translate each direction into a coordinate using a combination of <em>find</em>
(<a href="https://mlochbaum.github.io/BQN/doc/find.html"><code>â·</code></a>)
and <em>replicate</em>,
and thatâ€™s basically it.</p>
<hr />
<p>Part two is a slight variation of this idea:
what is the furthest away we have ever been during this process?
This just means that, instead of a <em>fold</em> over the list,
we use a <em>scan</em> and take the maximum distance.</p>
<pre class="bqn"><code>âŒˆÂ´ +Â´âˆ˜|Â¨ +`pts # â‡’ 1490</code></pre>
<h3 id="day-12"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day12.bqn">Day 12</a></h3>
<p>Itâ€™s another graph problem!
Today, we have to help a village of processes to communicate via pipes.
The input datum is an adjacency list of nodes and their neighbours.</p>
<pre><code>0 &lt;-&gt; 2
1 &lt;-&gt; 1
2 &lt;-&gt; 0, 3, 4
3 &lt;-&gt; 2, 4
4 &lt;-&gt; 2, 3, 6
5 &lt;-&gt; 6
6 &lt;-&gt; 4, 5</code></pre>
<p>Parsing this is not terribly difficult:</p>
<pre class="bqn"><code>inp â† (âŠ‘â‹ˆ2âŠ¸â†“)âˆ˜(â€¢BQNÂ¨)âˆ˜(' 'âŠ¸Split)Â¨â€¢FLines&quot;../inputs/day12.txt&quot;
# â‡’ âŸ¨ âŸ¨0,âŸ¨2âŸ©âŸ©, âŸ¨1,âŸ¨1âŸ©âŸ©, âŸ¨2,âŸ¨0,3,4âŸ©âŸ©, â€¦ âŸ©</code></pre>
<p>We first split each line on spaces, and then <code>â€¢BQN</code> the whole thing.
This is convenient for two reasons:
it parses numbers followed by commas, like <code>10,</code>, as numbers,
and interprets the <code>&lt;-&gt;</code> part as a train, so we donâ€™t even have to do any further filtering.</p>
<p>The first part wants us to find the path-component of <code>0</code>.
One could now think hard about how to efficiently encode a graph in BQN for these path finding types of problemsâ€¦
or one could brute force the solution.
Since the input graph is not that big,
letâ€™s just do the latter.
Starting from <code>0</code>, maintain a list of neighbours that are known to connect to it.
Then fold over the adjacency list and add the neighbours of every vertex weâ€™ve already seen along the way.
In code (monadic <code>â·</code> is called <em>deduplicate</em> and does what it says on the tin):</p>
<pre class="bqn"><code>Group â† { # ğ•©: adjacency list: âŸ¨ âŸ¨n, neighboursâŸ©, â€¦ âŸ©
  âŸ¨0âŸ© { vâ€¿ns ğ•Š seen: âŠ‘vâˆŠseen? â·seenâˆ¾ns; ğ•© }Â´ ğ•©
}</code></pre>
<p>Now, the above snippet does not work at all, because obviously the list does not have to be in order.
Consider</p>
<pre><code>3 &lt;-&gt; 1
2 &lt;-&gt; 0, 1
1 &lt;-&gt; 1, 3
0 &lt;-&gt; 2</code></pre>
<p>Calling <code>Group</code> on this input would result in <code>âŸ¨ 0 2 1 âŸ©</code>,<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> even though <code>3</code> is also part of the group!
To fix this we couldâ€¦ just run the algorithm until nothing changes?
Yes, that sounds perfectly sensible.</p>
<p>We need a helper 1-modifier <code>Fix</code>, which performs the iteration for us.<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a></p>
<pre class="bqn"><code>_Fix â† { ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½_ğ•£âˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•© }</code></pre>
<details>
<summary>
Iâ€™m sure you wanted to see another gory walkthrough by someone who has no idea what theyâ€™re talking about.
</summary>
<p>Letâ€™s first start with the simpler expression</p>
<pre class="bqn"><code>_Fix â† { ğ•Šâˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•© }</code></pre>
<p>the rest is just some icing on top.
The parse tree for this does not look so bad:</p>
<pre><code>    )explain {ğ•Šâˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•©}
{ğ•Šâˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•©}
{â”‚ â”‚ â”‚ â”‚â”‚
 ğ•Šâˆ˜âŠ¢ â”‚ â”‚â”‚
  â””â”€âŸâ‰¢ â”‚â”‚
    â””â”€âŸœğ”½â”‚
      â”œâ”€ğ•©
â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Thus, fully parenthesised and without <em>after</em>, it looks like</p>
<pre class="bqn"><code>{ ğ•©((ğ•Šâˆ˜âŠ¢)âŸâ‰¢)ğ”½ğ•© }</code></pre>
<p>at which point even a simpleton like me may guess that it will execute something like
<code>ğ•Šğ”½ğ•© if ğ•©â‰¢ğ”½ğ•© else ğ•©</code> (remember that using Boolean expression for control flow is a thing).</p>
<p>The problem with this code is, again, that BQN does not support tail recursion.
Letâ€™s now look at the real deal.</p>
<pre class="bqn"><code>_Fix â† { ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½_ğ•£âˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•© }</code></pre>
<p>Fully parenthesised this is</p>
<pre class="bqn"><code>_Fix â‡ { (((((((ğ”½âˆ˜âŠ¢)âŸâ‰¢)âŸœğ”½)_ğ•£)âˆ˜âŠ¢)âŸâ‰¢)âŸœğ”½)ğ•© }</code></pre>
<p>In particular, notice how we already understand almost all of this modifier!
The <code>ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½</code> part is the same as before, only we now donâ€™t recurse,
but build up another level of â€œapply <code>ğ”½</code>â€.
The rest sort of also works as beforeâ€”the outer <em>after</em> has the same shapeâ€”so
we are looking at</p>
<pre class="bqn"><code>_D â† {ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½} # Double F
_Fix â† {ğ•©(((ğ”½_D _ğ•£)âˆ˜âŠ¢)âŸâ‰¢)ğ”½ğ•©}</code></pre>
So if <code>ğ•©â‰¢ğ”½ğ•©</code>, we change the function <code>ğ”½</code> to essentially <code>ğ”½ğ”½</code>, and then recurse.
This happens on every iteration, so we actually go from <code>ğ”½</code> to <code>ğ”½ğ”½</code> to <code>ğ”½ğ”½ğ”½ğ”½</code>, and so on.
In short, we bring down the stack size to <span class="math inline">\log n</span> instead of <span class="math inline">n</span>.
Neat.
</details>
<p>Equipped with <code>_Fix</code>,
we can swiftly change the definition of <code>Group</code> to solve part one:</p>
<pre class="bqn"><code>Group â† {
  { vâ€¿ns ğ•Š seen: âŠ‘vâˆŠseen? â·seenâˆ¾ns; ğ•© }Â´âŸœğ•© _Fix âŸ¨0âŸ©
}
â‰ Group inp # â‡’ 380</code></pre>
<p>Because we fold over the same list every time,
we can glue it to the right side of the function using <em>after</em>.</p>
<hr />
<p>Part two tasks us with finding all of the connected components of the graph,
instead of just the one containing <code>0</code>.
For that we first need to adjust our <code>Group</code> function a little; instead of the hard-coded <code>0</code>,
letâ€™s search for the group of the first node in the given adjacency list.</p>
<pre class="bqn"><code>Group â† { # ğ•© = âŸ¨ âŸ¨0,âŸ¨2âŸ©âŸ©, âŸ¨1,âŸ¨1âŸ©âŸ©, âŸ¨2,âŸ¨0,3,4âŸ©âŸ©, â€¦ âŸ©
  { vâ€¿ns ğ•Š seen: âŠ‘vâˆŠseen? â·seenâˆ¾ns; ğ•© }Â´âŸœğ•© _Fix âŸ¨âŠ‘âŠ‘ğ•©âŸ©
}</code></pre>
<p>Now, we can successively obtain a single connected component, and delete it from the graph.
Since the graph is undirected, this just means looking for the nodes in our list.
For iteration, <code>â€¢_while_</code> can be used as before:</p>
<pre class="bqn"><code>c â† 0
{ c +âŸœ1â†© â‹„ (âŠ‘Â¨âŠ¸(Â¬âˆŠ)/âŠ£)âŸœGroup ğ•© } â€¢_while_ (âŸ¨âŸ©âŠ¸â‰¢) inp
c            # â‡’ 181</code></pre>
<p>The result of <code>Group</code> applied to <code>ğ•©</code>
is a single connected component,
so we want to throw out all of these nodes.
After that, just increment the counter and move on.
The whole thing stops when the list is emptyâ€”easy!</p>
<h3 id="day-13"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day13.bqn">Day 13</a></h3>
<p>We need to make our way across a firewall without being detected by packet scanners.
The firewall is represented by layers, each of which has a certain depth to it.
For example, given the input</p>
<pre><code>0: 3
1: 2
4: 4
6: 4</code></pre>
<p>one can visualise the firewall like this:</p>
<pre><code> 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]</code></pre>
<p>In each layer, there is a scanner starting at the top.
Every tick, it moves one layer down, bouncing off the bottom and coming up again.
We start in an imagined layer <code>Â¯1</code> at the very top.
Part one asks us to calculate how often we are <em>caught</em>â€”that is, overlap with a scanner.
Letâ€™s quickly go through the first few steps of the simulation for the above input:</p>
<pre><code>Initial state:
     0   1   2   3   4   5   6
 () [S] [S] ... ... [S] ... [S]
    [ ] [ ]         [ ]     [ ]
    [ ]             [ ]     [ ]
                    [ ]     [ ]

Tick 1 (not caught):
 0   1   2   3   4   5   6
( ) [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

Tick 2 (caught):
 0   1   2   3   4   5   6
[ ] (S) ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]</code></pre>
<p>You get the idea.
For every layer <span class="math inline">l</span> of size <span class="math inline">n</span>,
the question whether the probe is caught in step <span class="math inline">l</span> is equivalent to <span class="math inline">2(n - 1) \equiv 0 \mod l</span>,
where we need to subtract <span class="math inline">2</span> due to the bouncing off mechanic.
To get the score of a collision, multiply <span class="math inline">l</span> and <span class="math inline">n</span> together.
We can just verbatim copy this to BQN.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
inp â† (â€¢BQNÂ¨':'âŠ¸Split)Â¨ â€¢FLines &quot;../inputs/day13.txt&quot;
+Â´{lâ€¿n: lÃ—nÃ—0=l|Ëœ2Ã—n-1}Â¨inp # â‡’ 1316</code></pre>
<hr />
<p>Part two wants us to not get caught;
however, the only thing we can control is our starting time.
This would be a pretty cool problem if it were not brute forcable.
Alas, it is.</p>
<pre class="bqn"><code>+âŸœ1 â€¢_while_ {ğ•Šd: âŠ‘0âˆŠ{lâ€¿n: (l+d)|Ëœ2Ã—n-1}Â¨inp} 0 # â‡’ 3840052</code></pre>
<p>The algorithm is the same as above,
only that we now have an additional delay to factor into the equation.
We iterate until we find a delay <code>d</code> such that <code>0</code> is not a member of <code>{lâ€¿n: (l+d)|Ëœ2Ã—n-1}Â¨inp</code>;
i.e., such that we are not caught by any sensor.</p>
<h3 id="day-14"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day14.bqn">Day 14</a></h3>
<p>Today we are asked to defragment a disk,
represented by a 128Ã—128 grid,
with each square being either used or free.
Itâ€™s built like this:
given our input, e.g., <code>"abc"</code>,
create strings <code>"abc-0"</code> through <code>"abc-127"</code>.
For each of them, run the knot hash function from <a href="#day-10">day 10</a>,
convert every single hex
<a href="https://en.wikipedia.org/wiki/Nibble">nibble</a>
to its 4-digit binary representationâ€”e.g., for <code>"0f"</code> we would get <code>"00001111"</code>â€”<!--
-->and merge things together into a big 128Ã—128 matrix.
The finished grid might look a little bit like this:</p>
<pre><code>##.#.#..--&gt;
.#.#.#.#
....#.#.
#.#.##.#
.##.#...
##..#..#
.#...#..
##.#.##.--&gt;
|      |
V      V</code></pre>
<p>To get the grid representation, we first need to rewrite our solution for day 10,
and export a function to compute the knot hash of the given argument.</p>
<pre class="bqn"><code>KnotHash â‡ {
  ls â† âŒ½ âŸ¨17, 31, 73, 47, 23âŸ©âˆ¾Ëœ ğ•©-@
  âˆ¾ DecToHexâˆ˜XÂ¨ 16(/â¥ŠËœ)âŠ¸âŠ” âŠ‘ RÂ´âŸœlsâŸ64 (â†•256)â€¿0â€¿0
}
â€¢Show KnotHash inp2 # â‡’ &quot;2da93395f1a6bb3472203252e3b17fe5&quot;</code></pre>
<p>Nothing too unusual here,
only that exporting from a namespace works by binding with <em>export</em>
(<a href="https://mlochbaum.github.io/BQN/doc/namespace.html"><code>â‡</code></a>)
instead of <em>define</em>.
We can now import this function as we did for ones in the utility file,<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a></p>
<pre class="bqn"><code>âŸ¨Split,_FixâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
âŸ¨KnotHashâŸ© â† â€¢Import &quot;./day10.bqn&quot;</code></pre>
<p>and translate the recipe above into BQN code.</p>
<pre class="bqn"><code>grid â† {
  HexToBin â† {  ğ•Šp: pğ•ŠâŸ¨âŸ©;              # Start
               0ğ•Šr: rÂ«4â¥Š0;             # End: pad with zeros
               pğ•Šr: (âŒŠpÃ·2)ğ•Š(râˆ¾Ëœ2|p)    # Conversion
             }Â¨âˆ˜(&quot;0123456789abcdef&quot;âŠ¸âŠ) # Convert hex to decimal, then to binary
  Start â† (âŠ‘â€¢FLines&quot;../inputs/day14.txt&quot;)âˆ¾&quot;-&quot;âˆ¾â€¢Fmt
  Row â† âˆ¾âˆ˜HexToBinâˆ˜KnotHash
  &gt;Rowâˆ˜StartÂ¨â†•128
}</code></pre>
<p>Not too many new things here.
<code>HexToBin</code> essentially runs on the same logic as a more verbose version of <code>DecToHex</code> from day 10,<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>
and the <code>â€¢Fmt</code> function just pretty-prints the given value to a string.
This is, however, the first time that we see an ambivalent function definition<!--
-->â€”one that can be called both monadically and dyadically.
The monadic case is used in lieu of an internal worker function,
like what Haskell people often call <code>go</code>.
This could have also been achieved with a construct like <code>{â€¦}âŸœâŸ¨âŸ©Â¨â€¦</code>, but I feel like that wouldnâ€™t read as nicely.</p>
<p>Part one just asks us how many cells are alive:</p>
<pre class="bqn"><code>+Â´â¥Šgrid # â‡’ 8222</code></pre>
<p>We need to convert the matrix into a vector first, because <em>fold</em> only works on vectors.
Alternatively, we could have also summed up all major cells separately with <em>insert</em>
(<a href="https://mlochbaum.github.io/BQN/doc/fold.html"><code>Ë</code></a>),
and then summed up the resulting vector.</p>
<pre class="bqn"><code>+Â´+Ëgrid # â‡’ 8222</code></pre>
<hr />
<p>Part two is more interesting, and is probably among the top three parts for me in terms of fun.
Instead of simply counting the number of alive cells, we now need to find the number of distinct <em>regions</em>â€”<!--
-->live cells adjacent to each other in any of the four cardinal directions.
For example, the grid shown above would have the following regions<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a></p>
<pre><code>11.2.3..--&gt;
.1.2.3.4
....5.6.
7.8.55.9
.88.5...
88..5..8
.8...8..
88.8.88.--&gt;
|      |
V      V</code></pre>
<p>So, what do we do?
This question reminds me a little bit of a game of lifeâ€“type situation,
only that we donâ€™t have to evolve the grid.
Starting with</p>
<pre class="bqn"><code>    m â† 3â€¿3â¥Š0â€¿0â€¿1â€¿1â€¿1â€¿0â€¿1â€¿0â€¿0
â”Œâ”€
â•µ 0 0 1
  1 1 0
  1 0 0
        â”˜</code></pre>
<p>the first step is to associate a unique number with each <code>1</code> in the grid.
One way of doing this is to <em>deshape</em> the array into a vector, and then take a +-<em>scan</em> of it.
This will only increase when another <code>1</code> is encountered:</p>
<pre class="bqn"><code>    +`â¥Šm
âŸ¨ 0 0 1 2 3 3 4 4 4 âŸ©
   3â€¿3â¥Š+`â¥Šm
â”Œâ”€
â•µ 0 0 1
  2 3 3
  4 4 4
        â”˜</code></pre>
<p>If we now multiply with the original matrix,
all of the zeros will kill the redundant numbers in that representation.</p>
<pre class="bqn"><code>    um â† mÃ—3â€¿3â¥Š+`â¥Šm
â”Œâ”€
â•µ 0 0 1
  2 3 0
  4 0 0
        â”˜</code></pre>
<p>Packing this up into its own function,
a clever user of <em>under</em> takes care of all of the de- and reshaping for us.</p>
<pre class="bqn"><code>+`âŠ¸Ã—âŒ¾â¥Š</code></pre>
<p>Now, the idea is to proceed in the following way:
take the maximum of every cell with its four neighbours<!--
-->â€”to get group the cell should belong to if itâ€™s aliveâ€”<!--
-->and then multiply by the original value of the cell, to again make sure we only care about live cells.
Now, because BQN is an array language, we can do all of this for the whole array at the same time!
We can use <em>nudge</em> in either direction to get the North and South neighbour (remember that first axis stuff?),
and <em>nudge</em> <em>cells</em> to get the East and West one:</p>
<pre class="bqn"><code>    m â† 3â€¿3â¥Š1
â”Œâ”€
â•µ 1 1 1
  1 1 1
  1 1 1
        â”˜
   âŸ¨Â«,Â»,Â«Ë˜,Â»Ë˜âŸ©{ğ•ğ•©}Â¨&lt;m
â”Œâ”€
Â· â”Œâ”€        â”Œâ”€        â”Œâ”€        â”Œâ”€
  â•µ 1 1 1   â•µ 0 0 0   â•µ 1 1 0   â•µ 0 1 1
    1 1 1     1 1 1     1 1 0     0 1 1
    0 0 0     1 1 1     1 1 0     0 1 1
          â”˜         â”˜         â”˜         â”˜
                                          â”˜</code></pre>
<p>There are a few things going on here.
First, we use BQNâ€™s
<a href="https://mlochbaum.github.io/BQN/doc/functional.html">functional programming capabilities</a>,
which work just about as one would expect.<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a>
Second, we need to <em>enclose</em> <code>m</code> and make it a
<a href="https://mlochbaum.github.io/BQN/doc/enclose.html">unit array</a>,
as otherwise <em>each</em> is trying to match up the major cells of <code>m</code> with the elements of our vector (the functions).
We donâ€™t want that, and making <code>m</code> a unit will correctly â€œduplicateâ€ it to each function instead.
Finally, <em>nudge</em> correctly inserts the fill elements for the edge cases;
our grid is only 128Ã—128 and we are not on a torus.<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a></p>
<p>Now, we can just compare every neighbour with the original value,
and kick out the zeros.
Using our <code>um</code> array from above:</p>
<pre class="bqn"><code>    (Ã—um)Ã—âŒˆÂ´âŸ¨Â«,Â»,Â«Ë˜,Â»Ë˜,âŠ¢âŸ©{ğ•ğ•©}Â¨&lt;um
â”Œâ”€
â•µ 0 0 1
  4 3 0
  4 0 0
        â”˜</code></pre>
<p>For kicking out the zeros we have to use
<em>signum</em> (<a href="https://mlochbaum.github.io/BQN/doc/arithmetic.html"><code>Ã—</code></a>),
so as to not falsify the group.
Now, you may notice that this process hasnâ€™t converged yet; <code>3</code> is in the same group as <code>4</code>,
but there wasnâ€™t enough time for it to be swallowed up yet.
But we have a <code>_Fix</code> for that, donâ€™t we?</p>
<pre class="bqn"><code>    { (Ã—ğ•©)Ã—âŒˆÂ´âŸ¨Â«,Â»,Â«Ë˜,Â»Ë˜,âŠ¢âŸ©{ğ•ğ•©}Â¨&lt;ğ•© }_Fix um
â”Œâ”€
â•µ 0 0 1
  4 4 0
  4 0 0
        â”˜</code></pre>
<p>To get the number of regions,
we just have to pull everything together<!--
-->â€”and remember to subtract one, for <code>0</code>â€™s region.</p>
<pre class="bqn"><code>{ ğ•Šg:
  g (+`âŠ¸Ã—âŒ¾â¥Š)â†©
  g {(Ã—ğ•©)Ã—âŒˆÂ´âŸ¨Â»Ë˜,Â«Ë˜,Â»,Â«,âŠ¢âŸ©{ğ•ğ•©}Â¨&lt;ğ•©}_Fixâ†©
  1-Ëœ+Â´âˆŠâ¥Šg # Count all unique numbers minus 0
} grid     # â‡’ 1086</code></pre>
<h3 id="day-15"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day15.bqn">Day 15</a></h3>
<p>For day 15 we have to help a pair of duelling generators decide which of them is malfunctioning.
Each generator produces a value in the following way:
take the previous value, multiply it by <code>16807</code> (generator A) or <code>48271</code> (generator B),
and then keep the remainder of dividing the resulting product by <code>2147483647</code>.<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>
Our puzzle input comprises the initial seeds whence this process starts.
The task for part one is to check whether the lowest 16 bits of both of these numbers match up,
and count the number of times this happens after 40 million pairs.</p>
<p>Parsing is simple.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
aâ€¿b â† â€¢ParseFloatâˆ˜(Â¯1âŠ¸âŠ‘)âˆ˜(' 'âŠ¸Split)Â¨ â€¢FLines &quot;../inputs/day15.txt&quot;</code></pre>
<p>The rest is similarly straightforward.
One could drop down to bit-wise operations again,
but the lowest 16 bits of <span class="math inline">x</span> and <span class="math inline">y</span> matching up is equivalent to <span class="math inline">x \equiv y \mod 2^{16}</span>;
letâ€™s do that instead.</p>
<pre class="bqn"><code>S â† { ğ•Šaâ€¿bâ€¿n:
  na â† 2147483647|aÃ—16807
  nb â† 2147483647|bÃ—48271
  nn â† na =â—‹(65536âŠ¸|) nb
  âŸ¨na,nb,n+nnâŸ©
}
SâŸ40e6 aâ€¿bâ€¿0 # â‡’ 631</code></pre>
<p>We use <em>over</em>
(<a href="https://mlochbaum.github.io/BQN/doc/compose.html"><code>â—‹</code></a>)
to apply this transformation to the two arguments,
and then check for equality (i.e., <code>ğ•¨ğ”½â—‹ğ”¾ğ•©</code> is <code>(ğ”¾ğ•¨)ğ”½(ğ”¾ğ•©)</code>).</p>
<hr />
<p>Part two asks us to change up the algorithm, so that generator A only considers multiples of 4,
and generator B only cares about multiples of 8.
That is, both generators independently generate numbers until these conditions are met,
and only then are these numbers compared.
We also only have to check 5 million pairs, instead of the 40 million of part one.
First and foremost, this means that we have to decouple the comparison aspect from the generation of the numbers.</p>
<pre class="bqn"><code>Gen â† { fac ğ•Š n:
  res â† âŸ¨âŸ©
  {resâˆ¾â†©2147483647|(Â¯1âŠ‘â¥Šğ•©)Ã—fac}âŸ40e6 n
  res 65536âŠ¸|â†©
}
as â† 16807 Gen a
bs â† 48271 Gen b</code></pre>
<p>The calculations are the same as in part one, only now we use <em>change</em> to build a list that we can return.
Luckily, simply generating 40 million pairs as above and filtering for the right properties works out for us here.</p>
<pre class="bqn"><code>F â† 5e6â†‘(0âŠ¸=|)/âŠ¢
+Â´(8 F bs)=(4 F as) # â‡’ 279</code></pre>
<h2 id="days-1620">Days 16â€“20</h2>
<h3 id="day-16"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day16.bqn">Day 16</a></h3>
<p>This day involves analysing the dance of a few programs.
Part one is about mutating a small vectorâ€”characters <code>'a'</code> through <code>'p'</code>â€”according to the puzzle input,
which is a single line that looks a bit like this:</p>
<pre><code>s11,x10/2,pl/d,â€¦</code></pre>
<p>The valid moves are:</p>
<ul>
<li><code>sA</code> rotates the vector <code>A</code> positions to the right.</li>
<li><code>xA/B</code> exchanges the positions <code>A</code> and <code>B</code>.</li>
<li><code>pA/B</code> exchanges the characters <code>A</code> and <code>B</code>.</li>
</ul>
<p>So starting with just <code>abcd</code>, the sequence <code>s1,x3/4,pe/b</code> would go</p>
<pre><code>abcd  â†’  eabcd  â†’  eabdc  â†’  baedc</code></pre>
<p>Parsing the moves is not terribly complicated.
The cool thing is that we can use BQNâ€™s functional programming facilities again
and immediately translate the instructions above into functions to be applied!</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
P â† {
  aâ€¿&quot;s&quot;: (-â€¢ParseFloat a)âŠ¸âŒ½;                # sA
  aâ€¿&quot;x&quot;: âŒ½âŒ¾((â€¢ParseFloatÂ¨'/'Split a)âŠ¸âŠ);    # xA/B
  aâ€¿&quot;p&quot;: { ğ•Šxs: âŒ½âŒ¾((xsâŠâˆ¾'/'Split a)âŠ¸âŠ) xs } # pA/B
}
inp â† âŒ½ Pâˆ˜(1âŠ¸(â†“â‹ˆâ†‘))Â¨ ','Split âŠ‘â€¢FLines&quot;../inputs/day16.txt&quot;
# Reverse because we want to fold over the list later.</code></pre>
<p>Since the format of the instructions is so predictable,
we can just match on the first character and decide where to go from there.
Also, the <code>1(â†“â‹ˆâ†‘)</code> idiom returns as a useful tool yet again.
Do note the <code>xsâŠâˆ¾â€¦</code> in the third line; we want to get the indices of the <em>characters</em>
in the string, and not the indices of a substring of length one; compare:</p>
<pre class="bqn"><code>    '/'Split&quot;a/b&quot;
âŸ¨ &quot;a&quot; &quot;b&quot; âŸ©
    âˆ¾'/'Split&quot;a/b&quot;
&quot;ab&quot;
    &quot;abcde&quot;âŠ'/'Split&quot;a/b&quot; # âŠ returns â‰ ğ•¨ if it can't find ğ•© in ğ•¨
âŸ¨ 5 5 âŸ©
    &quot;abcde&quot;âŠâˆ¾'/'Split&quot;a/b&quot;
âŸ¨ 0 1 âŸ©</code></pre>
<p>With all of that in place,
we can successively apply all the functions to the seed value <code>abcdefghijklmnop</code>.</p>
<pre class="bqn"><code>('a'+â†•16){ğ•ğ•©}Â´inp # â‡’ &quot;eojfmbpkldghncia&quot;</code></pre>
<hr />
<p>Part two asks us to keep the result of part one, <code>"eojfmbpkldghncia"</code>,
and repeat the whole dance one billion times.
Now, that number is obviously much too large to simulate the whole thing.
Instead, letâ€™s try to find a loop.</p>
<pre class="bqn"><code>h  â† âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
d  â† {ğ•ğ•©}Â´âŸœinpâ€¢_while_{ (ğ•©h.Set@) âŠ¢ Â¬h.Hasğ•© } ('a'+â†•16) # dup
di â† âŠ‘(h.Keys@)âŠ&lt;d                                      # dup index
{ğ•ğ•©}Â´âŸœinpâŸ(di+(h.Count@)|10e9-di) d # â‡’ &quot;iecopnahgdflmkjb&quot;</code></pre>
<p>I used a hash map here since I figured the loop was still going to be substantial
(it wasnâ€™tâ€”oh well).
The test function supplied to while <code>â€¢_while_</code> (ab)uses the fact that,
while <code>âŠ¢</code> only ever returns <code>ğ•©</code>,
it actually evaluates both of its arguments.
Remember that evaluation happens right-to-left, though;
<code>(Â¬h.Hasğ•©) âŠ£ ğ•©h.Set@</code> wouldnâ€™t work!</p>
<p>At the end, the loop returns the first duplicate it found,
so all thatâ€™s left to do is to simulate that many steps upfront,
and then whatever we have left over.<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a>
The little <code>@</code>â€™s after the function calls to <code>h.Count</code> and <code>h.Keys</code>
(but not to <code>h.Set</code>, as we need to associate some kind of value to the keysâ€”that value just happens to be the null character)
function as dummy arguments.
To return something,
the upper case (function) variants need to be called,
but the argument is actually ignored.
This is a bit ugly, but sort of how BQNâ€™s â€œobject systemâ€<!--
-->â€”which really rather seems like an accident of having a module system and syntactic rolesâ€”<!--
-->works.</p>
<h3 id="day-17"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day17.bqn">Day 17</a></h3>
<p>Today we have to escape a deadly spinlock!
To do that, we have to simulate a circular buffer with the following rules:</p>
<blockquote>
<p>[The spinlock] starts with a circular buffer containing only the value 0, which it marks as the current position.
It then steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on.
The inserted value becomes the current position.
Then, it steps forward from there the same number of steps, and wherever it stops, inserts after it the second new value, 2, and uses that as the new current position again.</p>
</blockquote>
<p>All in all, we have to insert the numbers 0 to 2017 in this way.
For example, suppose our puzzle input was <code>3</code>.
Using <code>()</code> to indicate the current position, the list would grow thusly:</p>
<pre><code>(0)  â†’  0 (1)  â†’  0 (2) 1  â†’  0 2 (3) 1  â†’  â€¦</code></pre>
<p>Part one asks us for the value after 2017 in the final buffer.</p>
<p>With a puzzle input of <span class="math inline">n</span> and a position <span class="math inline">p</span> in step <span class="math inline">i</span>,
the stepping forward process is just <span class="math inline">1 + (p + n \mod i)</span><!--
-->â€”the list is exactly of length <span class="math inline">i</span> in that stepâ€”<!--
-->and inserting after the element means adding one.
As such, a straightforward solution for part one looks like this:</p>
<pre class="bqn"><code>n â† â€¢ParseFloatâŠ‘â€¢FLines&quot;../inputs/day17.txt&quot;
((1+âŠ‘)âŠâŸœ2017)âŠ¸âŠ‘ Â¯1âŠ‘ { ğ•Šiâ€¿pâ€¿b:         # index, position, buffer
  npâ†1+i|p+n â‹„ âŸ¨i+1,np,(npâ†‘b)âˆ¾iâˆ¾npâ†“bâŸ©
}âŸ2017 1â€¿0â€¿âŸ¨0âŸ©                        # â‡’ 1487</code></pre>
<p>However, this feel immensely unsatisfactory to me.
Repeatedly breaking apart an array and assembling it again (<code>(npâ†‘b)âˆ¾iâˆ¾npâ†“b</code>) sort of signals that something must be amiss.
Instead, it would be much better to not have to care about the position at all,
always insert the element at the front, and rotate the array instead.
After entirely too much thinking, something pops up.
Say we only looked at the small example above of going from <code>(0)</code> to <code>0 2 (3) 1</code>.
Again starting with <code>âŸ¨0âŸ©</code>,
we can do the following:</p>
<pre class="bqn"><code>    Rot â† { xsğ•Ši: iâˆ¾(3+1)âŒ½xs }
(function block)
    âŸ¨0âŸ© Rot 1
âŸ¨ 1 0 âŸ©
    (âŸ¨0âŸ© Rot 1) Rot 2
âŸ¨ 2 1 0 âŸ©
    ((âŸ¨0âŸ© Rot 1) Rot 2) Rot 3
âŸ¨ 3 1 0 2 âŸ©</code></pre>
<p>The final result, <code>3 1 0 2</code> is indeedâ€”up to circular permutationâ€”the same as <code>0 2 3 1</code>!
The <code>3+1</code> comprises the step size <code>3</code>, and keeps track of the fact that we need to insert the value after the index.
Even more, the final inserted value will be the head of the vector,
so getting the element at index <code>1</code> is what we wantâ€”no more <em>select</em>ing stuff.
Do note that walking to the <em>right</em> in terms of indices translates to rotating the buffer to the <em>left</em> (i.e., using positive numbers).
We can pack this function up in a fold, yielding an alternative solution for part one:<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a></p>
<pre class="bqn"><code>1âŠ‘âŸ¨0âŸ©{ğ•¨âˆ¾(n+1)âŒ½ğ•©}Â´âŒ½1+â†•2017 # â‡’ 1487</code></pre>
<hr />
<p>Part two now wants us to identify the value following <code>0</code>â€”after fifty million iterations!
This is much too big to simulate in the same way as the first part.
Instead, we can come back to the formula <span class="math inline">1 + (p + n \mod i)</span>
that predicts the index at which a given number is going to be inserted.
We can use a <em>scan</em> over the vector to get that index for each insertion.
Since the steps are increasing, the solution looks for the last time a <code>1</code> was inserted.</p>
<pre class="bqn"><code>âŠ‘ (â‰ -âŠâŸœ1âˆ˜âŒ½) 0{1+ğ•©|n+ğ•¨}`1+â†•50e6 # â‡’ 25674054</code></pre>
<details>
<summary>
This is the first time that we use a non-associative scan, so a few words of warning.
</summary>
<p>While <em>fold</em> is consuming its input array in the same direction as BQNâ€™s evaluation modelâ€”right-to-leftâ€”<em>scan</em> is evaluating its argument left-to-right!</p>
<pre class="bqn"><code>    âŸ¨10, 10-15, (10-15)-9âŸ© â‰¡ -`âŸ¨10,15,9âŸ©
1
    âŸ¨10, 10-15, 10-15-9âŸ©   â‰¡ -`âŸ¨10,15,9âŸ©
0</code></pre>
<p>As such, the default argument in a scan is given as the initial <em>left</em> argument,
instead of the initial right one as in a fold:</p>
<pre class="bqn"><code>    âŸ¨20-10, (20-10)-15, ((20-10)-15)-9âŸ© â‰¡ 20-`âŸ¨10,15,9âŸ©
1
    (10-(15-(9-20))) = 20-Â´âŸ¨10,15,9âŸ©
1</code></pre>
<p>The reason this is done is more of a pragmatic one,
from what I can tell:
left scans are simply more common than right ones.</p>
One may argue the same for left over right folds, actually,
but I suppose the Ã¦sthetics of having <code>20-Â´âŸ¨10,15,9âŸ©</code> be <code>10-15-9-20</code> won out there.
</details>
<p>Other than that, the train <code>â‰ -âŠâŸœ1âˆ˜âŒ½</code> computes the first occurrence of <code>1</code> in the reversed vector,
and then corrects the index by subtracting it from the length of the vector.</p>
<h3 id="day-18"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day18.bqn">Day 18</a></h3>
<p>Today we have to simulate some assembly in order to play music!
The computer has 16 registers, all starting at 0,
with the instructions being as follows:</p>
<blockquote>
<ul>
<li><code>snd X</code> plays a sound with a frequency equal to the value of <code>X</code>.</li>
<li><code>set X Y</code> sets register <code>X</code> to the value of <code>Y</code>.</li>
<li><code>add X Y</code> increases register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mul X Y</code> sets register <code>X</code> to the result of multiplying the value contained in register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mod X Y</code> sets register <code>X</code> to the remainder of dividing the value contained in register <code>X</code> by the value of <code>Y</code> (that is, it sets <code>X</code> to the result of <code>X</code> modulo <code>Y</code>).</li>
<li><code>rcv X</code> recovers the frequency of the last sound played, but only when the value of <code>X</code> is not zero. (If it is zero, the command does nothing.)</li>
<li><code>jgz X Y</code> jumps with an offset of the value of <code>Y</code>, but only if the value of <code>X</code> is greater than zero. (An offset of <code>2</code> skips the next instruction, an offset of <code>-1</code> jumps to the previous instruction, and so on.)</li>
</ul>
</blockquote>
<p>Our input consists of one instruction on each line; for example:</p>
<pre><code>set a 1
add a 2
mul a a
mod a 5
â€¦</code></pre>
<p>Part one asks us what value is recovered the first time an <code>rcv</code> instruction is actually executed
(i.e., called with a non-zero argument).
Letâ€™s first to some parsing.</p>
<pre class="bqn"><code>âŸ¨SplitâŸ©â†â€¢Import&quot;../../util/bqn_util/util.bqn&quot;
inp â† â€¢ParseFloatâŠâŠ¢Â¨âˆ˜(' 'âŠ¸Split)Â¨â€¢FLines &quot;../inputs/day18.txt&quot;</code></pre>
<p>Note the <code>â€¢ParseFloatâŠâŠ¢</code>.
Weâ€™ve used <em>catch</em> before on <a href="#day-7">day 7</a>, but for a different reason.
Here, we use it as a shorthand to parse a number if possible, and return the argument as-is otherwise.</p>
<pre class="bqn"><code>    â€¢ParseFloatâŠâŠ¢Â¨ ' 'Split&quot;set a 102&quot;
âŸ¨ &quot;set&quot; &quot;a&quot; 102 âŸ©</code></pre>
<p>Simulating an instruction is easyâ€”if verboseâ€”for the most part;
the only slight challenge is that we have instructions along the lines of <code>mul a 2</code>, as well as <code>mul a a</code>;
in the latter case, we first need to get the current value out of register <code>a</code> before execution.
An easy way to do this is to match on the
<a href="https://mlochbaum.github.io/BQN/spec/system.html#operation-properties"><code>â€¢Type</code></a>
of the argument.
The function returns <code>1</code> for integers,
in which case we just take the value;
otherwise, we can look it up as a register.</p>
<pre class="bqn"><code>V â† { 1=â€¢Type ğ•©? ğ•©; (âŠ‘ğ•©-&quot;a&quot;)âŠ‘ğ•¨ } # [V]alue, ğ•¨=arr, ğ•©=el</code></pre>
<p>The registers <code>aâ€¦p</code> are translated into indices <code>0â€¦15</code> in the usual way.
All thatâ€™s left to do is to write a change modifier.
It takes the vector of registers, a function <code>F</code>, and an <code>xâ€¿y</code> pair,
and changes <code>x</code> to <code>x F y</code>.
<em>Under</em> is quite nice for these sorts of things.</p>
<pre class="bqn"><code>_C â† { regs F _ğ•£ xâ€¿y: FâŸœ(regs V y)âŒ¾((âŠ‘x-&quot;a&quot;)âŠ¸âŠ‘) regs } # [C]hange</code></pre>
<p>Finally, here is the rest of the simulation.</p>
<pre class="bqn"><code>snd â† 0
SD â† { ğ•ŠâŸ¨ix,regs,insâ€¿xâ€¿yâŸ©:
  { ğ•Š&quot;set&quot;: âŸ¨ix+1, regs  âŠ¢_C xâ€¿yâŸ©;
    ğ•Š&quot;add&quot;: âŸ¨ix+1, regs  +_C xâ€¿yâŸ©;
    ğ•Š&quot;mul&quot;: âŸ¨ix+1, regs  Ã—_C xâ€¿yâŸ©;
    ğ•Š&quot;mod&quot;: âŸ¨ix+1, regs |Ëœ_C xâ€¿yâŸ©;
    ğ•Š&quot;jgz&quot;: 0&lt;regs V x? âŸ¨ix+regs V y, regsâŸ©;
    ğ•Š&quot;jgz&quot;: âŸ¨ix+1, regsâŸ©
  } ins
}
One â† {
  ğ•ŠâŸ¨ix,regs,insâ€¿xâŸ©:
    { ğ•Š&quot;snd&quot;: sndâ†©regs V x â‹„ âŸ¨ix+1, regsâŸ©;
      ğ•Š&quot;rcv&quot;: snd!0=regs V x â‹„ âŸ¨ix+1, regsâŸ©
    } ins;
  SD ğ•©
}</code></pre>
<p>Quite a lot of code!<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a>
However, nothing very interesting happening here;
we use <em>assert</em> (<code>!</code>) in the same way as in <a href="#day-7">day 7</a>,
only that we now have a genuine condition to test.
Recall that <code>ğ•¨!ğ•©</code> checks whether <code>ğ•©</code> is 1.
If it is, nothing happens;
if itâ€™s not, an exception with value <code>ğ•¨</code> is thrown.
We use it here so that we immediately exit upon receiving<a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> our first recovery signal.
As in any other â€œsimulate indexing into this arrayâ€â€“type situations,
<code>â€¢_while_</code> is used for iteration,
only this time we have to wrap the whole thing inside of <em>catch</em>.</p>
<pre class="bqn"><code>{ ğ•Šiâ€¿r: OneâŸ¨i,r,iâŠ‘inpâŸ©
}â€¢_while_{
  ğ•Šiâ€¿Â·: (iâ‰¥0)âˆ§i&lt;â‰ inp
}âŠâ€¢CurrentError âŸ¨0,16â¥Š0âŸ© # â‡’ 9423</code></pre>
<hr />
<p>Part two informs us that we actually completely misunderstood the instructions.
In reality, the assembly is about simulating a concurrent system comprising of program <code>0</code> and program <code>1</code>.
The simulations run completely separately,
save for the â€œsendâ€ and â€œreceiveâ€â€”instead of â€œsoundâ€ and â€œrecoverâ€â€”instructions they use to communicate:</p>
<blockquote>
<ul>
<li>snd X sends the value of X to the other program. These values wait in a queue until that program is ready to receive them. Each program has its own message queue, so a program can never receive a message it sent.</li>
<li>rcv X receives the next value and stores it in register X. If no values are in the queue, the program waits for a value to be sent to it. Programs do not continue to the next instruction until they have received a value. Values are received in the order they are sent.</li>
</ul>
</blockquote>
<p>Further, program <code>1</code> starts with a <code>1</code> in its last register.
Our task is to simulate both programs until they deadlock<!--
-->â€”both are stuck on <code>rcv</code> calls but both send queues are emptyâ€”<!--
-->and count the number of times program <code>1</code> pushed something to program <code>0</code>â€™s queue.</p>
<p>Are you ready to simulate concurrency in an array language?
I wasnâ€™t.
Anyways, my idea was to run both programs in lockstep, with two lists of additional state that we have to keep track of.
This is only important for <code>snd</code> and <code>rcv</code>â€”the other instructions donâ€™t have to change.</p>
<pre class="bqn"><code>Two â† { # my queue, other queue, index, registers, instruction
  # Push to other queue.
  ğ•ŠâŸ¨my,ot,ix,rs,&quot;snd&quot;â€¿xâŸ©: otâˆ¾â†©rs V x â‹„ âŸ¨my, ot, ix+1, rsâŸ©;
  # Don't advance on empty queue.
  ğ•ŠâŸ¨âŸ¨âŸ©,ot,ix,rs,&quot;rcv&quot;â€¿xâŸ©: âŸ¨âŸ¨âŸ©,ot,ix,rsâŸ©;
  # Pop from my queue.
  ğ•ŠâŸ¨my,ot,ix,rs,&quot;rcv&quot;â€¿xâŸ©: qâ€¿qs â† 1(â†‘â‹ˆâ†“)my â‹„ âŸ¨qs, ot, ix+1, rsâŠ¢_CâŸ¨x,âŠ‘qâŸ©âŸ©;
  ğ•ŠâŸ¨my,ot,ix,rs,insâŸ©    : âŸ¨my,otâŸ©âˆ¾SDâŸ¨ix,rs,insâŸ©
}</code></pre>
<p>Now all we have to do is take a deep breath and write the following code.</p>
<pre class="bqn"><code># Concurrency at home:
âŠ‘{ ğ•Šs1â€¿q0â€¿q1â€¿i1â€¿r1â€¿i2â€¿r2â€¿xs:
  âŸ¨q0,q1,i1,r1âŸ© â†© TwoâŸ¨q0,q1,i1,r1,i1âŠ‘xsâŸ©
  old0 â† â‰ q0
  âŸ¨q1,q0,i2,r2âŸ© â†© TwoâŸ¨q1,q0,i2,r2,i2âŠ‘xsâŸ© # q0 and q1 swap here
  âŸ¨s1+old0&lt;â‰ q0,q0,q1,i1,r1,i2,r2,xsâŸ©
}â€¢_while_{ ğ•ŠÂ·â€¿q0â€¿q1â€¿i1â€¿Â·â€¿i2â€¿Â·â€¿xs:
  âˆ¨Â´âŸ¨ q0â‰¢âŸ¨âŸ©, q1â‰¢âŸ¨âŸ©, &quot;rcv&quot;â‰¢âŠ‘i1âŠ‘xs, &quot;rcv&quot;â‰¢âŠ‘i2âŠ‘xs âŸ©
} âŸ¨0, âŸ¨âŸ©,âŸ¨âŸ©, 0,(15â¥Š0)âˆ¾0, 0,(15â¥Š0)âˆ¾1, inpâŸ© # â‡’ 7620</code></pre>
<p><code>s1</code> keeps track of how many times program <code>1</code> sent a signal;
the two <code>q</code>â€™s are the queues; and
the two <code>i</code>â€™s and <code>r</code>â€™s correspond to the respective indices and registers.
We simulate the whole thing until a deadlock occurs as per the above considerations.
Technically, I guess, both programs could also run to completion,
so there would have to be some extra index shenanigans in the check,
but this doesnâ€™t happen for my input so Iâ€™m going to pretend it never does.</p>
<h3 id="day-19"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day19.bqn">Day 19</a></h3>
<p>For day 19 we have to help a network packet traverse a routing diagram.
The diagram we get is pretty self-explanatory; an example
(the real path is much more complicated)
looks like this:</p>
<pre><code>     |
     |  +--+
     A  |  C
 F---|----E|--+
     |  |  |  D
     +B-+  +--+</code></pre>
<p>The question lets us know that there will be a unique line connected to the top,
which is our starting point.
This in particular means that we will start out going down.
Letters are simply passed through, and the path we can take is always unique;
we only change directions when absolutely necessary.</p>
<p>Part one asks what letters we see in order.
This is a straightforward simulation, so letâ€™s get to it;
first, parsing and massaging the input:</p>
<pre class="bqn"><code>âŸ¨SplitâŸ©â†â€¢Import&quot;../../util/bqn_util/util.bqn&quot;
inp â† âŒ½â‰âˆ˜({(' 'â¥ŠËœâ‰ ğ•©)âˆ¾âŒ½â‰ğ•©}âŸ3) &gt;â€¢FLines&quot;../inputs/day19.txt&quot;</code></pre>
<p>We pad the input matrix with spaces on the right, bottom, and left, in order to make changing directions easier.
This way, we only have to check if the next cell is a space character;
since we never move into that space, we donâ€™t have to special case indexing around the edges of the array.</p>
<details>
<summary>
The <code>âŒ½â‰</code> bit is a neat trick to compute all rotations of a matrix.
</summary>
<p>When padding the input,
we essentially want to rotate the matrix by 90 degrees three times,
and add spaces afterwards.
It is well known that every rotation is merely the product of two reflections,
like
<em>reverse</em> (<a href="https://mlochbaum.github.io/BQN/doc/reverse.html#reverse"><code>âŒ½</code></a>) and
<em>transpose</em> (<a href="https://mlochbaum.github.io/BQN/doc/transpose.html"><code>â‰</code></a>).</p>
<pre class="bqn"><code>    m â† 3â€¿3â¥Šâ†•9
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
        â”˜
    â‰m
â”Œâ”€
â•µ 0 3 6
  1 4 7
  2 5 8
        â”˜
    âŒ½m
â”Œâ”€
â•µ 6 7 8
  3 4 5
  0 1 2
        â”˜</code></pre>
<p>Depending on whether we rotate or transpose first,
we turn either right or left.</p>
<pre class="bqn"><code>    m
â”Œâ”€
â•µ 0 1 2
  3 4 5
  6 7 8
        â”˜
    âŒ½â‰ m
â”Œâ”€
â•µ 2 5 8
  1 4 7
  0 3 6
        â”˜
    â‰âŒ½ m
â”Œâ”€
â•µ 6 3 0
  7 4 1
  8 5 2
        â”˜</code></pre>
<p>Doing this four times gives us every rotation of the matrix:</p>
<pre class="bqn"><code>    (â‰âŒ½)âŸ(â†•4) m
â”Œâ”€
Â· â”Œâ”€        â”Œâ”€        â”Œâ”€        â”Œâ”€
  â•µ 0 1 2   â•µ 6 3 0   â•µ 8 7 6   â•µ 2 5 8
    3 4 5     7 4 1     5 4 3     1 4 7
    6 7 8     8 5 2     2 1 0     0 3 6
          â”˜         â”˜         â”˜         â”˜
                                          â”˜</code></pre>
<p>Padding all of the sides can be done during this rotation
by just adding the elements with which to pad in the right quantity (the number of major cells) to every side:</p>
<pre class="bqn"><code>    {((â‰ ğ•©)â¥Š0)âˆ¾âŒ½â‰ğ•©}âŸ4 m  # Pad every side
â”Œâ”€
â•µ 0 0 0 0 0
  0 0 1 2 0
  0 3 4 5 0
  0 6 7 8 0
  0 0 0 0 0
            â”˜</code></pre>
</details>
<p>Changing direction involves picking the unique (per the question) next direction to go in.
In particular, we never want to turn around.</p>
<pre class="bqn"><code>ND â† { pos ğ•Š dir:
  ds â† (&lt;Â¯1Ã—dir)(Â¬âˆ˜â·/âŠ¢)âŸ¨1â€¿0, 0â€¿1, Â¯1â€¿0, 0â€¿Â¯1âŸ© # Not where we came from
  ds/Ëœ' 'â‰ inpâŠ‘Ëœds+&lt;pos                        # Not empty space
}</code></pre>
<p>Notice how the result of <code>ND</code> is still a listâ€”when itâ€™s empty,
we know that we have reached the end.
Getting the path now simply involves simulating what we need to simulate.</p>
<pre class="bqn"><code>path â† {
  Â·â€¿pthâ€¿pos â† { ğ•Šdirâ€¿pthâ€¿pos:
      {' '=inpâŠ‘Ëœdir+pos? dir(âŠ‘posâŠ¸ND)â†©;@} # Change direction if necessary
      âŸ¨dir, pthâˆ¾posâŠ‘inp, pos+dirâŸ©
  }â€¢_while_{
    ğ•Šdirâ€¿Â·â€¿pos: 0&lt; â‰ pos ND dir   # While we can move somewhere
  } âŸ¨1â€¿0, &quot;&quot;, âŸ¨1, âŠ‘'|'âŠËœ1âŠinpâŸ©âŸ©  # Unique start
  pthâˆ¾posâŠ‘inp                    # Add last position to final path
}</code></pre>
<p>We just continue going into the same direction until the next cell would be a space.
In that case, we correct and move on until we canâ€™t move anymore.
As said above, the start is the unique <code>|</code> connected to the top;
the index is quickly obtained with <em>index of</em> after a <em>first cell</em>,
to get the first major cell (row, in this case).</p>
<p>All thatâ€™s left to do is to get all letters from the path:</p>
<pre class="bqn"><code>âˆŠâŸœ('A'+â†•26)âŠ¸/ path # â‡’ &quot;RUEDAHWKSM&quot;</code></pre>
<hr />
<p>Part two is short and sweetâ€”probably a breather from yesterdayâ€”and asks us for the length of the path.</p>
<pre class="bqn"><code>â‰ path # â‡’ 17264</code></pre>
<h3 id="day-20"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day20.bqn">Day 20</a></h3>
<p>Today, we have to help the GPU simulate particles.
Our input consists of the particle positions,
together with their velocity and acceleration.</p>
<pre><code>p=&lt;-3770,-455,1749&gt;, v=&lt;-4,-77,53&gt;, a=&lt;11,7,-9&gt;
p=&lt;1430,195,-903&gt;, v=&lt;-123,60,20&gt;, a=&lt;5,-5,1&gt;
p=&lt;-2964,-3029,2594&gt;, v=&lt;-8,157,7&gt;, a=&lt;9,-3,-8&gt;
â€¦</code></pre>
<p>Part one asks us the following, slightly handwavy, question.</p>
<blockquote>
<p>Which particle will stay closest to position &lt;0,0,0&gt; in the long term?</p>
</blockquote>
<p>Before thinking about this too much, letâ€™s first parse the input.</p>
<pre class="bqn"><code>Pâ†{pâ€¿râ†3(â†‘â‹ˆâ†“)ğ•© â‹„ vâ€¿aâ†3(â†‘â‹ˆâ†“)r â‹„ âŸ¨p,v,aâŸ©}
inpâ†{Pâ€¢BQN'âŸ¨'âˆ¾ğ•©âˆ¾'âŸ©'}âˆ˜(âˆŠâŸœ(&quot;-,&quot;âˆ¾'0'+â†•10)âŠ¸/)Â¨â€¢FLines&quot;../inputs/day20.txt&quot;</code></pre>
<p>Very dirty!
We first filter every line, only keeping the important bits for processing,
and then parse the whole thing as a list.</p>
<pre class="bqn"><code>    (âˆŠâŸœ(&quot;-,&quot;âˆ¾'0'+â†•10)âŠ¸/) &quot;p=&lt;-3770,-455,1749&gt;, v=&lt;-4,-77,53&gt;, a=&lt;11,7,-9&gt;&quot;
&quot;-3770,-455,1749,-4,-77,53,11,7,-9&quot;</code></pre>
<p>Now, â€œin the long termâ€ is a bit of a flexible formulation,
but what the question essentially wants us to recognise is that a higher acceleration always wins<!--
-->â€”doesnâ€™t matter how fast the other particle started.
In particular, if we want to find out which particle will stay closest to the origin,
we need to find the one that has the smallest acceleration.
I will discuss two ways of doing this, each slightly flawed in its own way.</p>
<p>First, my input has the neat property that there is a unique particle with a smallest total acceleration.
In such cases, part one just amounts to picking that.</p>
<pre class="bqn"><code>âŠ‘âˆ˜(âŠ¢âŠâŒŠÂ´) {+Â´|Â¯1âŠ‘ğ•©}Â¨ inp # â‡’ 376</code></pre>
<p><code>{+Â´|Â¯1âŠ‘ğ•©}</code> computes the maximal acceleration,
and <code>(âŠ¢âŠâŒŠÂ´)</code> is a neat train to pick the index of the minimal element.</p>
<p>In the absence of a unique particle with smallest total acceleration,
things get a bit more complicated.
One would have to include velocity and direction of travel into the equation,
which is much harder than to just simulate everything â€œfor a bitâ€.</p>
<pre class="bqn"><code>Uâ†{pâ€¿vâ€¿a: âŸ¨p+v+a, v+a, aâŸ©}
âŠ‘(âŠ¢âŠâŒŠÂ´)(+Â´|)âˆ˜âŠ‘âˆ˜(UâŸ1000)Â¨inp # â‡’ 376</code></pre>
<p>Get the absolute value of each position after 1000 steps,
and then compute the minimum as before.</p>
<hr />
<p>Part two wants us to take care of â€œcollidingâ€ particlesâ€”those whose positions match up at any point in time.
Since Iâ€™m not going to solve quadratic equations, letâ€™s also just simulate this one â€œlong enoughâ€.</p>
<pre class="bqn"><code>â‰ {(âˆŠâˆ§1âŒ½âˆŠ)âˆ˜(âŠ‘Â¨)âŠ¸/ âˆ¨UÂ¨ğ•©}âŸ1000 inp # â‡’ 574</code></pre>
<p>We advance every particle in the input by one,
sort the resulting list by position,
and kick out all particles that are equal to any adjacent ones.</p>
<details>
<summary>
The <code>âˆŠâˆ§1âŒ½âˆŠ</code> part is probably reasonably obfuscated, so letâ€™s go through it.
</summary>
<p>First, one could write that piece of code in a slightly differentâ€”perhaps more understandableâ€”way:<a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a></p>
<pre class="bqn"><code>(â‰¢Ë˜âŸœÂ«)âˆ§(â‰¢Ë˜âŸœÂ»)</code></pre>
<p>This very symmetrical looking expression checks which elements in a given vector
are unequal to their successor and predecessor:</p>
<pre class="bqn"><code>    (â‰¢Ë˜âŸœÂ«) âŸ¨1,1,3,âŸ¨4âŸ©,âŸ¨4âŸ©âŸ©
âŸ¨ 0 1 1 0 1 âŸ©
    (â‰¢Ë˜âŸœÂ») âŸ¨1,1,3,âŸ¨4âŸ©,âŸ¨4âŸ©âŸ©
âŸ¨ 1 0 1 1 0 âŸ©
    ((â‰¢Ë˜âŸœÂ«)âˆ§(â‰¢Ë˜âŸœÂ»)) âŸ¨1,1,3,âŸ¨4âŸ©,âŸ¨4âŸ©âŸ©
âŸ¨ 0 0 1 0 0 âŸ©</code></pre>
<p>The first thing to notice is that, in a sorted list,
a number not being equal to its predecessor just means that itâ€™s the first occurrence of that number in the vector:</p>
<pre class="bqn"><code>    (â‰¢Ë˜âŸœÂ») âŸ¨1,1,3,4,4,4,5,6,6âŸ©
âŸ¨ 1 0 1 1 0 0 1 1 0 âŸ©
    âˆŠ âŸ¨1,1,3,4,4,4,5,6,6âŸ©
âŸ¨ 1 0 1 1 0 0 1 1 0 âŸ©
    âˆŠ âŸ¨1,1,3,4,4,5,6,6âŸ©
âŸ¨ 1 0 1 1 0 1 1 0 âŸ©
   (â‰¢Ë˜âŸœÂ») âŸ¨1,1,3,4,4,5,6,6âŸ©
âŸ¨ 1 0 1 1 0 1 1 0 âŸ©</code></pre>
<p>The more interesting questions is how to capture that a number is not equal to its successor.
For that, one can still use <em>mark firsts</em> and then simply <em>rotate</em> the vector by one to the left.
This will instead give you the last occurrence of every element in the vector.</p>
<pre class="bqn"><code>    (â‰¢Ë˜âŸœÂ«) âŸ¨1,1,3,4,4,4,5,6,6,7âŸ©
âŸ¨ 0 1 1 0 0 1 1 0 1 1 âŸ©
   1âŒ½âˆŠ âŸ¨1,1,3,4,4,4,5,6,6,7âŸ©
âŸ¨ 0 1 1 0 0 1 1 0 1 1 âŸ©</code></pre>
<p>Thus, to get the unique elements of our sorted list, <code>âˆŠâˆ§1âŒ½âˆŠ</code> will do!<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a></p>
</details>
<h2 id="days-2125">Days 21â€“25</h2>
<h3 id="day-21"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day21.bqn">Day 21</a></h3>
<p>In todayâ€™s very array-oriented problem,
we have to help a program create art by repeatedly enhancing an image.
The following is our starting pattern:</p>
<pre><code>.#.
..#
###</code></pre>
<p>The task says to apply the following two simple rules over and over again.</p>
<blockquote>
<ul>
<li>If the size [of the array] is evenly divisible by 2, break the pixels up into 2x2 squares, and convert each 2x2 square into a 3x3 square by following the corresponding enhancement rule.</li>
<li>Otherwise, the size is evenly divisible by 3; break the pixels up into 3x3 squares, and convert each 3x3 square into a 4x4 square by following the corresponding enhancement rule.</li>
</ul>
</blockquote>
<p>An â€œenhancement ruleâ€ look like <code>../.# =&gt; ##./#../...</code>, where <code>/</code> signals a line break.
An important part of the problem is that not only does <code>../.#</code> match this pattern, but also any rotation or flip of it,
which means the following configurations are all matches:</p>
<pre><code>..     .#     #.     ..
.#     ..     ..     #.</code></pre>
<p>Note that regardless of how the match is formed, the output pattern is never rotated or flipped.</p>
<p>Beginning with the above starting configuration and applying enhancement rule <code>.#./..#/### =&gt; #..#/..../..../#..#</code>,
we end up with</p>
<pre><code>#..#
....
....
#..#</code></pre>
<p>Applying rule <code>../.# =&gt; ##./#../...</code> to each of the four 2Ã—2 squares, we get</p>
<pre><code>##.##.
#..#..
......
##.##.
#..#..
......</code></pre>
<p>and so on.</p>
<p>Part one asks us to simulate the whole thing five times,
and determine how many <code>#</code>â€™s are in the resulting grid.
Letâ€™s start by parsing a single enhancement line:</p>
<pre class="bqn"><code>âŸ¨SplitâŸ© â† â€¢Import &quot;../../util/bqn_util/util.bqn&quot;
P â† { # Parse a line into fromâ€¿to pairs
  fâ€¿t â† '='Splitğ•© â‹„ f Â¯1âŠ¸â†“â†© â‹„ t 2âŠ¸â†“â†©
  &gt;âˆ˜(&quot;.#&quot;âŠ¸âŠÂ¨)âˆ˜('/'âŠ¸Split)Â¨ fâ€¿t
}</code></pre>
<p>This isnâ€™t too surprising; we first essentially split on <code>" =&gt; "</code> in an awkward way,<a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>
split every individual array on <code>/</code>,
change the dots and hashes to zeros and ones,
and <em>merge</em> each of the vectors into a proper array.</p>
<pre class="bqn"><code>    P &quot;.../.../... =&gt; ...#/#.##/.##./#..#&quot;
â”Œâ”€
Â· â”Œâ”€        â”Œâ”€
  â•µ 0 0 0   â•µ 0 0 0 1
    0 0 0     1 0 1 1
    0 0 0     0 1 1 0
          â”˜   1 0 0 1
                      â”˜
                        â”˜</code></pre>
<p>Since all rotations and flips are valid for the pattern match,
we might as well immediately â€œexpandâ€ each of the substitutions into all eight possibilities.
This essentially boils down to applying every transformation of the
<a href="https://en.wikipedia.org/wiki/Dihedral_group#Matrix_representation">dihedral group</a>
<span class="math inline">D_4</span> of the square to our array.
One way to do this is to compute all of the rotations,
and all of the rotations with reversed rows.
We already saw that we can use <code>(â‰âŒ½)âŸ(â†•4)</code> to obtain all rotations on <a href="#day-19">day 19</a>,
and reversing the rows is easy enough to do with <code>âŒ½Ë˜</code>:</p>
<pre class="bqn"><code>    âŸ¨âŒ½Ë˜,âŠ¢âŸ©{ğ•ğ•©}âŒœ(â‰âŒ½)âŸ(â†•4) &gt;âŸ¨âŸ¨1,2âŸ©,âŸ¨3,4âŸ©âŸ©
â”Œâ”€
â•µ â”Œâ”€      â”Œâ”€      â”Œâ”€      â”Œâ”€
  â•µ 2 1   â•µ 1 3   â•µ 3 4   â•µ 4 2
    4 3     2 4     1 2     3 1
        â”˜       â”˜       â”˜       â”˜
  â”Œâ”€      â”Œâ”€      â”Œâ”€      â”Œâ”€
  â•µ 1 2   â•µ 3 1   â•µ 4 3   â•µ 2 4
    3 4     4 2     2 1     1 3
        â”˜       â”˜       â”˜       â”˜
                                  â”˜</code></pre>
<p>We now just have to do some plumbing to associate every one of the resulting eight input patterns to the same output.</p>
<pre class="bqn"><code>E â† { ğ•Š fâ€¿t: (â¥ŠâŸ¨âŒ½Ë˜,âŠ¢âŸ©{ğ•ğ•©}âŒœ(â‰âŒ½)âŸ(â†•4)f)â‹ˆÂ¨&lt;t }</code></pre>
<details>
<summary>
For example (line wrapped for readability):
</summary>
<pre class="bqn"><code>â”Œâ”€
Â· â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 1 0   â•µ 0 0 1
      0 1     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 1 0   â•µ 0 0 1
      0 1     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 0 1   â•µ 0 0 1
      1 0     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 0 1   â•µ 0 0 1
      1 0     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 1 0   â•µ 0 0 1
      0 1     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 0 1   â•µ 0 0 1
      1 0     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
  â”Œâ”€
  Â· â”Œâ”€      â”Œâ”€
    â•µ 1 0   â•µ 0 0 1
      0 1     1 0 0
          â”˜   1 1 0
                    â”˜
                      â”˜
                        â”˜</code></pre>
</details>
<p>Now, as you can imagine by either thinking about or looking at the output,
there are usually a lot of duplicates in this list.
We can fix this by using
<em>deduplicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/selfcmp.html#deduplicate"><code>â·</code></a>)
to only keep the first occurrence of every major cell.</p>
<pre class="bqn"><code>E â† { ğ•Š fâ€¿t: (â·â¥ŠâŸ¨âŒ½Ë˜,âŠ¢âŸ©{ğ•ğ•©}âŒœ(â‰âŒ½)âŸ(â†•4)f)â‹ˆÂ¨&lt;t }
inp â† âˆ¾ Eâˆ˜PÂ¨ â€¢FLines&quot;../inputs/day21.txt&quot;</code></pre>
<p>Next up is enhancing the grid as described.
Letâ€™s do this generically:
given an array, a target <code>k</code> (for <code>kÃ—k</code> subarrays),
and a list of <code>kÃ—k â†’ (k+1)Ã—(k+1)</code> substitutions,
perform one enhancement step.<a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a></p>
<pre class="bqn"><code>Widen â† { kâ€¿substs ğ•Š grid:
  âˆ¾{ ğ•Šsg: # A kÃ—k submatrix of `grid'
    1âŠ‘âŠ‘ (sgâ‰¡âŠ‘)Â¨âŠ¸/substs
  }Â¨ (2â¥Š&lt;âŒŠkÃ·Ëœâ†•â‰ grid)âŠ”grid
}</code></pre>
<p><em>Group</em> is used to partition the grid into the necessary <code>kÃ—k</code> subarrays:
<code>âŒŠkÃ·Ëœâ†•â‰ grid</code> creates a vector like <code>âŸ¨0,â€¦,0, 1,â€¦,1 â€¦, n,â€¦,nâŸ©</code>,
where <code>n = ((â‰ grid)Ã·k)-1</code> and each number appears exactly <code>k</code> times:</p>
<pre class="bqn"><code>    (âŒŠ3Ã·Ëœâ†•21)
âŸ¨ 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 âŸ©
    (âŒŠ7Ã·Ëœâ†•21)
âŸ¨ 0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2 âŸ©</code></pre>
<p>We can then use the fact that the left argument to <em>group</em> can be a nested vector,
where each element corresponds to one axis of the right argument;
see <a href="https://mlochbaum.github.io/BQN/doc/group.html#multidimensional-grouping">multidimensional grouping</a>.
For the simple partition that we want, doubling the vector suffices.</p>
<pre class="bqn"><code>    2â¥Š&lt;âŒŠ3Ã·Ëœâ†•6
âŸ¨ âŸ¨ 0 0 0 1 1 1 âŸ© âŸ¨ 0 0 0 1 1 1 âŸ© âŸ©
    (2â¥Š&lt;âŒŠ3Ã·Ëœâ†•6)âŠ”(6â€¿6â¥Šâ†•36)
â”Œâ”€
â•µ â”Œâ”€           â”Œâ”€
  â•µ  0  1  2   â•µ  3  4  5
     6  7  8      9 10 11
    12 13 14     15 16 17
             â”˜            â”˜
  â”Œâ”€           â”Œâ”€
  â•µ 18 19 20   â•µ 21 22 23
    24 25 26     27 28 29
    30 31 32     33 34 35
             â”˜            â”˜
                            â”˜</code></pre>
<p>The rest of the code is kind of straightforward;
in <code>{ğ•Šsg: 1âŠ‘âŠ‘ (sgâ‰¡âŠ‘)Â¨âŠ¸/substs}</code> we look for the substitution that fits the current subset of the grid<!--
-->â€”we are guaranteed by the question that we have exactly one such matchâ€”<!--
-->and take the enhancement (<code>1âŠ‘</code>).
This already has the right shape in that the resulting array consists of <code>(k+1)Ã—(k+1)</code> blocks in the right order,
so we just need to <em>join</em> everything together.</p>
<pre class="bqn"><code>    t â† âŸ¨2, {2=â‰ âŠ‘ğ•©}Â¨âŠ¸/inpâŸ© {
      kâ€¿ssğ•Šg: {ğ•Šsg: 1âŠ‘âŠ‘ (sgâ‰¡âŠ‘)Â¨âŠ¸/ss}Â¨ (2â¥Š&lt;âŒŠkÃ·Ëœâ†•â‰ g)âŠ”g
    } [[1,1,0,1],[0,1,1,0],[1,1,0,1],[0,0,0,1]]
â”Œâ”€
â•µ â”Œâ”€        â”Œâ”€
  â•µ 1 1 0   â•µ 0 0 1
    0 0 1     1 0 0
    1 0 1     1 1 0
          â”˜         â”˜
  â”Œâ”€        â”Œâ”€
  â•µ 0 1 0   â•µ 0 1 0
    1 1 0     1 1 0
    1 1 1     1 1 1
          â”˜         â”˜
                      â”˜
    âˆ¾t
â”Œâ”€
â•µ 1 1 0 0 0 1
  0 0 1 1 0 0
  1 0 1 1 1 0
  0 1 0 0 1 0
  1 1 0 1 1 0
  1 1 1 1 1 1
              â”˜</code></pre>
<p>When plugging everything together we just need to make sure to pass the right substitutions to <code>Widen</code>
(and to have the case for <code>2</code> come before that for <code>3</code>).</p>
<pre class="bqn"><code>Sim â† { # Only take valid substitutions.
  0=2|â‰ ğ•©? âŸ¨2, {2=â‰ âŠ‘ğ•©}Â¨âŠ¸/inpâŸ© Widen ğ•©;
  0=3|â‰ ğ•©? âŸ¨3, {3=â‰ âŠ‘ğ•©}Â¨âŠ¸/inpâŸ© Widen ğ•©
}

start â† &gt;&quot;.#&quot;âŠ¸âŠÂ¨âŸ¨&quot;.#.&quot;, &quot;..#&quot;, &quot;###&quot;âŸ©
+Â´â¥Š SimâŸ5  start # â‡’ 155</code></pre>
<hr />
<p>Part two asks us to instead simulate 18 enhancement steps.</p>
<pre class="bqn"><code>+Â´â¥Š SimâŸ18 start # â‡’ 2449665</code></pre>
<h3 id="day-22"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day22.bqn">Day 22</a></h3>
<p>Today we are tasked with helping a computer cluster fend off a virus.
Our puzzle input is a populated part of an infinite grid:</p>
<pre><code>..#
#..
...</code></pre>
<p>The virus starts square in the middle, looking up.</p>
<p>Part one has two types of cells, clean (<code>.</code>) and infected (<code>#</code>),
and wants us to count the number of cells that have been infected (at any point) after 10â€™000 steps.
A single step in the simulation proceeds according to the following rules:</p>
<blockquote>
<ul>
<li>If the current node is infected, it turns to its right. Otherwise, it turns to its left. (Turning is done in-place; the current node does not change.)</li>
<li>If the current node is clean, it becomes infected. Otherwise, it becomes cleaned. (This is done after the node is considered for the purposes of changing direction.)</li>
<li>The virus carrier moves forward one node in the direction it is facing</li>
</ul>
</blockquote>
<p>We will use a hash map to simulate the infinite grid.
Parsing is easy this time:</p>
<pre class="bqn"><code>inp â† &gt;â€¢FLines &quot;../inputs/day22.txt&quot;
Start â† {âŸ¨(â¥Šâ†•â‰¢inp)â€¢HashMapğ•©, 0, âŒŠ(â‰¢inp)Ã·2, Â¯1â€¿0âŸ©}</code></pre>
<p>Note the unusual coordinates:
since I donâ€™t want to change the â€œdirectionâ€ in the array itself,
up, right, down, and left are <code>Â¯1â€¿0</code>, <code>0â€¿1</code>, <code>1â€¿0</code>, and <code>0â€¿Â¯1</code>, respectively.
For the simulation, we also need the ability to change direction.
The idea is to get the index of <code>ğ•©</code> in a list of directions,
add <code>ğ•¨</code> mod 4 (to turn <code>ğ•¨</code> steps to the right),
and <em>pick</em> the element at that index.</p>
<pre class="bqn"><code>Turn â† { # Given direction ğ•©, turn ğ•¨ steps to the right.
  ts â† âŸ¨Â¯1â€¿0, 0â€¿1, 1â€¿0, 0â€¿Â¯1âŸ©
  (âŠ‘4|ğ•¨+tsâŠ&lt;ğ•©)âŠ‘ts
}</code></pre>
<p>The simulation now just does what the rules say.</p>
<pre class="bqn"><code>Sim â† { ğ•Šgâ€¿iâ€¿pâ€¿d:     # grid, index, position, direction
  pv â† 0 g.Get p      # Don't keep track of clean (= 0) cells.
  nd â† ({ğ•Š0:Â¯1;ğ•©}pv) Turn d
  p g.Set Â¬pv         # New value for p.
  âŸ¨g, i+0=pv, p+nd, ndâŸ©
}

1âŠ‘ SimâŸ10_000 Start(â¥Š&quot;.#&quot;âŠinp) # â‡’ 5460</code></pre>
<p>Since we want to turn left when we see a clean cell,
we have to have a substitution like <code>0â†’Â¯1</code>,
which is what <code>{ğ•Š0:Â¯1;ğ•©}</code> accomplishes.
We again donâ€™t keep track of additional clean cells by supplying a default argument to <code>Get</code>, in case <code>p</code> is not found.</p>
<hr />
<p>Part two wants us to simulate the same thing, but instead of two we now have four states to keep track of:
clean, weakened, infected, and flaggedâ€”in that order.
We also have to simulate everything for 10â€™000â€™000 instead of only 10â€™000 steps,
and the rules are a bit different:</p>
<blockquote>
<ul>
<li>Decide which way to turn based on the current node:
<ul>
<li>If it is clean, it turns left.</li>
<li>If it is weakened, it does not turn, and will continue moving in the same direction.</li>
<li>If it is infected, it turns right.</li>
<li>If it is flagged, it reverses direction, and will go back the way it came.</li>
</ul></li>
<li>Modify the state of the current node, as described above [clean â†’ weakened â†’ infected â†’ flagged â†’ clean â€¦].</li>
<li>The virus carrier moves forward one node in the direction it is facing.</li>
</ul>
</blockquote>
<p>After some staring one figures out that while the infected state has moved from <code>1</code> to <code>2</code>, the whole thing just switches out numbers mod 2 for numbers mod 4.
Looking at our <code>Sim</code> function,
we only need to change a few things to make it more generic:</p>
<pre class="bqn"><code># modâ€¿infectedTargetâ€¿TurnOffset ğ•Š gridâ€¿infectCountâ€¿positionâ€¿direction
Sim â† { mâ€¿tâ€¿TO ğ•Š gâ€¿iâ€¿pâ€¿d:
  pv â† 0 g.Get p      # Don't keep track of clean (= 0) cells.
  nd â† (TO pv) Turn d
  p g.Set m|pv+1      # New value for p.
  âŸ¨g, i+t=pv, p+nd, ndâŸ©
}

# Part one still works:
1âŠ‘ âŸ¨2, 0, {ğ•Š0:Â¯1;ğ•©}âŸ© SimâŸ10_000 Start(â¥Š&quot;.#&quot;âŠinp) # â‡’ 5460</code></pre>
<p>Some bits of additional state, like the modulus used or which number we want to count in the end, are needed.
Other than that, though, itâ€™s the same function as before.</p>
<pre class="bqn"><code>1âŠ‘ âŸ¨4, 1, -âŸœ1âŸ© SimâŸ10_000_000 Start(â¥Š&quot;. #&quot;âŠinp) # â‡’ 2511702</code></pre>
<h3 id="day-23"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day23.bqn">Day 23</a></h3>
<p>Today we have to help an experimental coprocessor to not halt and catch fire.
This again boils down to simulating some small assembly languageâ€”or so one would think.
The instruction set is similar to that of <a href="#day-18">day 18</a>:</p>
<blockquote>
<ul>
<li><code>set X Y</code> sets register <code>X</code> to the value of <code>nY</code>.</li>
<li><code>sub X Y</code> decreases register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mul X Y</code> sets register <code>X</code> to the result of multiplying the value contained in register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>jnz X Y</code> jumps with an offset of the value of <code>Y</code>, but only if the value of <code>X</code> is not zero. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)</li>
</ul>
<p>Only the instructions listed above are used. The eight registers here, named <code>a</code> through <code>h</code>, all start at 0.</p>
</blockquote>
<p>Part one asks us how many times the <code>mul</code> instruction is invoked.
My solution is this one:</p>
<pre class="bqn"><code>63Ã—63 # â‡’ 3969</code></pre>
<p>Oh yeah.</p>
<hr />
<p>So whatâ€™s that all about?
Well, originally the code looked very different<!--
-->â€”almost an exact copy-paste of what we did for day 18â€”<!--
-->but part two reveals what the task actually wants us to do.</p>
<blockquote>
<p>You flip the switch, which makes register <code>a</code> now start at <code>1</code> when the program is executed.</p>
<p>Immediately, the coprocessor begins to overheat. Whoever wrote this program obviously didnâ€™t choose a very efficient implementation. Youâ€™ll need to optimize the program if it has any hope of completing before Santa needs that printer working.
The coprocessorâ€™s ultimate goal is to determine the final value left in register <code>h</code> once the program completes. Technically, if it had thatâ€¦ it wouldnâ€™t even need to run the program.</p>
</blockquote>
<p>This is a very big nudge into the direction of â€œgo and read the assemblyâ€.
There are, I suppose, several ways to go about finding the solution.
The sane one might be to translate the assembly into a more human readable form,<a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a>
and then try to see patterns in this simpler representation (remember notation as a tool for thought?).
Instead, I employed a trusted method that I learned from studying maths for too long:
stare at it until it makes sense.</p>
<details>
<summary>
Hereâ€™s the input if you want to give it a try.
</summary>
<pre><code>set b 65
set c b
jnz a 2
jnz 1 5
mul b 100
sub b -100000
set c b
sub c -17000
set f 1
set d 2
set e 2
set g d
mul g e
sub g b
jnz g 2
set f 0
sub e -1
set g e
sub g b
jnz g -8
sub d -1
set g d
sub g b
jnz g -13
jnz f 2
sub h -1
set g b
sub g c
jnz g 2
jnz 1 3
sub b -17
jnz 1 -23</code></pre>
</details>
<p><a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a>
After quite a lot of staring, one figures out that <code>h</code> will fill up with all non-primes between <code>106500</code> and <code>123500</code> in steps of <code>17</code>.</p>
<pre class="bqn"><code>+Â´{1â‰ +Â´0=ğ•©|Ëœâ†•âŒˆâˆšğ•©}Â¨+âŸœ17âŸ(â†•1+17Ã·Ëœ123500-106500) 106500 # â‡’ 917</code></pre>
<h3 id="day-24"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day24.bqn">Day 24</a></h3>
<p>The penultimate day wants us to build a bridge to get across a
<a href="https://knowyourmeme.com/memes/bottomless-pit-supervisor">bottomless pit</a>.
Our puzzle input comprises components that we have to connect to each other:</p>
<pre><code>0/2
2/2
2/3
3/4
3/5
0/1
10/1
9/10</code></pre>
<p>We start at <code>0</code>; the â€œportsâ€ of connected components have to match up, but only up to rotation:
<code>0/2â€”2/3â€”4/3</code> is a valid bridge.
The only restriction we have in that regard is that a port can only be used once,
so <code>0/2â€”2/3â€”2/4</code> is not valid.
Part one asks us for the strongest bridge we can make of our input (without replacement),
where the strength is just all ports added together.
Parsing is trivial:</p>
<pre class="bqn"><code>âŸ¨Split,_FixâŸ© â† â€¢Import&quot;../../util/bqn_util/util.bqn&quot;
inp â† â€¢ParseFloatÂ¨âˆ˜('/'âŠ¸Split)Â¨ â€¢FLines&quot;../inputs/day24.txt&quot;</code></pre>
<p>This creates a nested vector like <code>âŸ¨âŸ¨0 2âŸ© âŸ¨2 2âŸ© âŸ¨2 3âŸ© â€¦âŸ©</code>.
For selecting a part, we want to match a number against that list and pick all ports where at least one port matches that number:</p>
<pre class="bqn"><code>    Sel â† (&gt;âˆŠÂ¨)/âŠ¢
(function block)
    0 Sel inp      # Starting states
âŸ¨ âŸ¨ 50 0 âŸ© âŸ¨ 28 0 âŸ© âŸ¨ 0 33 âŸ© âŸ©</code></pre>
<p>For each of these starting states, we can formulate a naturally recursive algorithm:
given a target value <code>t</code> and a list <code>xs</code> of components, do the following:</p>
<ul>
<li>if no components match <code>t</code>, return <code>0</code>;</li>
<li>otherwise, recurse on each match
(using the value that <code>t</code> didnâ€™t match as the new target),
pick the maximum over all branches,
and add the value of the current match to it.</li>
</ul>
<pre class="bqn"><code>SM â† Â¬âˆ˜âˆŠ/âŠ£ # Set minus
Sim â† { t Rec xs:
  {(+Â´ğ•©)+ 0âŒˆÂ´ (ğ•©âŠ‘Ëœt=âŠ‘ğ•©)Rec xs SMâŸ¨ğ•©âŸ©}Â¨ t Sel xs
}</code></pre>
<p>We use our old friend <code>Â¬âˆ˜âˆŠ/âŠ£</code> to take care of the â€œwithout replacementâ€ part of the whole thing,
<code>ğ•©âŠ‘Ëœt=âŠ‘ğ•©</code> picks the number that did not match <code>t</code> for the recursion, and
the maximum over all branches has a default value of <code>0</code>, which is supplied in case the list is empty.</p>
<p>To complete part one we just have to pick the maximum over all starting values:</p>
<pre class="bqn"><code>âŒˆÂ´âˆ¾{ğ•Š0â€¿b: b+ b Sim inp SMâŸ¨0â€¿b,bâ€¿0âŸ©}âˆ˜âˆ§Â¨0 Sel inp # â‡’ 1656</code></pre>
<p>We sort the starting values for easier pattern matching,
and then just have to take some extra care of actually removing it from the list.</p>
<hr />
<p>Part two wants us to get the strongest bridge only amongst those that are longest overall.
For example, given the bridges</p>
<ul>
<li><code>0/1â€”10/1â€”9/10</code></li>
<li><code>0/2</code></li>
<li><code>0/2â€”2/3â€”3/5</code></li>
<li><code>0/2â€”2/2â€”2/3â€”3/4</code></li>
<li><code>0/2â€”2/2â€”2/3â€”3/5</code></li>
</ul>
<p>for part one <code>0/1â€”10/1â€”9/10</code> would win with a score of <code>31</code>,
and for part two <code>0/2â€”2/2â€”2/3â€”3/5</code> would win with a score of <code>19</code>.
Conceptually, this is sort of the same code, only with more bookkeeping.</p>
<pre class="bqn"><code>Sim2 â† { iâ€¿t Rec xs: # Step i, target value t, list xs
  {iâ€¿(+Â´ğ•©)+ âŠ‘âˆ¨ (&lt;0â€¿0)âˆ¾ âŸ¨i+1, ğ•©âŠ‘Ëœt=âŠ‘ğ•©âŸ© Rec xs SM âŸ¨ğ•©âŸ©}Â¨t Sel xs
}
1âŠ‘âŒˆÂ´âˆ¾{ğ•Š0â€¿b: 0â€¿bâŠ¸+Â¨ 1â€¿b Sim2 inp SM âŸ¨0â€¿b,bâ€¿0âŸ©}âˆ˜âˆ§Â¨0 Sel inp # â‡’ 1642</code></pre>
<p>Instead of just the current strength, we also keep track of the depth.
The maximum thus has to prefer the first index of that tuple to the second one.
Thankfully, the default
<em>sort down</em> (<a href="https://mlochbaum.github.io/BQN/doc/order.html#sort"><code>âˆ¨</code></a>)
already does this,
which gives us our answer for part two.</p>
<p>If we really wanted to, we could now combine these two solutions,
and even get rid of the <code>SM</code> and <code>Sel</code> functions, because why have human readable names if you could use funny symbols?</p>
<pre class="bqn"><code>_sol â† { Mx _ğ•£:               # Max function Mx
  âŒˆÂ´âˆ¾{ ğ•Š0â€¿b:
    b+ 1âŠ‘Â¨ 1â€¿b { iâ€¿t Rec xs:  # Step i, Target value t, list xs
      {âŸ¨i,+Â´ğ•©âŸ©+ Mx âŸ¨i+1, ğ•©âŠ‘Ëœt=âŠ‘ğ•©âŸ©Rec xs(Â¬âˆ˜âˆŠ/âŠ£)âŸ¨ğ•©âŸ©}Â¨t((&gt;âˆŠÂ¨)/âŠ¢)xs
    } inp(Â¬âˆ˜âˆŠ/âŠ£)âŸ¨0â€¿b,bâ€¿0âŸ©
  }âˆ˜âˆ§Â¨0((&gt;âˆŠÂ¨)/âŠ¢)inp
}

{0âŒˆÂ´1âŠ‘Â¨ğ•©}    _sol # â‡’ 1656
{âŠ‘âˆ¨(&lt;0â€¿0)âˆ¾ğ•©} _sol # â‡’ 1642</code></pre>
<h3 id="day-25"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day25.bqn">Day 25</a></h3>
<p>Appropriately, for the final day we have to simulate a Turing machine!
Actually, it starts with a parsing problem:
the transition function of the Turing machine is given in the following format:</p>
<pre><code>In state A:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state B.
  If the current value is 1:
    - Write the value 0.
    - Move one slot to the left.
    - Continue with state C.</code></pre>
<p>Some additional information,
like the starting state and the number of iterations we should simulate the machine for,
is also given.
Frankly, on the last day I have no intention of doing a bunch of parsing in a language which is, in my opinion, not at all suited for that kind of task.
Since the transition function is small enough, however, we can do what we did two days ago and justâ€¦ inspect the input.</p>
<pre class="bqn"><code>tapeâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
Gâ†0âŠ¸tape.Get   # Get
Wâ†tape.Set     # Write
Aâ†Bâ†Câ†Dâ†Eâ†Fâ†âŠ¢  # Forward declarations!
Aâ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix+1,BâŸ©; ixğ•Š1: ix W 0 â‹„ âŸ¨ix-1,CâŸ©}
Bâ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix-1,AâŸ©; ixğ•Š1: ix W 1 â‹„ âŸ¨ix+1,DâŸ©}
Câ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix+1,AâŸ©; ixğ•Š1: ix W 0 â‹„ âŸ¨ix-1,EâŸ©}
Dâ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix+1,AâŸ©; ixğ•Š1: ix W 0 â‹„ âŸ¨ix+1,BâŸ©}
Eâ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix-1,FâŸ©; ixğ•Š1: ix W 1 â‹„ âŸ¨ix-1,CâŸ©}
Fâ†©{ixğ•Š0: ix W 1 â‹„ âŸ¨ix+1,DâŸ©; ixğ•Š1: ix W 1 â‹„ âŸ¨ix+1,AâŸ©}</code></pre>
<p>The tape is just a hash map that only keeps track of the non-zero entries.
Each of the states is a separate function that takes the current index and the value at that index,
and gives back the next index and state.
To solve part one, we just have to simulate this for the appropriate amount of time and then count the number of ones still on the tape.</p>
<pre class="bqn"><code>{ğ•Šiâ€¿Sim: i Sim G i}âŸ12_919_244 0â€¿A
+Â´tape.Values@ # â‡’ 4287</code></pre>
<p>There is probably a more array-oriented solution to this:
the transition function of this Turing machine is something like
<span class="math display">
  \delta\colon Q \times \Gamma \to Q \times \Gamma \times \{ \mathrm{L}, \mathrm{R} \},
</span>
where <span class="math inline">Q \defeq \{\, \mathrm{A,B,C,D,E,F} \,\}</span> and <span class="math inline">\Gamma \defeq \{\, 0, 1 \,\}</span>.
In particular,
for any of the 12 possible inputs, one obtains a single 3-tuple as an output.
This means that one should be able to use an array of shape <code>âŸ¨6, 2âŸ©</code> to solve this problem,
where every element would be a vector of length <code>3</code>, indicating the new state, tape cell, and direction.
Alternatively, I suppose, an array of shape <code>âŸ¨6, 2, 3âŸ©</code> also works
(and <a href="https://saltysylvi.github.io/blog/flat1.html">would be flat</a>).
I havenâ€™t explored this further, but it would probably be fun to implementâ€”I will leave it as an exercise for the eager reader.</p>
<hr />
<p>As every year, part two is a freebie if one has completed all of the puzzles up until now,
as it asks for the 49 stars collected so far to reboot the printer.
Nice.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If youâ€™re impatient, I think I had the most fun on days
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-8">8</a>,
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-14">14</a>,
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-17">17</a>, and
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-21">21</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>I flirted with APL for about a week before picking up BQN,
but the dialect that everyone seems to use is Dyalog APL,
and I didnâ€™t have the guts to commit to a proprietary language implementation.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>This sentence is also true for the axiom of choice;
jokes on you, constructivists!<a href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p>Depending on your font, <code>ğ•¨</code> and <code>ğ•©</code> might not look so different from <code>w</code> and <code>x</code>:
the former really are the blackboard bold variants of the respective letters.<a href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn5"><p>No relation.<a href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn6"><p>Perhaps it is unwise to postpone actually talking about arrays in an array language,
but I feel like if this gets even longer I will lose the one reader who gets this far.<a href="#fnref6" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn7"><p>Beyond the headline that is;
the fact that notation influences oneâ€™s thoughts seems obviously true to me.
Please indulge me for a second (or donâ€™t and go back to the main text) and let me derail this post about BQN with maths.
There is an abundance of different notations one might use to talk about Hopf-ish objects in monoidal categories.
Donâ€™t worry about actually understanding the maths, btw, just look at the notation.
Suppose we have maps
<span class="math inline">\mu \colon H \otimes H \to H</span>, <span class="math inline">\Delta\colon H \to H \otimes H</span>, <span class="math inline">S\colon  H\to H</span>, and <span class="math inline">\varepsilon \colon H \to \Bbbk</span>, for <span class="math inline">H \in \mathsf{Vect}_{\Bbbk}</span>.
Assume that this map satisfies
<span class="math display">
       \mu \circ (S \otimes \mathrm{id}) \circ \Delta
       = \eta \circ \varepsilon
       = \mu \circ (\mathrm{id} \otimes S) \circ \Delta.
   </span>
First of all, notice how there are already lots of notational decisions that could have been written up differently!
One might omit all of the <span class="math inline">\circ</span>â€™s, and just write <span class="math inline">\mu(S \otimes \mathrm{id})\Delta</span>,
or highlight the symmetry between two of the maps and write <span class="math inline">\nabla</span> instead of <span class="math inline">\mu</span>.</p>
<p>Even more extreme, however, are the following alternative ways of writing the same equation.
One might also express it</p>
<ul>
<li>in <em>Sweedler notation</em> by
<span class="math display">
  S(a_{(1)})a_{(2)} = \varepsilon(a) 1 =  a_{(1)}S(a_{(2)});
</span></li>
<li>with <em>commutative diagrams</em>:
<img class="pure-img" src="../images/bqn-aoc/commutative-diagram.png" alt="A commutative diagram for the above equation.">
and</li>
<li>with <em>string diagrams</em>:
<img class="pure-img" src="../images/bqn-aoc/string-diagram.png" alt="A string diagram for the above equation."></li>
</ul>
<p>Needless to say, these all look <em>vastly</em> different,
eachâ€”in my opinionâ€”enabling a certain mode of thought better than the others.
For example, I happen to like the string diagrammatic version the best,
and try to use it as often as possible.
However, try doing that when you have to juggle 10+ strings!
At that point, Sweedler notation becomes extremely concise and much easier to reason about.</p>
<p>Letâ€™s get back to that array programming thing, though.<a href="#fnref7" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn8"><p>This is actually also true for the respective user-defined analogues,
but letâ€™s talk about <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">that</a> later.<a href="#fnref8" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn9"><p>The grouping of days is mostly done so the TOC doesnâ€™t completely explode,
while retaining some sort of directional aid.
In either case, itâ€™s probably fastest to just <code>C-f</code> for the respective day.<a href="#fnref9" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn10"><p>The <code>â€¢</code> is not a separate function, but really part of the name <code>â€¢FLines</code>.
All names starting with that symbol are [system values]â€”<!--
   -->things provided by the BQN interpreter that are not the builtin primitives.
We will see other important system values, like <code>â€¢HashMap</code> or <code>â€¢Type</code>, a bit later.<a href="#fnref10" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn11"><p>The â€œreside inâ€ is crucial.
There are many definitions of affine space, here is a simple one:
an <em>affine space</em> comprises a set <span class="math inline">A</span> and a vector space <span class="math inline">V</span>,
such that the underlying abelian group of <span class="math inline">V</span> acts freely and transitively on <span class="math inline">A</span>.</p>
<p>What I actually want to say now is that <span class="math inline">A</span> the set of Unicode codepoints,
and <span class="math inline">V</span> is the field of â€œnumbersâ€.
This, however, falls quite flat almost immediately.
Even leaving aside all the â€œfloating points are evilâ€ rhetoric,
we can only reasonably act on a character with an integer.
Now, â„¤ is just a ring, not a field, and indeed has no hope of being a vector space over any field.
Rather, one should talk about characters forming an affine <em>module</em> over â„¤,
which would at least be a bit more formal.</p>
<p>â€œReside inâ€ can now mean that we embed both â„¤ and the set of Unicode codepoints into bigger structures,
such that the restriction to them yields the action we care about.
This could, for example, be the regular action of â„ on itself,
but I personally donâ€™t think that this helps much with reasoning about the original action.</p>
<p>I swear I will stop with the maths at some point.<a href="#fnref11" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn12"><p>All whitespace here, and indeed in most places, is completely redundant.
I choose to still include it, to â€œlogically groupâ€ certain operations.
It helps me with reading the code, anyways.<a href="#fnref12" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn13"><p>Or, if you wanted to make it extra confusing,
as <code>+Â´âŠ¢/âŠ¢=Â¯1âŠ¸âŒ½</code>,
but weâ€™ll get to that later on.<a href="#fnref13" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn14"><p>Note that the actual implementation of <code>Split</code> Iâ€™m using is</p>
<pre class="bqn"><code>Split â‡ (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸&gt;)âˆ˜â‰ âŠ”âŠ¢</code></pre>
<p>which is subtly different in its behaviour.
I leave it as an exercise for the readerâ€”or my future selfâ€”to figure out how exactly this version differs to the one I just explained,
and what problem it fixes.<a href="#fnref14" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn15"><p>E.g., Emacs supports this by means of <code>quoted-insert</code> (<code>C-q</code>).<a href="#fnref15" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn16"><p>The abelian assumption is important here; otherwise, you wonâ€™t get that
<span class="math inline">(f \cdot g)(x \cdot_M y) = (f\cdot g)(x) \cdot_N (f\cdot g)(y)</span>.<a href="#fnref16" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn17"><p>Technically, itâ€™s
<a href="https://mlochbaum.github.io/BQN/doc/train.html#longer-trains">â€œany function expression with multiple functions or subjects in itâ€</a>,
which means a string of functions and subjects that ends with a function.<a href="#fnref17" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn18"><p>This is a primitive in APL, dyadic <code>~</code>,
but itâ€™s easy enough to remember that it doesnâ€™t feel all that bothersome to write it out in BQN.<a href="#fnref18" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn19"><p>Donâ€™t want to somehow end up with an array that has holes in it!<a href="#fnref19" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn20"><p>In two dimensions this is <span class="math inline">|x_1 - x_2| + |y_1 - y_2|</span>;
or, as <span class="math inline">y</span> is always the origin, just <span class="math inline">|x_1|+|x_2|</span>.<a href="#fnref20" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn21"><p>Dzaima alerted me to the fact that <code>âˆ¾(â†•â‹ˆÂ¨â†•)ğ•©</code> as a whole is probably better written as <code>2/â†•ğ•©</code>,
using the magic of
<em>replicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/replicate.html#replicate"><code>/</code></a>).</p>
<pre class="bqn"><code>    2/â†•6
âŸ¨ 0 0 1 1 2 2 3 3 4 4 5 5 âŸ©</code></pre>
<p>However, since I wanted to showcase <code>zip</code>,
I will keep the slightly longer version in the main text.<a href="#fnref21" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn22"><p>Guess which other language I like to program in!<a href="#fnref22" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn23"><p>I mean, not reallyâ€”arrays in BQN are immutable.
But we can at least pretend it does that.<a href="#fnref23" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn24"><p>There is also a â€œcomputationalâ€ <em>under</em>,
in which the BQN implementation tries to find a right inverse to the given function.
Itâ€™s a pretty interesting modifier.<a href="#fnref24" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn25"><p>Thatâ€™s actually false: this algorithm doesnâ€™t provide a general solution,
as it banks on the fact that a node never contains two children
(in which case we would have to try both branches).
It works for my input, though, so I figured this was good enough.
Letâ€™s say that tree manipulations are not necessarily my favourite thing to do in an array language.<a href="#fnref25" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn26"><p>Iâ€™m reversing the list because we have to right fold over it later.<a href="#fnref26" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn27"><p>For example,</p>
<pre class="bqn"><code>    DecToHex 15
&quot;0f&quot;
    DecToHex 32
&quot;20&quot;</code></pre>
<a href="#fnref27" class="footnote-back" role="doc-backlink">â†©ï¸</a></li>
<li id="fn28"><p>This is a phenomenal article, btw, definitely give it a read.<a href="#fnref28" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn29"><p>Or <code>âŸ¨0 2âŸ©</code>, depending in which direction your list points.<a href="#fnref29" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn30"><p>Unlike APL, BQNâ€™s <em>repeat</em> operator does not support this out of the box.<a href="#fnref30" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn31"><p>Indeed, <code>utils.bqn</code> just looks like</p>
<pre class="bqn"><code>Split â‡ (Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸&gt;)âˆ˜â‰ âŠ”âŠ¢
_Fix  â‡ { ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½_ğ•£âˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•© }
tab   â‡ @+9
lf    â‡ @+10</code></pre>
<a href="#fnref31" class="footnote-back" role="doc-backlink">â†©ï¸</a></li>
<li id="fn32"><p>That is, the first version of that code, before dzaima told me how to clean it up:</p>
<pre class="bqn"><code>DecToHexâ†{
  ğ•©{ 0ğ•Šn: nâˆ¾Ëœ(2-â‰ n)â¥Š'0';
     xğ•Šn: (âŒŠxÃ·16)ğ•Š(nâˆ¾Ëœ&quot;0123456789abcdef&quot;âŠ‘Ëœ16|x)
  }&quot;&quot;
}</code></pre>
<a href="#fnref32" class="footnote-back" role="doc-backlink">â†©ï¸</a></li>
<li id="fn33"><p>Region <code>8</code> just extends beyond the bounds of the part of the grid that we see and loops back around.<a href="#fnref33" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn34"><p>We canâ€™t just use <code>âŸ¨Â«,Â»,Â«Ë˜,Â»Ë˜âŸ©Â¨&lt;x</code>
because the <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">syntactic role</a> of a list is a subject,
which canâ€™t be applied as a function.<a href="#fnref34" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn35"><p>In that case, using <em>rotate</em> would be more appropriate.<a href="#fnref35" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn36"><p>Notice that <span class="math inline">2147483647 = 2^{31} - 1</span>
so this challenge was doable even for esolangs
that only support signed 32bit integers.
Nice touch.<a href="#fnref36" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn37"><p>My loop happens to start with at 0,
but I donâ€™t know if this is universal across all inputs.<a href="#fnref37" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn38"><p>I suppose inserting <code>i</code> in the back of the array would be cheaper:</p>
<pre class="bqn"><code>Â¯2âŠ‘âŸ¨0âŸ©{ğ•¨âˆ¾Ëœ(-n+1)âŒ½ğ•©}Â´âŒ½1+â†•2017</code></pre>
<p>However, this doesnâ€™t really matter;
we need a different solution for part two either way.<a href="#fnref38" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn39"><p>In fact, since simulating these instructions is so verbose,
the file contains 36 lines of pure code (without comments or empty lines)!
This is not only 15 more lines than the second place, <a href="#day-7">day 7</a>,
but a big anomaly in general;
the average is around 12 lines, and the median is 11:</p>
<pre class="bqn"><code>    ((+Â´Ã·â‰ )â‹ˆ{(âŒŠ2Ã·Ëœâ‰ ğ•©)âŠ‘âˆ¨ğ•©}){â€¢BQN&quot;âŸ¨&quot;âˆ¾ğ•©âˆ¾&quot;âŸ©&quot;}1âŠ‘â€¢SHâŸ¨
      &quot;/bin/sh&quot;
      &quot;-c&quot;
      &quot;tokei -f Â«pathÂ» \
        | awk '{ print $3 }' \
        | head -n-3 | tail -n25&quot;
    âŸ©
âŸ¨ 11.6 11 âŸ©</code></pre>
<a href="#fnref39" class="footnote-back" role="doc-backlink">â†©ï¸</a></li>
<li id="fn40"><p>Foreshadowing.<a href="#fnref40" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn41"><p>This is modulo some shenanigans when <code>0</code> is the first element of the list,
but letâ€™s completely ignore that case for the purposes of this exposition.
Indeed, since we are dealing with a vector of three numbers and the fill element is still <code>0</code>,
this does not affect the actual solution.<a href="#fnref41" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn42"><p>After writing this, I saw that <a href="https://mlochbaum.github.io/bqncrate/">BQNcrate</a> suggests <code>âˆŠâˆ§âˆŠâŒ¾âŒ½</code>,
which should also work for non-sorted lists.<a href="#fnref42" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn43"><p>A version of <code>Split</code> that splits on subarrays would have probably been useful here.
Certainly something to write before this yearâ€™s event.<a href="#fnref43" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn44"><p>Note that this is all under the assumption that <code>k</code> divides <code>n</code>.<a href="#fnref44" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn45"><p>Thereâ€™s a great (apocryphal) anecdote about John von Neumann
shouting at his PhD students because they were writing assembly.
Obviously, this just wasted resources because it was much too high-level,
and they should have written their programs directly in binary instead.
A more civilised age.<a href="#fnref45" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn46"><p>There always seems to be at least one day each year where inspecting oneâ€™s input is the expected way to solve the problem.
Honestly, Iâ€™m not sure what to think of that;
I used to really dislike these days, but this one was unexpectedly fun.
It <em>is</em> a breath of fresh air after over 20 days of solving puzzles, I guess.
However, it also helps that doing these problems â€œout of seasonâ€
is a lot more relaxed than trying to bash out both parts before work every day.<a href="#fnref46" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>

      <!-- Body is included in the above file -->
    </section>
    
</article>
]]></summary>
</entry>

</feed>
