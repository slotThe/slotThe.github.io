<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <meta name="robots" content="noai, noimageai">
    

    
      <title>Change the Insides of an S-Expression in Emacs · Tony Zorman</title>
    

    <!-- https://purecss.io/ -->
    <link rel="stylesheet" type="text/css" href="../css/pure-min.css">
    <link rel="stylesheet" type="text/css" href="../css/skin.css">
    <!-- Default appearance -->
    <link rel="stylesheet" type="text/css" href="../css/colours.css">
    <link rel="stylesheet" type="text/css" href="../css/fonts.css">
    <link rel="stylesheet" type="text/css" href="../css/default.css">
    <!-- Syntax highlighting -->
    <link rel="stylesheet" type="text/css" href="../css/pygments.css">
    <link rel="stylesheet" type="text/css" href="../css/katex.css">
    <!-- Margin and sidenotes -->
    <link rel="stylesheet" type="text/css" href="../css/sidenotes.css">
  </head>

  <body class="pure-skin-solid">
    <div class="pure-g-r">
      <div class="pure-u-1-4">
        <div id="navigation" class="no-print">
          <div class="pure-menu pure-menu-open">
            <a href="../" class="pure-menu-heading menu-title">
              Blog<br>
              <span class="menu-subtitle">Tony Zorman</span>
            </a>
            <ul>
              <li><a href="../posts.html">Posts</a></li>
              <li><a href="../research.html">Research</a></li>
              <li><a href="../free-software.html">Free Software</a></li>
              <li><a href="../about.html">About</a></li>
            </ul>
          </div>
        </div>
        <!-- A table of contents on the left side, but only for screens
             that are big enough -->
         
          <div id="contents-big">
            <p class="mini-header">Contents <a id="up-arrow" href="#">↑</a></p>
            <ul>
<li><a href="#how-it-all-started">How it all started</a></li>
<li><a href="#inside-change-inner">Inside change-inner</a>
<ul>
<li><a href="#puni-to-the-rescue">Puni to the rescue</a></li>
<li><a href="#puni-to-the-rescue-1">Puni to the rescue?</a></li>
</ul></li>
<li><a href="#the-code">The code</a></li>
</ul>
          </div>
         
      </div>
      <div class="pure-u-3-4">
        <div id="content">
          <!-- We want to include the RSS/Atom feed in certain scenarios,
               but this shouldn't mangle the above header title. -->
           
            <h1>Change the Insides of an S-Expression in Emacs</h1>
           

          <article>
    <p class="header">
      
        Posted on 2023-08-26
      
      
        &thinsp;·&thinsp; last modified: 2023-08-29
      
      
        &thinsp;·&thinsp; <span title="1751 words">8 min read</span> &thinsp;·&nbsp;
      
      
        <a title="All pages tagged 'emacs'." href="../tags/emacs.html" rel="tag">emacs</a>
      
    </p>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  <div id="contents">
    <p class="mini-header">Contents</p>
    <ul>
<li><a href="#how-it-all-started">How it all started</a></li>
<li><a href="#inside-change-inner">Inside change-inner</a>
<ul>
<li><a href="#puni-to-the-rescue">Puni to the rescue</a></li>
<li><a href="#puni-to-the-rescue-1">Puni to the rescue?</a></li>
</ul></li>
<li><a href="#the-code">The code</a></li>
</ul>
  </div>

<div>
  <!--
--><label for="sn-0" class="margin-toggle">⊕</label><input type="checkbox" id="sn-0" class="margin-toggle" /><div class="marginnote">The term “S-expression” is not super accurate,
and should be substituted with something like “semantic unit” instead,
as I’m also talking about things that aren’t necessarily S-expressions as Emacs knows them.
I mainly chose the term for brevity, and because it’s hopefully more familiar—and thus less scary—to the reader.</div><!--
-->I have to make a confession:
I have an <a href="https://github.com/emacs-evil/evil">evil</a> past—literally.
Having switched to vanilla Emacs keybindings a while ago,
one thing that I genuinely miss from <em>that time</em> are the <code>ci(</code> and <code>ca(</code> motions,
killing everything in or around the closest encompassing <code>()</code>-environment.
Luckily, the <a href="https://github.com/magnars/change-inner.el">change-inner</a> package provides exactly these commands for Emacs proper.
Unluckily, there are some issues regarding whitespace handling—let’s try to fix that.
<!--more-->
<h2 id="how-it-all-started">How it all started<a href="#how-it-all-started" class="floatleft sec-link">§</a></h2>
<p></p>
After happily using change-inner for a few days,
one of the first problems I ran into
was the package’s flakiness with respect to whitespace.
This is elucidated in, for example,
<a href="https://github.com/magnars/change-inner.el/issues/5">this issue</a>:
<blockquote>
<p></p>
When using change-inner with rust-mode, the following code (with <code>|</code> as the cursor):
<div class="highlight-rust" style="padding-left: 1em;"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">issue_list_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="p">::</span><span class="n">parse</span><span class="p">(</span><span class="o">|</span>
<span class="w">    </span><span class="s">&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;</span>
<span class="w">        </span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
</pre></div>

<p></p>
calling <code>M-x change-inner (</code> gives:
<div class="highlight-rust" style="padding-left: 1em;"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">issue_list_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="p">::</span><span class="n">parse</span><span class="o">|</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
</pre></div>

<p></p>
whereas I would expect:
<div class="highlight-rust" style="padding-left: 1em;"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">issue_list_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="p">::</span><span class="n">parse</span><span class="p">(</span><span class="o">|</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
</pre></div>

<p></p>
It looks like it’s related to newlines. There’s a similar issue in JS:
<div class="highlight-javascript" style="padding-left: 1em;"><pre><span></span><span class="c1">// works here</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span><span class="s2">&quot;baz&quot;</span><span class="p">);</span>

<span class="c1">// error: Couldn't find expansion</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span>
<span class="w">    </span><span class="s2">&quot;baz&quot;</span><span class="p">);</span>
</pre></div>

</blockquote>
<p></p>
Change-inner as a package builds upon another excellent one from the same author:
<a href="https://github.com/magnars/expand-region.el">expand-region</a>,
an “Emacs extension to increase selected region by semantic units.”
Essentially, change-inner just expands the region
until it hits something that it’s happy with.
As such, the problem eluded to above is
with the respective expand-region functions that are called;
specifically, <code>er/mark-inside-pairs</code>,
which is defined like so:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">er/mark-inside-pairs</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;Mark inside pairs (as defined by the mode), not including the pairs.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nv">er--point-inside-pairs-p</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">goto-char</span><span class="w"> </span><span class="p">(</span><span class="nf">nth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nv">syntax-ppss</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">set-mark</span><span class="w"> </span><span class="p">(</span><span class="k">save-excursion</span>
<span class="w">                </span><span class="p">(</span><span class="nf">forward-char</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nf">skip-chars-forward</span><span class="w"> </span><span class="nv">er--space-str</span><span class="p">)</span><span class="w"> </span><span class="c1">; ← HERE</span>
<span class="w">                </span><span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">forward-list</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">backward-char</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">skip-chars-backward</span><span class="w"> </span><span class="nv">er--space-str</span><span class="p">)</span><span class="w">            </span><span class="c1">; ← HERE</span>
<span class="w">    </span><span class="p">(</span><span class="nv">exchange-point-and-mark</span><span class="p">)))</span>
</pre></div>

<p></p>
Notice the invocations of <code>(skip-chars-forward er--space-str)</code>;
if we start with<!--
--><label for="sn-1" class="margin-toggle">⊕</label><input type="checkbox" id="sn-1" class="margin-toggle" /><div class="marginnote">As is common,
I will use <code>|</code>
to indicate the position of the point.</div><!--
-->
<div class="highlight-javascript" style="padding-left: 1em;"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span>
<span class="w">    </span><span class="s2">&quot;baz&quot;</span><span class="p">);</span>
</pre></div>

<p></p>
and run <code>M-x er/mark-inside-pairs RET</code>,
then the marked area will actually just be <code>"baz"</code>,
instead of everything inside of the parentheses.
<p></p>
Mystery solved, right?
Maybe, but having to redefine that function for this package alone
feels wrong to me.
This got me looking into the internals of change-inner,<!--
--><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><div class="sidenote">I wish I hadn’t.</div><!--
-->
in order to see where the problem <em>actually</em> lies.
<h2 id="inside-change-inner">Inside change-inner<a href="#inside-change-inner" class="floatleft sec-link">§</a></h2>
<p></p>
Taking a closer look at <code>change-inner*</code><!--
-->—the internal function doing the actual work—<!--
-->reveals the following.
After some initial book keeping,
the area surrounding the point is expanded,
looking for the innermost expression matching the parameters:<!--
--><label for="sn-3" class="margin-toggle">⊕</label><input type="checkbox" id="sn-3" class="margin-toggle" /><div class="marginnote">󠀠
<p></p>
󠀠
<p></p>
<code>q-char</code> is the char that the user input,
but quoted as a regular expression via <code>regexp-quote</code>.</div><!--
-->
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nv">er--expand-region-1</span><span class="p">)</span>
<span class="p">(</span><span class="nv">er--expand-region-1</span><span class="p">)</span><span class="w">                      </span><span class="c1">; sic!</span>
<span class="p">(</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">=</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">looking-at</span><span class="w"> </span><span class="nv">q-char</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">er--expand-region-1</span><span class="p">))</span>
</pre></div>

<p></p>
Crucially,
the area is expanded twice <em>completely unconditionally</em>.
This stops only
once we’ve reached the bounds of either the buffer,
or the expression we are interested in.
<p></p>
The idea is to start in a situation like this
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;t|wo&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
</pre></div>

<p></p>
and expand until we encompass the whole list<!--
--><label for="sn-4" class="margin-toggle">⊕</label><input type="checkbox" id="sn-4" class="margin-toggle" /><div class="marginnote">󠀠
<p></p>
As you’ve probably already guessed,
the <code>^</code>’s are supposed to signal the marked region.</div><!--
-->
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;t|wo&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
<span class="c1">;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</pre></div>

<p></p>
noting that the previous step was
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;t|wo&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
<span class="c1">;  ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</pre></div>

<p></p>
which equates to the “inner” part of the list.
Then, one can call
<code>er/contract-region</code>,
which relies on an expansion history,
in order to only kill this inner part.
<p></p>
Why expand twice unconditionally?
Because in a situation like
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="ss">'|</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
</pre></div>

<p></p>
The expansion would immediately encompass the whole list,<!--
--><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><div class="sidenote">As in
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="ss">'|</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
<span class="c1">; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</pre></div>
</div><!--
-->
and its innards wouldn’t be available to expand-region’s contraction history.
The “trick” is to actually expand <em>further</em> than necessary;
looping through the <code>while</code> above until one inevitably hits <code>(point-min)</code> and stops expanding.
This triggers yet another bit of code that then recurses with prefilled arguments<!--
--><label for="sn-6" class="margin-toggle">⊕</label><input type="checkbox" id="sn-6" class="margin-toggle" /><div class="marginnote">󠀠
<p></p>
󠀠
<p></p>
<code>search-forward-char</code> is the second argument of <code>change-inner*</code>;
if the function was called with that,
we have already recursed once, so stop.
<code>char</code> is the character that the user actually input.
<code>starting-point</code> is the position of the point before anything happened.</div><!--
-->
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">looking-at</span><span class="w"> </span><span class="nv">q-char</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">search-forward-char</span>
<span class="w">        </span><span class="p">(</span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;Couldn't find any expansion starting with %S&quot;</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">goto-char</span><span class="w"> </span><span class="nv">starting-point</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">mark-active</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">change-inner*</span><span class="w"> </span><span class="nv">yank?</span><span class="w"> </span><span class="nv">char</span><span class="p">))</span>
<span class="w">  </span><span class="c1">;; … else …</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>

<p></p>
During that additional run of the function,
it searches for the correct delimiter via
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nf">search-forward</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="p">(</span><span class="nv">point-at-eol</span><span class="p">))</span>
</pre></div>

<p></p>
and<!--
-->—due to the way that <code>search-forward</code> works by default—<!--
-->we end up with the point directly after the opening delimiter
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="nv">|</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="w"> </span><span class="p">)</span>
</pre></div>

<p></p>
This now expands correctly.<!--
--><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle" /><div class="sidenote">Actually,
the searching also has a different, actual, use.
When in a situation like
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="nv">1|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="s">&quot;this is a string&quot;</span><span class="p">)</span>
</pre></div>

<p></p>
One might want to change the string—indeed,
<code>M-x change-inner "</code> correctly jumps to the string:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="o">'</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="p">)</span>
</pre></div>

<p></p>
This is one of the great features of Vim’s <code>ci"</code>,
and certainly something to preserve.</div><!--
-->
<h3 id="puni-to-the-rescue">Puni to the rescue<a href="#puni-to-the-rescue" class="floatleft sec-link">§</a></h3>
<p></p>
I certainly know what I think of this solution.
Instead of trying to fix this web of expansions and contractions,
how about we rewrite the function instead?
<p></p>
I’ve been happily using <a href="https://github.com/AmaiKinono/puni">puni</a> for a while,
and it seems pretty apt for the job.
Briefly, puni is a structured editing package,
like <a href="https://paredit.org/">paredit</a> or <a href="https://github.com/Fuco1/smartparens">smartparens</a>,
but it works for a broader range of languages than the former,
while comprising of a much smaller code-base<!--
-->—and even fewer language-specific bits—<!--
-->than the latter.<!--
--><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle" /><div class="sidenote">Puni achieves this by relying on Emacs’s built-in functions.</div><!--
-->
While I still prefer paredit for lisps,
puni has become my de facto standard for language-agnostic parenthesis handling.
<p></p>
Luckily for us,
puni already comes equipped with a <code>puni-expand-region</code> function,
so one can swiftly rewrite the core of <code>change-inner*</code> using that instead of <code>er--expand-region-1</code>:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="c1">;; Try to find a region.</span>
<span class="p">(</span><span class="nv">puni-expand-region</span><span class="p">)</span>
<span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">mark</span><span class="p">))</span><span class="w"> </span><span class="c1">; By default, puni jumps to the end of the sexp</span>
<span class="w">  </span><span class="p">(</span><span class="nv">exchange-point-and-mark</span><span class="p">))</span>
<span class="p">(</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">=</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">looking-at</span><span class="w"> </span><span class="nv">q-char</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">puni-expand-region</span><span class="p">))</span>
</pre></div>

<p></p>
Notice that the double expansion vanished!
Instead, when a region was found,
we can make use of <code>puni-bounds-of-list-around-point</code> to get the internals explicitly,
and then calculate how big the delimiters were:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nv">rb</span><span class="w"> </span><span class="p">(</span><span class="nf">region-beginning</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">re</span><span class="w"> </span><span class="p">(</span><span class="nf">region-end</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">insides</span><span class="w"> </span><span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="p">(</span><span class="nf">goto-char</span><span class="w"> </span><span class="p">(</span><span class="nf">1+</span><span class="w"> </span><span class="nv">rb</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="nv">puni-bounds-of-list-around-point</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">olen</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="p">(</span><span class="nf">car</span><span class="w"> </span><span class="nv">insides</span><span class="p">)</span><span class="w"> </span><span class="nv">rb</span><span class="p">))</span><span class="w">  </span><span class="c1">; Length of opening delimiter</span>
<span class="w">       </span><span class="p">(</span><span class="nv">clen</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="nv">re</span><span class="w"> </span><span class="p">(</span><span class="nf">cdr</span><span class="w"> </span><span class="nv">insides</span><span class="p">))))</span><span class="w"> </span><span class="c1">; Length of closing delimiter</span>
<span class="w">  </span><span class="p">(</span><span class="nv">kill-region</span><span class="w"> </span><span class="p">(</span><span class="nf">+</span><span class="w"> </span><span class="nv">rb</span><span class="w"> </span><span class="nv">olen</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="nv">re</span><span class="w"> </span><span class="nv">clen</span><span class="p">)))</span>
</pre></div>

<p></p>
Trying this out with our trusty example of
<div class="highlight-javascript" style="padding-left: 1em;"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span>
<span class="w">    </span><span class="s2">&quot;baz&quot;</span><span class="p">);</span>
</pre></div>

<p></p>
we… are greeted with a type error.
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p nil)
  puni--smaller-interval((103 . 108) (nil . 108))
</pre></div>

<p></p>
Yikes.
<h3 id="puni-to-the-rescue-1">Puni to the rescue?<a href="#puni-to-the-rescue-1" class="floatleft sec-link">§</a></h3>
<p></p>
The <code>puni--smaller-interval</code> function does some comparisons with <code>&lt;=</code>,
and having <code>nil</code> in there will obviously result in a bad time for everyone.
As it turns out, puni <em>also</em> has some problems handling whitespace,
in that it <em>doesn’t</em> skip it.
At some point in <code>puni-expand-region</code>,
we call <code>puni-bounds-of-sexp-at-point</code>,
which tries to find out whether we are at the start or end of an S-expression
by going forwards and backwards a few times:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
<span class="w">  </span><span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">end-forward</span><span class="w"> </span><span class="p">(</span><span class="nv">puni-strict-forward-sexp</span><span class="p">)</span>
<span class="w">        </span><span class="nv">beg-forward</span><span class="w"> </span><span class="p">(</span><span class="nv">puni-strict-backward-sexp</span><span class="p">)))</span>
<span class="p">(</span><span class="k">save-excursion</span>
<span class="w">  </span><span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">beg-backward</span><span class="w"> </span><span class="p">(</span><span class="nv">puni-strict-backward-sexp</span><span class="p">)</span>
<span class="w">        </span><span class="nv">end-backward</span><span class="w"> </span><span class="p">(</span><span class="nv">puni-strict-forward-sexp</span><span class="p">)))</span>
</pre></div>

<p></p>
Now, when we are in a situation like <code>(|   "furble")</code>,
an invocation of <code>puni-strict-forward-sexp</code> will leave us at <code>(   "furble"|)</code>,
but executing <code>puni-strict-backward-sexp</code> after that will result in <code>(   |"furble")</code>—not where we started.
As such, puni will (incorrectly) conclude that we were not at the start of the expression.
<p></p>
One could try to cram some whitespace handling into this,
but who says we don’t run into other issues then?<!--
--><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle" /><div class="sidenote">The real reason,
of course,
is that I just wanted my code to work <em>right now</em>,
instead of having to wait for upstream to fix something.
At some point this should definitely be fixed in puni, though.</div><!--
-->
In fact, <code>puni-expand-region</code> is written in such a way
that it tries out different expansion strategies until one succeeds—why not just quiet the error?
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nv">advice-add</span><span class="w"> </span><span class="ss">'puni-bounds-of-sexp-at-point</span><span class="w"> </span><span class="nb">:around</span>
<span class="w">  </span><span class="p">(</span><span class="nb">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">fun</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">ignore-errors</span><span class="w"> </span><span class="p">(</span><span class="nv">fun</span><span class="p">))))</span>
</pre></div>

<p></p>
This… turns out to work!
<div class="highlight-javascript" style="padding-left: 1em;"><pre><span></span><span class="c1">// before</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span>
<span class="w">    </span><span class="s2">&quot;baz&quot;</span><span class="p">);</span>

<span class="c1">// after</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="o">|</span><span class="p">);</span>
</pre></div>

<p></p>
Phew.
<h2 id="the-code">The code<a href="#the-code" class="floatleft sec-link">§</a></h2>
<p></p>
For anyone interested, here is the full code.
It also includes a <code>mode</code> setting, which can be set to <code>outer</code>,
in order to kill around the parentheses; e.g.,
<div class="highlight-rust" style="padding-left: 1em;"><pre><span></span><span class="c1">// before</span>
<span class="kd">let</span><span class="w"> </span><span class="n">issue_list_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="p">::</span><span class="n">parse</span><span class="p">(</span><span class="o">|</span><span class="s">&quot;https://my-url.com&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="c1">// after</span>
<span class="kd">let</span><span class="w"> </span><span class="n">issue_list_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="p">::</span><span class="n">parse</span><span class="o">|</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
</pre></div>

<p></p>
For obvious reasons,
I will not submit this upstream to change-inner,
but it will instead live in my personal configuration.<!--
--><label for="sn-10" class="margin-toggle">⊕</label><input type="checkbox" id="sn-10" class="margin-toggle" /><div class="marginnote">󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
󠀠
<p></p>
Using a recursive local function also incidentally fixes <a href="https://github.com/magnars/change-inner.el/issues/9">#9</a>.
Nice.</div><!--
-->
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nb">cl-defun</span><span class="w"> </span><span class="nv">slot/change-sexp</span><span class="w"> </span><span class="p">(</span><span class="kp">&amp;key</span><span class="w"> </span><span class="nv">search-for</span><span class="w"> </span><span class="nv">mode</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Delete (the innards of) a sexp.</span>
<span class="s">Takes a char, like ( or \&quot;, and kills the first ancestor semantic</span>
<span class="s">unit starting with that char. The unit must be recognisable to</span>
<span class="ss">`puni'</span><span class="s">.</span>

<span class="s">SEARCH-FOR is the opening delimiter to search for: if this is</span>
<span class="s">nil, prompt for one. MODE is whether to kill the whole</span>
<span class="s">region (</span><span class="ss">`outer'</span><span class="s">), or just the innards of it (any other value,</span>
<span class="s">including nil).&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nb">cl-labels</span>
<span class="w">      </span><span class="p">((</span><span class="nv">expand</span><span class="w"> </span><span class="p">(</span><span class="nv">char</span><span class="w"> </span><span class="kp">&amp;optional</span><span class="w"> </span><span class="nv">forward</span><span class="p">)</span>
<span class="w">         </span><span class="s">&quot;Expand until we encompass the whole expression.&quot;</span>
<span class="w">         </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nv">char</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">char</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">char-to-string</span>
<span class="w">                           </span><span class="p">(</span><span class="nf">read-char</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">&quot;Kill %s:&quot;</span>
<span class="w">                                              </span><span class="p">(</span><span class="nf">symbol-name</span>
<span class="w">                                               </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">mode</span><span class="w"> </span><span class="ss">'inner</span><span class="p">)))))))</span>
<span class="w">                </span><span class="p">(</span><span class="nv">q-char</span><span class="w"> </span><span class="p">(</span><span class="nf">regexp-quote</span><span class="w"> </span><span class="nv">char</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="nv">starting-point</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
<span class="w">           </span><span class="c1">;; Try to find a region.</span>
<span class="w">           </span><span class="p">(</span><span class="nv">puni-expand-region</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nf">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">mark</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nv">exchange-point-and-mark</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">=</span><span class="w"> </span><span class="p">(</span><span class="nf">point</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
<span class="w">                       </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">looking-at</span><span class="w"> </span><span class="nv">q-char</span><span class="p">)))</span>
<span class="w">             </span><span class="p">(</span><span class="nv">puni-expand-region</span><span class="p">))</span>
<span class="w">           </span><span class="c1">;; If we haven't found one yet, initiate a forward search and</span>
<span class="w">           </span><span class="c1">;; try again—once.</span>
<span class="w">           </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nv">not</span><span class="w"> </span><span class="p">(</span><span class="nf">looking-at</span><span class="w"> </span><span class="nv">q-char</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">goto-char</span><span class="w"> </span><span class="nv">starting-point</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nv">deactivate-mark</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">forward</span>
<span class="w">                 </span><span class="p">(</span><span class="ne">error</span><span class="w"> </span><span class="s">&quot;Couldn't find any expansion starting with %S&quot;</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nf">search-forward</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="p">(</span><span class="nv">pos-eol</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nv">expand</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="ss">'forward</span><span class="p">))))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">expand</span><span class="w"> </span><span class="nv">search-for</span><span class="p">)</span>
<span class="w">    </span><span class="c1">;; Now that we have a region, decide what to do with it.</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">rb</span><span class="w"> </span><span class="p">(</span><span class="nf">region-beginning</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">re</span><span class="w"> </span><span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">eq</span><span class="w"> </span><span class="nv">mode</span><span class="w"> </span><span class="ss">'outer</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">kill-region</span><span class="w"> </span><span class="nv">rb</span><span class="w"> </span><span class="nv">re</span><span class="p">)</span><span class="w">           </span><span class="c1">; Kill everything</span>
<span class="w">        </span><span class="c1">;; If we want to delete inside the expression, fall back to `puni'.</span>
<span class="w">        </span><span class="c1">;; This circumvents having to call `er--expand-region-1' and then</span>
<span class="w">        </span><span class="c1">;; `er/contract-region' in some vaguely sensical order, and hoping</span>
<span class="w">        </span><span class="c1">;; to recover the inner expansion from that.</span>
<span class="w">        </span><span class="c1">;; Addresses ghub:magnars/change-inner.el#5</span>
<span class="w">        </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nv">insides</span><span class="w"> </span><span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="p">(</span><span class="nf">goto-char</span><span class="w"> </span><span class="p">(</span><span class="nf">1+</span><span class="w"> </span><span class="nv">rb</span><span class="p">))</span>
<span class="w">                               </span><span class="p">(</span><span class="nv">puni-bounds-of-list-around-point</span><span class="p">)))</span>
<span class="w">               </span><span class="p">(</span><span class="nv">olen</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="p">(</span><span class="nf">car</span><span class="w"> </span><span class="nv">insides</span><span class="p">)</span><span class="w"> </span><span class="nv">rb</span><span class="p">))</span><span class="w"> </span><span class="c1">; Length of opening delimiter</span>
<span class="w">               </span><span class="p">(</span><span class="nv">clen</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="nv">re</span><span class="w"> </span><span class="p">(</span><span class="nf">cdr</span><span class="w"> </span><span class="nv">insides</span><span class="p">))))</span><span class="w"> </span><span class="c1">; Length of closing delimiter</span>
<span class="w">          </span><span class="p">(</span><span class="nv">kill-region</span><span class="w"> </span><span class="p">(</span><span class="nf">+</span><span class="w"> </span><span class="nv">rb</span><span class="w"> </span><span class="nv">olen</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-</span><span class="w"> </span><span class="nv">re</span><span class="w"> </span><span class="nv">clen</span><span class="p">)))))))</span>
</pre></div>

<p></p>
One can bind killing the innards to <code>M-i</code>,
and killing everything to <code>M-o</code>,
as change-inner suggests.
Alternatively, and this is what I do,<!--
--><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle" /><div class="sidenote"><code>M-o</code> will never be something other than <code>other-window</code>.</div><!--
-->
a second small helper function is swiftly written,
such that only one keybinding is needed:
<div class="highlight-emacs-lisp" style="padding-left: 1em;"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">slot/change-around</span><span class="w"> </span><span class="p">(</span><span class="kp">&amp;optional</span><span class="w"> </span><span class="nv">arg</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">interactive</span><span class="w"> </span><span class="s">&quot;P&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">arg</span>
<span class="w">      </span><span class="p">(</span><span class="nv">slot/change-sexp</span><span class="w"> </span><span class="nb">:mode</span><span class="w"> </span><span class="ss">'outer</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">slot/change-sexp</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">bind-key</span><span class="w"> </span><span class="s">&quot;M-i&quot;</span><span class="w"> </span><span class="nf">#'</span><span class="nv">slot/change-around</span><span class="p">)</span>
</pre></div>

</div>

      <!-- Body is included in the above file -->
    </section>
    
      <!-- A footer-ish thing above the actual boring footer for pretty
           fleurons and things that should only appear on posts. -->
      <div style="text-align:center;">
        <img class="center-block-dark" src="../images/fleuron-dark.svg" style="max-width: 3cm" alt="End of post fleuron">
        <img class="center-block-light" src="../images/fleuron.svg" style="max-width: 3cm" alt="End of post fleuron">
        Have a comment? Write me an <a href="../about.html">email!</a>
      </div>
    
</article>


        </div>
        <div id="footer">
          <!-- Left -->
          <a id="to-top" href="#">top</a>
          <!-- Right -->
          <a href="../atom.xml" style="font-variant:small-caps">rss</a>
          &nbsp;|&nbsp;
          <a href="https://github.com/slotThe/slotThe.github.io">Website source</a>
          &nbsp;|&nbsp;
          <a href="../impressum.html">Legal notice and privacy policy</a>
        </div>
      </div>
    </div>
  </body>
</html>
