<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
      <meta name="robots" content="noai, noimageai">
    

    
      <title>BQNing Advent of Code · Tony Zorman</title>
    

    <link rel="shortcut icon" href="../favicon.png">
    <!-- https://purecss.io/ -->
    <link rel="stylesheet" type="text/css" href="../css/pure-min.css" />
    <link rel="stylesheet" type="text/css" href="../css/skin.css" />
    <!-- Default appearance -->
    <link rel="stylesheet" type="text/css" href="../css/colours.css" />
    <link rel="stylesheet" type="text/css" href="../css/fonts.css" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <!-- Syntax highlighting -->
    <link rel="stylesheet" type="text/css" href="../css/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../css/katex.css" />
    <!-- Margin and sidenotes -->
    <link rel="stylesheet" type="text/css" href="../css/sidenotes.css" />
  </head>

  <body class="pure-skin-solid">
    <div class="pure-g-r">
      <div class="pure-u-1-4">
        <div id="navigation" class="no-print">
          <div class="pure-menu pure-menu-open">
            <a href="../" class="pure-menu-heading menu-title">
              Blog<br>
              <span class="menu-subtitle">Tony Zorman</span>
            </a>
            <ul>
              <li><a href="../posts.html">Posts</a></li>
              <li><a href="../research.html">Research</a></li>
              <li><a href="../free-software.html">Free Software</a></li>
              <li><a href="../about.html">About</a></li>
            </ul>
          </div>
        </div>
        <!-- A table of contents on the left side, but only for screens
             that are big enough -->
         
          <div id="contents-big">
            <p class="mini-header">Contents <a id="up-arrow" href="#">↑</a></p>
            <ul>
<li><a href="#the-setup">The setup</a></li>
<li><a href="#a-crash-course-on-syntax">A crash course on syntax</a></li>
<li><a href="#days-15">Days 1–5</a></li>
<li><a href="#days-610">Days 6–10</a></li>
<li><a href="#days-1115">Days 11–15</a></li>
<li><a href="#days-1620">Days 16–20</a></li>
<li><a href="#days-2125">Days 21–25</a></li>
</ul>
          </div>
         
      </div>
      <div class="pure-u-3-4">
        <div id="content">
          <!-- We want to include the RSS/Atom feed in certain scenarios,
               but this shouldn't mangle the above header title. -->
           
            <h1>BQNing Advent of Code</h1>
           

          <article>
    <p class="header">
      
        Posted on 2024-10-27
      
      
        &thinsp;·&thinsp; last modified: 2024-10-28
      
      
        &thinsp;·&thinsp; <span title="22191 words">89 min read</span> &thinsp;·&nbsp;
      
      
        <a title="All pages tagged 'BQN'." href="../tags/BQN.html" rel="tag">BQN</a>
      
    </p>
    <section>
      <!-- A table of contents inline in the text, in case the screen is
           too small for the one in the `default.html' template -->
      <!-- A table of contents inline in the text, in case the screen is too
     small for the one in the `default.html' template -->

  <div id="contents">
    <p class="mini-header">Contents</p>
    <ul>
<li><a href="#the-setup">The setup</a></li>
<li><a href="#a-crash-course-on-syntax">A crash course on syntax</a></li>
<li><a href="#days-15">Days 1–5</a></li>
<li><a href="#days-610">Days 6–10</a></li>
<li><a href="#days-1115">Days 11–15</a></li>
<li><a href="#days-1620">Days 16–20</a></li>
<li><a href="#days-2125">Days 21–25</a></li>
</ul>
  </div>

<div>
  I did all of Advent of Code 2017 in <span class="small-caps">bqn</span> so you don’t have to.
Let me tell you about that in as few as 20’000 words.<!--
--><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><div class="sidenote">If you’re impatient, I think I had the most fun on days
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-8" class="local-link">8</a>,
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-14" class="local-link">14</a>,
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-17" class="local-link">17</a>, and
<a href="https://tony-zorman.com/posts/aoc-in-bqn.html#day-21" class="local-link">21</a>.</div><!--
-->
<!--more-->
<h2 id="the-setup">The setup<a href="#the-setup" class="floatleft sec-link">§</a></h2>
<p></p>
Advent of Code is a yearly puzzle-coding-challenge-thing,
in which one has to solve two riddles every day from the 1st until the 25th of December,
with the second part of each puzzle being unknown until one solves the first one.
I’ve found it to be a great way to learn the basics of a language—how it “feels”.
<p></p>
The puzzles are accompanied by an endearing—and at times pretty funny—story.
I will, however, leave out most of it for this post,
as I feel like it would distract too much from the point I’m trying to make.
<h3 id="conventions-throughout-the-article">Conventions throughout the article<a href="#conventions-throughout-the-article" class="floatleft sec-link">§</a></h3>
<p></p>
One thing I will not leave out is the full solution for every day.
Normally this would result in a rather large amount of code having to be shown for the later days,
but <span class="small-caps">bqn</span>’s terseness saves us here:
excluding comments and empty lines, all days combined are just under 300 lines of code!
I will be a tiny bit economical with the different parts, though;
think of every heading as introducing its own namespace.
For example,
in the code block solving the first part of every day I will generally include parsing the input.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="err">…</span>
<span class="c1"># Hypothetical solution for first part</span>
<span class="nv">inp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span>
</pre></div>

<p></p>
The second part will then freely refer to <code>inp</code> without me having to define it again.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="c1"># Second part</span>
<span class="nv">inp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span>
</pre></div>

<h3 id="who-reads-all-of-this-anyways">Who reads all of this anyways?<a href="#who-reads-all-of-this-anyways" class="floatleft sec-link">§</a></h3>
<p></p>
A surprisingly hard question is who this article is for.
Someone new to Advent of Code, but familiar with <span class="small-caps">bqn</span>?
The other way around?
New to both?
Familiar with both?
The answer—as is so often the case—is that I don’t know.
Realistically, I’m actually talking to my present and future self here<!--
-->—writing about things is a great way to solidify understanding—<!--
-->so the article will be structured accordingly:
I will talk about <span class="small-caps">bqn</span>’s core concepts and language features,
but put the more dreary parts of that exposition in collapsible boxes,
for people who either already know, or don’t care.
<p></p>
Keep in mind that I started solving these puzzles to learn the language.
Further, <span class="small-caps">bqn</span> is my very first array programming language,<!--
--><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><div class="sidenote">I flirted with <span class="small-caps">apl</span> for about a week before picking up <span class="small-caps">bqn</span>,
but the dialect that everyone seems to use is Dyalog <span class="small-caps">apl</span>,
and I didn’t have the guts to commit to a proprietary language implementation.</div><!--
-->
so my understanding of a lot of concepts is still quite shallow.
The official documentation is really quite good, so I will link to it a lot.
As mentioned, the tangents in which I talk about language features are more for my own understanding.
Still, perhaps they are useful in case someone who does not know <span class="small-caps">bqn</span> has somehow found their way here,
and didn’t run away after seeing the Unicode characters.
As such, the focus of this post should be on how I<!--
-->—as a total newcomer to this kind of thing—<!--
-->approach solving problems in such an unusual language;
what works and what doesn’t, that kind of thing.
In short, I want to impart the <em>vibe</em> of the language to the reader<!--
-->—and that <span class="small-caps">aoc</span> is actually a lot of fun!<!--
--><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><div class="sidenote">This sentence is also true for the axiom of choice;
jokes on you, constructivists!</div><!--
-->
<h3 id="acknowledgements">Acknowledgements<a href="#acknowledgements" class="floatleft sec-link">§</a></h3>
<p></p>
I want to explicitly thank the super welcoming
<a href="https://mlochbaum.github.io/BQN/community/index.html">community</a>
that this language has!
Next to fantastic sites such as <a href="https://mlochbaum.github.io/bqncrate/"><span class="small-caps">bqn</span>crate</a><!--
-->—a great way to pick up on idiomatic ways to write certain things—<!--
-->there is a
<a href="https://app.element.io/#/room/%23bqn:matrix.org">#bqn:matrix.org</a>
matrix room, which is part of the larger
<a href="https://app.element.io/#/room/%23array:matrix.org">#array:matrix.org</a> space.
Someone knowledgeable is always there to answer your stupid questions.
Special thank to
Marshall Lochbaum (the creator of the language!),
dzaima, and
brian_e.
Without them a lot of solutions presented here would be even uglier than they already are.
A separate big thanks goes out to dzaima (again!)
for sending me lots of code improvements and suggestions for this post.
<h2 id="a-crash-course-on-syntax">A crash course on syntax<a href="#a-crash-course-on-syntax" class="floatleft sec-link">§</a></h2>
<p></p>
Here is an entirely too short crash course on the syntax of the language,
with a bit of semantics sprinkled in here and there.
Throughout, I will present most examples in a <span class="small-caps">repl</span>-esque fashion;
input is indented by 4 spaces, and output is flush to the left.
Line comments in <span class="small-caps">bqn</span> start with <code>#</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">1</span><span class="o">+</span><span class="m">4</span><span class="o">+</span><span class="m">6</span><span class="w"> </span><span class="c1"># Everything normal so far…</span>
<span class="m">11</span>
<span class="w">    </span><span class="m">2</span><span class="o">×</span><span class="m">4</span><span class="o">+</span><span class="m">6</span><span class="w"> </span><span class="c1"># …but actually not!</span>
<span class="m">20</span>
</pre></div>

<p></p>
That last one probably already needs explanation.
First, multiplication is <code>×</code>, instead of <code>*</code> as in most other languages.
More importantly, however: there is no precedence for mathematical operators!
<span class="small-caps">bqn</span> is evaluated (strictly) from right to left,
and most of the time this is also the direction you should read expressions in.
<p></p>
Assigning values to variables works with <em>define</em> (<code>←</code>):
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">v</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">2</span><span class="o">×</span><span class="m">4</span><span class="o">+</span><span class="m">6</span>
<span class="m">20</span>
</pre></div>

<p></p>
A block is something in between curly braces,
containing several assignments and expressions separated by line breaks, or, alternatively, the <code>⋄</code> character.
Further, a block starts its own <a href="https://mlochbaum.github.io/BQN/doc/namespace.html">namespace</a>;
nothing all that surprising coming from almost any other language.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">v</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">2</span><span class="o">×</span><span class="m">4</span><span class="o">+</span><span class="m">6</span>
<span class="m">20</span>
<span class="w">    </span><span class="kt">{</span><span class="nv">v</span><span class="kd">←</span><span class="m">0</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">v</span><span class="kt">}</span>
<span class="m">0</span>
<span class="w">    </span><span class="nv">v</span>
<span class="m">20</span>
</pre></div>

<p></p>
I will talk a little bit more about namespaces later,
but let’s not get too hung up on that right now.
Instead, let’s talk about functions.
A user-defined function is something in curly braces that mentions the special names <code>𝕨</code> and <code>𝕩</code>,
standing in for the left and right argument to it.<!--
--><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><div class="sidenote">Depending on your font, <code>𝕨</code> and <code>𝕩</code> might not look so different from <code>w</code> and <code>x</code>:
the former really are the blackboard bold variants of the respective letters.</div><!--
-->
Functions are always infix, and can only be called with either one or two arguments.
In the former case, the function takes its argument on the right and <code>𝕨</code> will be given a special value:
<em>nothing</em> (<a href="https://mlochbaum.github.io/BQN/doc/expression.html#nothing"><code>·</code></a>)!.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕨</span><span class="o">+</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">2</span>
<span class="m">3</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕨</span><span class="o">-</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">2</span>
<span class="m">¯1</span>
<span class="w">    </span><span class="m">2</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕨</span><span class="o">⋆</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">8</span><span class="w">  </span><span class="c1"># Careful: exponentiation!</span>
<span class="m">256</span>
<span class="w">    </span><span class="kt">{</span><span class="o">√</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">9</span><span class="w">     </span><span class="c1"># Could also just write √9</span>
<span class="m">3</span>
</pre></div>

<p></p>
I should note that the <code>⋆</code> above is the Unicode code point <code>0x22C6</code> (STAR OPERATOR),
and not just a normal asterisk.
<p></p>
Because Greek is much cooler than Latin,
<span class="small-caps">bqn</span> calls functions taking one argument <em>monadic</em>,<!--
--><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><div class="sidenote">No relation.</div><!--
-->
and ones taking two arguments <em>dyadic</em>.
When in doubt, just substitute “unary” and “binary” in your head.
One thing that might seem very confusing at the start is that
many functions are actually overloaded depending on whether they are called monadically or dyadically<!--
-->—often with seemingly unrelated (or only barely so) functions!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="c1"># Dyadic ×; N.b. we use the upper minus ¯ here because ¯2 is its own</span>
<span class="w">    </span><span class="c1"># number literal. We could also use the function -, but then (because</span>
<span class="w">    </span><span class="c1"># remember everything is evaluated right to left) we would have to</span>
<span class="w">    </span><span class="c1"># use parentheses: (-2)×4. Otherwise, the expression would be parsed</span>
<span class="w">    </span><span class="c1"># as -(2×4).</span>
<span class="w">    </span><span class="m">¯2</span><span class="o">×</span><span class="m">4</span>
<span class="m">¯8</span>
<span class="w">    </span><span class="o">×</span><span class="m">¯2</span><span class="w"> </span><span class="c1"># Monadic × is the signum function!</span>
<span class="m">¯1</span>
<span class="w">    </span><span class="o">×</span><span class="m">2</span>
<span class="m">1</span>
<span class="w">    </span><span class="o">×</span><span class="m">0</span>
<span class="m">0</span>
</pre></div>

<p></p>
The signum function hints at a fundamental design decision that basically all array languages share:
instead of a name,
all builtin functions are given a unique symbol.
However, the documentation of each of them does mention a pronounceable name as well,
so that it’s easier to talk to other people about a given piece of code.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">↕</span><span class="m">9</span><span class="w">                 </span><span class="c1"># Monadic ↕: Range. Gives you the integer range [0, 𝕩-1].</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="m">7</span><span class="o">↕</span><span class="sr">(</span><span class="o">↕</span><span class="m">9</span><span class="sr">)</span><span class="w">             </span><span class="c1"># Dyadic ↕: Windows. Create all windows of size 𝕨 in 𝕩.</span>
<span class="w">                       </span><span class="c1"># N.b: the parentheses are not technically needed.</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span>
<span class="w">  </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">                </span><span class="err">┘</span>
</pre></div>

<p></p>
In particular, the above examples showcase how <span class="small-caps">bqn</span> displays <em>vectors</em> (or <em>lists</em>) and <em>arrays</em>.
Definitionally, vectors are “rank 1 arrays”—we will talk about what exactly this means when we talk about major cells.<!--
--><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><div class="sidenote">Perhaps it is unwise to postpone actually talking about arrays in an array language,
but I feel like if this gets even longer I will lose the one reader who gets this far.</div><!--
-->
We can define our own arrays in a few different ways,
the two most important ones being
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># Using list notation</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="m">1</span><span class="p">‿</span><span class="m">2</span><span class="p">‿</span><span class="m">3</span><span class="p">‿</span><span class="m">4</span><span class="w">   </span><span class="c1"># Using strand notation</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Here’s another example of monadic and dyadic uses of functions:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">r</span><span class="kd">←</span><span class="o">↕</span><span class="m">9</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">⌽</span><span class="nv">r</span><span class="w">                 </span><span class="c1"># Monadic ⌽: Reverse.</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="m">3</span><span class="o">⌽</span><span class="nv">r</span><span class="w">                </span><span class="c1"># Dyadic ⌽: Rotate. Rotates 𝕩 by 𝕨 places to the</span>
<span class="w">                       </span><span class="c1"># left (to the right if 𝕨 is negative).</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
This takes some time getting used to.
However, after a while you really start to think that
<a href="https://dl.acm.org/doi/pdf/10.1145/1283920.1283935">notation as a tool for thought</a>
has a point.<!--
--><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle" /><div class="sidenote">Beyond the headline that is;
the fact that notation influences one’s thoughts seems obviously true to me.
Please indulge me for a second (or don’t and go back to the main text) and let me derail this post about <span class="small-caps">bqn</span> with maths.
There is an abundance of different notations one might use to talk about Hopf-ish objects in monoidal categories.
Don’t worry about actually understanding the maths, btw, just look at the notation.
Suppose we have maps
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>H</mi><mo>⊗</mo><mi>H</mi><mo>⟶</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\mu \colon H \otimes H \longrightarrow H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>H</mi><mo>⟶</mo><mi>H</mi><mo>⊗</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\Delta\colon H \longrightarrow H \otimes H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord">Δ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>H</mi><mo>⟶</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">S\colon  H\longrightarrow H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>H</mi><mo>⟶</mo><mi mathvariant="double-struck">k</mi></mrow><annotation encoding="application/x-tex">\varepsilon \colon H \longrightarrow \Bbbk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">ε</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">k</span></span></span></span>, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∈</mo><msub><mrow><mi mathvariant="sans-serif">V</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">t</mi></mrow><mi mathvariant="double-struck">k</mi></msub></mrow><annotation encoding="application/x-tex">H \in \mathsf{Vect}_{\Bbbk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">Vect</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3322em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.
Assume that this map satisfies
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>μ</mi><mo>∘</mo><mo stretchy="false">(</mo><mi>S</mi><mo>⊗</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mo>∘</mo><mi mathvariant="normal">Δ</mi><mo>=</mo><mi>η</mi><mo>∘</mo><mi>ε</mi><mo>=</mo><mi>μ</mi><mo>∘</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>⊗</mo><mi>S</mi><mo stretchy="false">)</mo><mo>∘</mo><mi mathvariant="normal">Δ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mu \circ (S \otimes \mathrm{id}) \circ \Delta        = \eta \circ \varepsilon        = \mu \circ (\mathrm{id} \otimes S) \circ \Delta.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ.</span></span></span></span></span>
First of all, notice how there are already lots of notational decisions that could have been written up differently!
One might omit all of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span>’s, and just write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>S</mi><mo>⊗</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\mu(S \otimes \mathrm{id})\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mord">Δ</span></span></span></span>,
or highlight the symmetry between two of the maps and write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∇</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span>.
<p></p>
Even more extreme, however, are the following alternative ways of writing the same equation.
One might also express it
<ul>
<li>in <em>Sweedler notation</em> by
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>ε</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mn>1</mn><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msub><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">S(a_{(1)})a_{(2)} = \varepsilon(a) 1 =  S(a_{(1)})a_{(2)};</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ε</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mpunct">;</span></span></span></span></span></li>
<li>with <em>commutative diagrams</em>:
<img class="pure-img" src="../images/bqn-aoc/commutative-diagram.png" alt="A commutative diagram for the above equation.">
and</li>
<li>with <em>string diagrams</em>:
<img class="pure-img" src="../images/bqn-aoc/string-diagram.png" alt="A string diagram for the above equation."></li>
</ul>
<p></p>
Needless to say, these all look <em>vastly</em> different,
each—in my opinion—enabling a certain mode of thought better than the others.
For example, I happen to like the string diagrammatic version the best,
and try to use it as often as possible.
However, try doing that when you have to juggle 10+ strings!
At that point, Sweedler notation becomes extremely concise and much easier to reason about.
<p></p>
Let’s get back to that array programming thing, though.</div><!--
-->
I believe <span class="small-caps">bqn</span>’s creator once called the syntax “scribbles on a whiteboard”, and honestly that’s my feeling about it too<!--
-->—with the slight addendum that blackboards are obviously vastly superior to whiteboards.
<p></p>
One more piece of syntax that we have to discuss before diving into day 1: modifiers.
These are <em>things</em> that take either one or two functions, and spit out a new, modified, one.
I would imagine that this comes from the <span class="small-caps">apl</span> tradition and is actually not strictly needed,
given that <span class="small-caps">bqn</span> supports <a href="https://mlochbaum.github.io/BQN/doc/functional.html">higher order functions</a>.
However, since these things have their own precedence and binding rules, the separate concept may nonetheless be useful.
<p></p>
We can write our own modifiers by using <code>𝔽</code> and <code>𝔾</code> inside of a block,
but for most of this article we will only use the builtin ones.
Monadic modifiers take their function argument <em>to the left</em>,
and are not called monadic any longer,
but 1-modifiers.
Likewise, modifiers taking two functions are called 2-modifiers.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">3</span><span class="w">  </span><span class="c1"># Normal subtraction</span>
<span class="m">¯2</span>

<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="na">˜</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="c1"># ˜ is the *flip* or *swap* 1-modifier:</span>
<span class="w">           </span><span class="c1"># it takes a dyadic function and returns</span>
<span class="w">           </span><span class="c1"># one with its arguments flipped.</span>
<span class="m">2</span>
<span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span>
<span class="m">2</span>

<span class="w">    </span><span class="o">-</span><span class="na">˜</span><span class="w"> </span><span class="m">3</span><span class="w">  </span><span class="c1"># If a flipped function is called with</span>
<span class="w">          </span><span class="c1"># only one argument, it gets duplicated.</span>
<span class="m">0</span>
<span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">3</span>
<span class="m">0</span>

<span class="w">    </span><span class="kt">{</span><span class="ni">𝕩</span><span class="o">+</span><span class="m">1</span><span class="kt">}</span><span class="py">∘</span><span class="kt">{</span><span class="ni">𝕩</span><span class="o">-</span><span class="m">3</span><span class="kt">}</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="c1"># ∘ is the function composition 2-modifier called *atop*.</span>
<span class="w">                  </span><span class="c1"># Called monatically, 𝔽∘𝔾 𝕩 is just 𝔽𝔾𝕩</span>
<span class="m">2</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕩</span><span class="o">+</span><span class="m">1</span><span class="kt">}</span><span class="py">∘</span><span class="kt">{</span><span class="ni">𝕩</span><span class="o">-</span><span class="ni">𝕨</span><span class="kt">}</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="c1"># Called dyadically, 𝕨 𝔽∘𝔾 𝕩 transforms to 𝔽(𝕨𝔾𝕩)</span>
<span class="m">4</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="o">+</span><span class="py">⟜</span><span class="m">1</span><span class="py">∘</span><span class="o">-</span><span class="w"> </span><span class="m">4</span><span class="w">     </span><span class="c1"># ⟜ is *after*: 𝔽⟜𝔾 𝕩 evaluates to 𝕩𝔽(𝔾𝕩).</span>
<span class="w">                  </span><span class="c1"># If a constant or variable is given as 𝔽 or 𝔾,</span>
<span class="w">                  </span><span class="c1"># it is promoted to its constant function.</span>
<span class="w">                  </span><span class="c1"># The whole expression associates as 1 (+⟜1)∘- 4,</span>
<span class="w">                  </span><span class="c1"># and so evaluates to (+⟜1) (1-4) = (1-4)+1.</span>
<span class="m">¯2</span>
</pre></div>

<p></p>
Besides this being quite a lot to take in,
you might have already noticed something strange in the last example:
how come <code>+⟜1∘-</code> is parsed like <code>(+⟜1)∘-</code> when I previously said everything is evaluated right to left?
While there are no precedence rules among functions or among modifiers,
the latter does <a href="https://mlochbaum.github.io/BQN/doc/syntax.html#precedence">bind tighter</a> than the former.
Additionally, modifiers associate left to right, instead of right to left:
given functions <code>F</code>, <code>G</code>, and <code>H</code>, then <code>F∘G∘H</code> is parsed as <code>(F∘G)∘H</code> instead of <code>F∘(G∘H)</code>.
As you can imagine, getting used to reading <span class="small-caps">bqn</span> expressions takes quite some time.
It gets better, though, I promise.
<p></p>
Something to ease the pain:
there is a purely syntactic way to decide whether a given symbol is a (builtin) function, 1-, or 2-modifier!<!--
--><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle" /><div class="sidenote">This is actually also true for the respective user-defined analogues,
but let’s talk about <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">that</a> later.</div><!--
-->
Thankfully, someone thought about this, and there is a consistent morphology to the chosen symbols:
<ul>
<li>1-modifiers are always superscripts;</li>
<li>2-modifiers always contain an <em>unbroken</em> circle; and</li>
<li>everything else is a function.</li>
</ul>
<p></p>
For example, <code>× + - ⋆ ⌽ ⍉ ⊔ ≢</code> are functions (remember the unbroken part),
<code>˘ ¨ ⁼ ´</code> are 1-modifiers,
and <code>∘ ⍟ ⚇ ◶ ⌾</code> are 2-modifiers.
Quite neat, I think.
<p></p>
This should be plenty to get a feeling for the language.
Anything more will be introduced as needed.<!--
--><label for="sn-8" class="margin-toggle">⊕</label><input type="checkbox" id="sn-8" class="margin-toggle" /><div class="marginnote">The grouping of days is mostly done so the <span class="small-caps">toc</span> doesn’t completely explode,
while retaining some sort of directional aid.
In either case, it’s probably fastest to just <code>C-f</code> for the respective day.</div><!--
-->
<h2 id="days-15">Days 1–5<a href="#days-15" class="floatleft sec-link">§</a></h2>
<h3 id="day-1"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day01.bqn">Day 1</a><a href="#day-1" class="floatleft sec-link">§</a></h3>
<p></p>
Let’s get into the swing of things!
Day 1 starts with us getting sucked into Santa’s computer,
where we have to solve a captcha, proving we’re not human.
<p></p>
For part one,
we are given a (circular) list of numbers,
and are asked to identify repeating digits, starting from the beginning
(i.e., all digits that match the next element).
For example, in <code>311223</code> this would be <code>1</code>, <code>2</code>, and <code>3</code> (in that order).
Our input is a long string of digits
that we first have to convert to a long string of numbers:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="s1">'0'</span><span class="o">-</span><span class="na">˜</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day01.txt&quot;</span>
</pre></div>

<p></p>
Reading the input line-by-line and converting it to a vector works via the builtin <code>•FLines</code> function.<!--
--><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle" /><div class="sidenote">The <code>•</code> is not a separate function, but really part of the name <code>•FLines</code>.
All names starting with that symbol are [system values]—<!--
   -->things provided by the <span class="small-caps">bqn</span> interpreter that are not the builtin primitives.
We will see other important system values, like <code>•HashMap</code> or <code>•Type</code>, a bit later.</div><!--
-->
The only other function we haven’t see so far is
<em>first</em> <a href="https://mlochbaum.github.io/BQN/doc/pick.html"><code>⊑</code></a>,
which gives us the first element in the list—our input is on a single long line.
Much more interesting is the <code>'0'-˜</code> part,
which immediately gives me a chance to talk about character–number conversions in <span class="small-caps">bqn</span>.
<details>
<summary>
Affine characters in <span class="small-caps">bqn</span>
</summary>
<p></p>
The <a href="https://mlochbaum.github.io/BQN/tutorial/expression.html#character-arithmetic">documentation</a>
says that characters form an affine space;
this is not technically true, but a good guide on what kinds of operations we have access to:<!--
--><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle" /><div class="sidenote">There are many definitions of affine space, here is a simple one:
an <em>affine space</em> comprises a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and a vector space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>,
such that the underlying abelian group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> acts freely and transitively on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.
In our specific case, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> would be the set of “numeric Unicode codepoints”,
and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is the field of “numbers”.
<p></p>
The latter is where this falls quite flat;
even leaving aside all the “floating points are evil” rhetoric,
we can actually only act on a character with an integer.
Now, ℤ is just a ring, not a field, and has no hope of being a vector space over any field.
Rather, one should talk about characters forming an affine <em>module</em> over ℤ,
which would at least be a bit more formal.
I swear I will stop with the maths at some point.</div><!--
-->
<ol type="1">
<li><p></p>

<code>(+) : Num  → Char → Char</code>, adding a number to a character gives a character:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">97</span><span class="o">+</span><span class="ss">@</span><span class="w">   </span><span class="c1"># @ is the literal &quot;null&quot; character;</span>
<span class="w">           </span><span class="c1"># i.e., '\0' in most other languages.</span>
<span class="s1">'a'</span>
</pre></div>
</li>
<li><p></p>

<code>(-) : Char → Num  → Char</code>, subtracting a number from a character gives a character:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">'a'</span><span class="o">-</span><span class="m">32</span>
<span class="s1">'A'</span>
</pre></div>
</li>
<li><p></p>

<code>(-) : Char → Char → Num</code>, subtracting two characters gives a number:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">'a'</span><span class="o">-</span><span class="ss">@</span>
<span class="m">97</span>
<span class="w">    </span><span class="s1">'0'</span><span class="o">-</span><span class="ss">@</span>
<span class="m">48</span>
<span class="w">    </span><span class="s1">'a'</span><span class="o">-</span><span class="s1">'0'</span>
<span class="m">49</span>
</pre></div>
</li>
</ol>
<p></p>
Since the numbers from 0 to 9 are ordered sequentially in UTF-8,
this in particular gives a neat way to transform a vector of characters<!--
-->—also known as a string—<!--
-->into a vector of digits:
simply subtract <code>'0'</code> from them!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">'9'</span><span class="o">-</span><span class="s1">'0'</span>
<span class="m">9</span>
<span class="w">    </span><span class="s2">&quot;1939102&quot;</span><span class="o">-</span><span class="s1">'0'</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

The last example shows another important feature of pretty much all array oriented languages:
<a href="https://mlochbaum.github.io/BQN/doc/arithmetic.html#pervasion">scalar pervasion</a>.
Simply put, arithmetic functions like <code>-</code> know how to “penetrate” arrays,
in that they apply to each element individually, instead of to the whole thing as one.
In this case, the scalar <code>'0'</code> is “duplicated” and supplied to all elements of the string <code>"1939102"</code>.
</details>
<p></p>
After the input is parsed, the solution is not so complicated:<!--
--><label for="sn-11" class="margin-toggle">⊕</label><input type="checkbox" id="sn-11" class="margin-toggle" /><div class="marginnote">All whitespace here, and indeed in most places, is completely redundant.
I choose to still include it, to “logically group” certain operations.
It helps me with reading the code, anyways.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="nv">inp</span><span class="o">/</span><span class="na">˜</span><span class="w"> </span><span class="nv">inp</span><span class="o">=</span><span class="w"> </span><span class="m">¯1</span><span class="o">⌽</span><span class="nv">inp</span>
</pre></div>

<p></p>
We <em>rotate</em> (<a href="https://mlochbaum.github.io/BQN/doc/reverse.html#rotate"><code>⌽</code></a>)
the whole list by 1 to the right,
and then compare it with its original (<code>inp= -1⌽inp</code>).
This creates a <em>Boolean mask</em>: a list with the same length as <code>inp</code>, only consisting of zeros and ones.
We can use this to pick the elements of the list corresponding to 1 with
<em>replicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/replicate.html#replicate"><code>/</code></a>).
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="c1"># &quot;Only give me the elements of 𝕩</span>
<span class="w">    </span><span class="c1"># that correspond to 1's in 𝕨&quot;.</span>
<span class="w">    </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">↕</span><span class="m">6</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
All that’s left is to sum up the numbers by using
+-<em>fold</em> (<a href="https://mlochbaum.github.io/BQN/doc/fold.html#fold"><code>`</code></a>),
which is just a right fold over the list.
A few more notes:
<ol type="1">
<li><p></p>

Boolean masks are an important concept to internalise,
and will often be used to filter results, or serve as control flow<!--
     -->—<span class="small-caps">bqn</span> does not have a builtin if-then-else expression!</li>
<li><p></p>

<em>Swap</em> (<a href="https://mlochbaum.github.io/BQN/doc/swap.html"><code>˜</code></a>),
as seen in the <a href="#a-crash-course-on-syntax">crash course on syntax</a> makes an appearance again.
Recall that this 1-modifier simply takes a function, and returns a function with its arguments flipped,
so <code>X f˜ Y</code> is the same as <code>Y f X</code>.
When given only one argument, <em>swap</em> becomes <em>self</em> and duplicates its argument: <code>f˜ Y</code> is <code>Y f Y</code>.
The modifier mostly exists to allow the reading order to flow more naturally from right to left.
Without it, we would have to write the above expression as <code>+´(inp=-1⌽inp)/inp</code>.<!--
--><label for="sn-12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-12" class="margin-toggle" /><div class="sidenote">Or, if you wanted to make it extra confusing,
as <code>+´⊢/⊢=¯1⊸⌽</code>,
but we’ll get to that later on.</div><!--
--></li>
</ol>
<hr />
<p></p>
Part two is basically the same,
only a number doesn’t consider its first successor,
but the one that’s exactly halfway around the list.
Adjusting for this just means that we have to adjust how much we shift before comparing:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="nv">inp</span><span class="o">/</span><span class="na">˜</span><span class="w"> </span><span class="nv">inp</span><span class="o">=</span><span class="w"> </span><span class="sr">(</span><span class="m">¯2</span><span class="o">÷</span><span class="na">˜</span><span class="o">≠</span><span class="nv">inp</span><span class="sr">)</span><span class="o">⌽</span><span class="nv">inp</span>
</pre></div>

<p></p>
Even in this simple example,
one can already see what goes into writing code in this language:
aim for branchless, array-based, solutions rather than iterating through elements.
However, if you ever miss <code>if-then-else</code> or <code>while</code> constructs,
<a href="https://mlochbaum.github.io/BQN/doc/control.html">you can make your own</a>.
<h3 id="day-2"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day02.bqn">Day 2</a><a href="#day-2" class="floatleft sec-link">§</a></h3>
<p></p>
Today we have to help some programs repair a corrupted spreadsheet.
Our puzzle input is a table of numbers, like so:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>5 9 2 8
9 4 7 3
3 8 6 5
</pre></div>

<p></p>
For part one we have to calculate the smallest and largest values of all rows in the table.
This is easy enough once we have the data in a usable format;
however, getting to that format is actually the much more interesting part of the day.
For one, we have to learn how to split strings!
For these kinds of partitioning tasks, <span class="small-caps">bqn</span> sports the very general
<em>group</em> (<a href="https://mlochbaum.github.io/BQN/doc/group.html"><code>⊔</code></a>)
function.
Briefly, <code>X⊔Y</code> groups <code>Y</code> according to the indices supplied by <code>X</code>,
while omitting elements that are associated to <code>¯1</code>.
For example, in
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">¯1</span><span class="p">‿</span><span class="m">1</span><span class="w"> </span><span class="o">⊔</span><span class="w"> </span><span class="s2">&quot;abcd&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="s2">&quot;ad&quot;</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
both <code>a</code> and <code>d</code> are associated to the same index, <code>1</code>, so they are grouped together;
<code>b</code> is alone (and in front of <code>a</code> and <code>d</code> because it is associated to index <code>0</code>);
and <code>c</code> is omitted.
The strategy is, then, to somehow associate <code>¯1</code> to the separator in the input, and have all digits of a number be associated to the same index.
If you want you can black box that such a <code>Split</code> function exists;
if not, feel free to peruse the insert below.
<details>
<summary>
The long and painful walkthrough
</summary>
<p></p>
We start by checking which elements of the given string match the separator,
and call it <code>ws</code>.
I will use a string with a space separator for illustrative purposes, but the function itself is really quite general.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Now, a
+-<em>scan</em> (<a href="https://mlochbaum.github.io/BQN/doc/scan.html"><code>`</code></a>)
yields a running sum, indicating when we encounter a separator.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">+</span><span class="na">`</span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
This looks a bit weird, but the <code>ws←𝕨=𝕩</code> is an inline assignment—we do the comparison <code>𝕨=𝕩</code>, call the result <code>ws</code>, and then scan over it.
In this way, we can refer to <code>ws</code> again at a later point.
It’s not the best style to write code this way, but here it kind of fits.
If we just <em>group</em>ed the string now, we
would get the separators “attached” to the word that follows them:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="ni">𝕩</span><span class="o">⊔</span><span class="na">˜</span><span class="o">+</span><span class="na">`</span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;13&quot;</span><span class="w"> </span><span class="s2">&quot; 259&quot;</span><span class="w"> </span><span class="s2">&quot; 39999&quot;</span><span class="w"> </span><span class="s2">&quot; 4&quot;</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
One thing we can do,
since <code>ws</code> gives us the positions of the separators,
is to
<em>negate</em> (<a href="https://mlochbaum.github.io/BQN/doc/logic.html"><code>¬</code></a>)
the entire vector and multiply it with what we already have.
This would turn all separators into zeros in the output:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="sr">(</span><span class="o">¬</span><span class="nv">ws</span><span class="sr">)</span><span class="o">×+</span><span class="na">`</span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Now we can’t differentiate between the separators and our first word!
However, there is an easy fix for this;
we just take the original <code>ws</code>, which—remember—contains the positions of the separators,
and subtract it from the result that we have:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">ws</span><span class="o">-</span><span class="na">˜</span><span class="sr">(</span><span class="o">¬</span><span class="nv">ws</span><span class="sr">)</span><span class="o">×+</span><span class="na">`</span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
And that’s it!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="ni">𝕩</span><span class="o">⊔</span><span class="na">˜</span><span class="nv">ws</span><span class="o">-</span><span class="na">˜</span><span class="sr">(</span><span class="o">¬</span><span class="nv">ws</span><span class="sr">)</span><span class="o">×+</span><span class="na">`</span><span class="nv">ws</span><span class="kd">←</span><span class="ni">𝕨</span><span class="o">=</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;13&quot;</span><span class="w"> </span><span class="s2">&quot;259&quot;</span><span class="w"> </span><span class="s2">&quot;39999&quot;</span><span class="w"> </span><span class="s2">&quot;4&quot;</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
If you wanted to make it unreadable (see the bit on trains below), you could also write it as
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">' '</span><span class="w"> </span><span class="sr">((</span><span class="o">⊢-</span><span class="na">˜</span><span class="o">¬×+</span><span class="na">`</span><span class="sr">)</span><span class="py">∘</span><span class="o">=⊔⊢</span><span class="sr">)</span><span class="w"> </span><span class="s2">&quot;13 259 39999 4&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;13&quot;</span><span class="w"> </span><span class="s2">&quot;259&quot;</span><span class="w"> </span><span class="s2">&quot;39999&quot;</span><span class="w"> </span><span class="s2">&quot;4&quot;</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

We can bind that to a function <code>Split</code> and be on our way!<!--
--><label for="sn-13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-13" class="margin-toggle" /><div class="sidenote">Note that the actual implementation of <code>Split</code> I’m using is
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Split</span><span class="w"> </span><span class="kd">⇐</span><span class="w"> </span><span class="sr">(</span><span class="o">¬-</span><span class="na">˜</span><span class="o">⊢×</span><span class="m">·</span><span class="o">+</span><span class="na">`</span><span class="o">»</span><span class="py">⊸</span><span class="o">&gt;</span><span class="sr">)</span><span class="py">∘</span><span class="o">≠⊔⊢</span>
</pre></div>

<p></p>
which is subtly different in its behaviour.
I leave it as an exercise for the reader—or my future self—to figure out how exactly this version differs to the one I just explained,
and what problem it fixes.</div><!--
-->
</details>
<p></p>
The input separates each number by a tab,
so we just need <code>'\t' Split input</code>, right?
<p></p>
Wrong!
<p></p>
<span class="small-caps">bqn</span>’s characters and strings are almost completely void of any kind of escaping mechanism.
That is to say, besides for double quotes, which are inserted by duplicating them,
every character entered into a string it interpreted verbatim.
Indeed, <code>'\t'</code> is not even a valid character,
as it actually comprises two characters: <code>'\'</code> and <code>'t'</code>!
To write a tab we either need to actually insert a tab character,<!--
--><label for="sn-14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-14" class="margin-toggle" /><div class="sidenote">E.g., Emacs supports this by means of <code>quoted-insert</code> (<code>C-q</code>).</div><!--
-->
or make use of the “affine” part of affine characters:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">'	'</span>
<span class="s1">'	'</span>
<span class="w">    </span><span class="ss">@</span><span class="o">+</span><span class="m">9</span>
<span class="s1">'	'</span>
</pre></div>

<p></p>
Because both <code>Split</code> and <code>tab←@+9</code> will be needed quite a few times this year,
let’s put it into a small utility file.
We can use <span class="small-caps">bqn</span>’s system function <code>•Import</code> to import a namespace<!--
-->—which I don’t want to get into right now, but it works as one would expect—<!--
-->from somewhere.
Parsing the input and solving part one is straightforward:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">,</span><span class="w"> </span><span class="nv">tab</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">&gt;</span><span class="sr">(</span><span class="o">•ParseFloat</span><span class="na">¨</span><span class="w"> </span><span class="nv">tab</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day02.txt&quot;</span>

<span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="sr">(</span><span class="o">⌈</span><span class="na">´</span><span class="o">-⌊</span><span class="na">´</span><span class="sr">)</span><span class="na">˘</span><span class="w"> </span><span class="nv">inp</span>
</pre></div>

<p></p>
…except that this solution uses two new concepts that we haven’t seen before:
multidimensional arrays, and tacit programming!
<details>
<summary>
Arrays
</summary>
<p></p>
The fateful day has come that we need to talk about arrays in this array language.
I will probably not do this topic justice here, so <a href="https://mlochbaum.github.io/BQN/doc/array.html">have a link</a> to the <span class="small-caps">bqn</span> array docs.
For now, let’s look at an array as a blob with the following properties:
<ul>
<li><p></p>

It has a <em>rank</em>, which is its number of axes.
Pictorially, it is the number of dimensions one can walk in.
The <em>leading axis</em> is the first one.</li>
<li><p></p>

It has a <em>shape</em>, which is the number of positions that it has along each of its axes.</li>
<li><p></p>

It has <em>elements</em>, which are the values at every position.</li>
</ul>
<p></p>
One can query the <em>rank</em> of an array with monadic
<a href="https://mlochbaum.github.io/BQN/doc/shape.html"><code>=</code></a>
and the <em>shape</em> with monadic
<a href="https://mlochbaum.github.io/BQN/doc/shape.html"><code>≢</code></a>.
<p></p>
For example,
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">10</span><span class="o">+↕</span><span class="m">9</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="m">11</span><span class="w"> </span><span class="m">12</span><span class="w"> </span><span class="m">13</span><span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="m">15</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">17</span><span class="w"> </span><span class="m">18</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
is an array of <em>rank</em> <code>1</code> with <em>shape</em> <code>⟨9⟩</code>.
At every possible position (0–9), we find a corresponding element: <code>10</code> for 0, <code>11</code> for 1, etc.
<p></p>
We can use <em>reshape</em> to create a higher-dimensional array from a flat vector:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
This is an array of <em>rank</em> <code>2</code> with <em>shape</em> <code>⟨3 3⟩</code>.
The element at position <code>1‿1</code> (notice how we have two indices to specify) is <code>4</code>.
<p></p>
Why am I blabbering on about this when everyone intuitively knows what an array is?
Because this is <em>really</em> important:
arrays are an intrinsic concept.
Many things that seem intuitive at first,
coming from another language, are just not true in <span class="small-caps">bqn</span>.
<ul>
<li><p></p>

Lists of lists are not equivalent to higher-dimensional arrays:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">a</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨⟨</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">⟩,⟨</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">⟩⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="nv">b</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">&gt;</span><span class="nv">a</span><span class="w">              </span><span class="c1"># monadic &gt; is called *merge*</span>
<span class="w">                        </span><span class="c1"># and creates an array from a list</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span>
<span class="w">      </span><span class="err">┘</span>
<span class="w">   </span><span class="nv">b</span><span class="o">≡</span><span class="nv">a</span>
<span class="m">0</span>
</pre></div>
</li>
<li><p></p>

Piggybacking off of that: “depth is not rank”.
The type of the elements is not at all important in determining the arrays rank.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">   </span><span class="o">=</span><span class="m">1</span><span class="p">‿</span><span class="m">2</span><span class="p">‿</span><span class="m">3</span><span class="p">‿</span><span class="m">4</span><span class="p">‿</span><span class="m">5</span><span class="w"> </span><span class="c1"># vector</span>
<span class="m">1</span>
<span class="w">   </span><span class="o">=</span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span><span class="w">    </span><span class="c1"># matrix</span>
<span class="m">2</span>
<span class="w">   </span><span class="nv">m</span><span class="kd">←</span><span class="m">1</span><span class="p">‿</span><span class="sr">(</span><span class="m">3</span><span class="p">‿</span><span class="m">4</span><span class="sr">)</span><span class="p">‿</span><span class="sr">(</span><span class="m">2</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊↕</span><span class="m">4</span><span class="sr">)</span><span class="w"> </span><span class="c1"># Nested array</span>
<span class="err">┌─</span>
<span class="m">·</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="err">┌─</span>
<span class="w">            </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">              </span><span class="m">2</span><span class="w"> </span><span class="m">3</span>
<span class="w">                  </span><span class="err">┘</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">   </span><span class="o">=</span><span class="nv">m</span><span class="w"> </span><span class="c1"># The rank of the elements does</span>
<span class="w">      </span><span class="c1"># *not* affect the rank of the array.</span>
<span class="m">1</span>
</pre></div>
</li>
</ul>
<p></p>
A <em>cell</em> of an array is just a subarray of any size.
Now, a <em>major cell</em> of an array of rank <code>n</code> is a cell of rank <code>n-1</code> that leaves out the leading axis.
For example, <code>3‿3⥊↕9</code> has three major cells, <code>⟨0 1 2⟩</code>, <code>⟨3 4 5⟩</code>, and <code>⟨6 7 8⟩</code>.
<p></p>
This concept is quite central to the way a lot of array primitives work,
in that they often only apply to the first axis of the argument.
The 1-modifier
<em>cells</em> (<a href="https://mlochbaum.github.io/BQN/doc/rank.html"><code>˘</code></a>)
changes a function to instead operate on the major cells of its argument.
For example, we already saw that <em>reverse</em> reverses lists.
If we have more dimensions, we instead reverse along the leading axis:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">m</span><span class="kd">←</span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⌽</span><span class="nv">m</span><span class="w">   </span><span class="c1"># Reverse the first axis of m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⌽</span><span class="na">˘</span><span class="nv">m</span><span class="w">  </span><span class="c1"># Reverse each major cell separately</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">5</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">3</span>
<span class="w">  </span><span class="m">8</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">6</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

</details>
<details>
<summary>
Tacit programming
</summary>
<p></p>
If you, after reading this far,
thought that <span class="small-caps">bqn</span> was really a little too verbose for you,
<a href="https://mlochbaum.github.io/BQN/doc/tacit.html">you’re in luck</a>!
<p></p>
The basic idea of trains is deceptively simple.
Pick your favourite algebraic structure with a binary operation, say a monoid.
Given two monoid morphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>M</mi><mo>⟶</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">f, g \colon M \longrightarrow N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, we can define another map
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>⋅</mo><mi>g</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>M</mi><mo>⟶</mo><mi>N</mi><mo separator="true">,</mo><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>f</mi><mo>⋅</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo><mpadded class="vcenter"><mo lspace="0em" rspace="0em">:</mo></mpadded></mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f \cdot g \colon M \longrightarrow N, \qquad (f \cdot g)(x) \mathrel{\vcenter{:}}= f(x) \cdot g(x).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.4653em;"><span style="top:-3.0347em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">:</span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span>
It is an easy exercise to prove that this is again a morphism of monoids.
<p></p>
What <span class="small-caps">bqn</span> now does is twofold:
first, it takes the expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⋅</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \cdot g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>, and allows it to be called both monadically and dyadically.
Second, it allows one to replace the operation in the middle with any dyadic function whatsoever.
<p></p>
Train syntax is essentially just “writing functions after each other”.<!--
--><label for="sn-15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-15" class="margin-toggle" /><div class="sidenote">Technically, it’s
<a href="https://mlochbaum.github.io/BQN/doc/train.html#longer-trains">“any function expression with multiple functions or subjects in it”</a>,
which means a string of functions and subjects that ends with a function.</div><!--
-->
This in particular does not use any blocks, so you can’t refer to named arguments at all.
More explicitly, we have the following two relationships:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>(FGH)y  ≡  (Fy)G(Hy)   and   x(FGH)y  ≡  (xFy)G(xHy)
</pre></div>

<p></p>
Replace <code>G</code> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> in the first of these and you essentially have the above mathematical notation.
<p></p>
Since this train is composed of three functions, it is called a <em>3-train</em>.
Naturally, <em>2-trains</em> also exist; these are just 3-trains in which the function <code>F</code> is <em>nothing</em>
(<a href="https://mlochbaum.github.io/BQN/doc/expression.html#nothing"><code>·</code></a>):
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>(GH)y  ≡  GHy   and   x(GH)y  ≡  G(xHy)
</pre></div>

<p></p>
For example, suppose we wanted to write a function that takes two arrays <code>X</code> and <code>Y</code> and gives us back only those major cells of <code>X</code> that do not exist in <code>Y</code>.<!--
--><label for="sn-16" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-16" class="margin-toggle" /><div class="sidenote">This is a primitive in <span class="small-caps">apl</span>, dyadic <code>~</code>,
but it’s easy enough to remember that it doesn’t feel all that bothersome to write it out in <span class="small-caps">bqn</span>.</div><!--
-->
Sort of like a set difference for arrays.
We just need a few functions for this purpose:
<em>negate</em> (<a href="https://mlochbaum.github.io/BQN/doc/logic.html"><code>¬</code></a>) and
<em>member of</em> (<a href="https://mlochbaum.github.io/BQN/doc/search.html#member-of"><code>∊</code></a>),
which do what you would expect them to.
<p></p>
Additionally, we will make use of the scalar pervasion of <em>member of</em>,
where for every element in <code>𝕨</code>, we test whether it is in <code>𝕩</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s2">&quot;.b#d.#zz#&quot;</span><span class="w"> </span><span class="o">∊</span><span class="w"> </span><span class="s2">&quot;.#&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Let’s now write the function with and without trains:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">W1</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="sr">(</span><span class="o">¬</span><span class="ni">𝕨</span><span class="o">∊</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">/</span><span class="ni">𝕨</span><span class="kt">}</span><span class="w">   </span><span class="c1"># no trains at all</span>
<span class="w">    </span><span class="o">W2</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">¬∊</span><span class="sr">)</span><span class="o">/⊣</span><span class="w">       </span><span class="c1"># A 3-train whose left argument is a 2-train</span>
<span class="w">    </span><span class="o">W3</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">¬</span><span class="py">∘</span><span class="o">∊/⊣</span><span class="w">        </span><span class="c1"># A single 3-train because of precedence</span>

<span class="w">    </span><span class="m">3</span><span class="p">‿</span><span class="m">1</span><span class="o">⥊</span><span class="p">⟨</span><span class="sr">(</span><span class="o">↕</span><span class="m">9</span><span class="sr">)</span><span class="o">W1</span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">1</span><span class="p">⟩,</span><span class="w"> </span><span class="sr">(</span><span class="o">↕</span><span class="m">9</span><span class="sr">)</span><span class="o">W2</span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">1</span><span class="p">⟩,</span><span class="w"> </span><span class="sr">(</span><span class="o">↕</span><span class="m">9</span><span class="sr">)</span><span class="o">W3</span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">1</span><span class="p">⟩⟩</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">                  </span><span class="err">┘</span>
</pre></div>

<p></p>
That last example used the
<em>atop</em> (<a href="https://mlochbaum.github.io/BQN/doc/compose.html#atop"><code>∘</code></a>)
2-modifier; one of several
<a href="https://mlochbaum.github.io/BQN/doc/tacit.html#combinators">combinators</a>
that <span class="small-caps">bqn</span> sports to complement this syntax.
I will generally introduce them on a call by need basis;
<em>atop</em> is basically a 2-train as a modifier:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>F∘G𝕩  ≡  FG𝕩   and   𝕨F∘G𝕩  ≡  F(𝕨G𝕩)
</pre></div>

<p></p>
The <code>(¬∊)/⊣</code> example above shows that trains can “stack”.
Parentheses are really important here, by the way, since
depending on whether the overall length of an expression is even or odd
things may get parsed as a 2- or 3- train!
This is horribly confusing at first, but thankfully <span class="small-caps">bqn</span> has an <code>)explain</code> system function that prints the parse tree of an expression:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>    )explain (¬∊)/⊣
 (¬∊)/⊣
   │  │
  ¬∊  │
  └──/⊣
╶────┘

    )explain ¬∘∊/⊣
 ¬∘∊/⊣
 │ │ │
 ¬∘∊ │
  └─/⊣
╶───┘
</pre></div>

Playing around with this was immensely helpful for me in the beginning.
</details>
<p></p>
The 1-modifier
<em>each</em> (<a href="https://mlochbaum.github.io/BQN/doc/map.html"><code>¨</code></a>)
does what it says on the tin—it’s comparable to <code>map</code> in many other languages.
Parsing the input works as expected,
in that we split each line on the tab character,
and parse all the resulting sequences of digits as numbers.
All that’s left to do is to assembly the table in to a rank two array.
By means of <em>cells</em> we get the maximum and minimum for every row<!--
-->—using the <code>⌈´-⌊´</code> train, which is a great one to reason through—<!--
-->and sum up the resulting vector to get our answer.
<hr />
<p></p>
Part two asks a bit of a different question:
instead of the smallest and largest number in each row,
we instead need to find the two (unique) numbers such that one evenly divides the other,
and take the result of that division.
<p></p>
I didn’t think too hard about this and just decided to brute-force a solution.
The idea is to proceed row-wise and first create a division table for each row with <code>÷⌜˜</code>.
This uses the 1-modifier
<em>table</em> (<a href="https://mlochbaum.github.io/BQN/doc/map.html#table"><code>⌜</code></a>),
which is essentially a generalised outer product in the sense of linear algebra.
Written out explicitly, this definition is equivalent to <code>{ 𝕩÷⌜𝕩 }</code>:
it applies the given function to every element of <code>𝕩</code> on the left and all of <code>𝕩</code> on the right
and makes that one row in a new matrix (or, table, hence the name).
Since arithmetic functions support scalar pervasion,
this ends up giving us the division table we want:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>    (÷⌜˜) ⟨2, 4, 8, 16⟩
┌─
╵ 1 0.5 0.25 0.125    # 2÷2  2÷4  2÷8  2÷16
  2   1  0.5  0.25    # 4÷2  …
  4   2    1   0.5    # 8÷2  …
  8   4    2     1    # 16÷2 …
                   ┘
</pre></div>

<p></p>
As the problem explicitly says,
there will be exactly one pair of <em>different</em> numbers where one evenly divides the other.
As such, we just need to select an integer<!--
-->—e.g., some number that’s equal to its floor—<!--
-->that is not one:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Two</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">t</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">÷</span><span class="na">⌜˜</span><span class="ni">𝕩</span><span class="w">            </span><span class="c1"># Division table</span>
<span class="w">  </span><span class="o">⊑</span><span class="sr">((</span><span class="m">1</span><span class="o">≠</span><span class="nv">t</span><span class="sr">)</span><span class="o">∧</span><span class="nv">t</span><span class="o">=⌊</span><span class="nv">t</span><span class="sr">)(</span><span class="o">/</span><span class="py">○</span><span class="o">⥊</span><span class="sr">)</span><span class="nv">t</span><span class="w"> </span><span class="c1"># Select integer that is not 1</span>
<span class="kt">}</span>
<span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="o">Two</span><span class="na">˘</span><span class="w"> </span><span class="nv">inp</span>
</pre></div>

<p></p>
As before, selection is done with <code>/</code> (<em>replicate</em>).
We use <em>over</em>, <code>○</code>, which is one of the combinators mentioned earlier, to
<em>deshape</em> (<a href="https://mlochbaum.github.io/BQN/doc/reshape.html#deshape"><code>⥊</code></a>)
the array beforehand,
as <em>replicate</em> only operates on vectors and not arrays.<!--
--><label for="sn-17" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-17" class="margin-toggle" /><div class="sidenote">Don’t want to somehow end up with an array that has holes in it!</div><!--
-->
Briefly, one has that <code>𝕨(𝔽○𝔾)𝕩</code> is <code>(𝔾𝕨)𝔽(𝔾𝕩)</code>.
We then just have to pick the first element of the array,
which we know will have exactly one match.
All that’s left to do is to apply the function <code>Two</code> to all rows of <code>inp</code>,
which is but a <em>cells</em> away, and sum up the result.
<h3 id="day-3"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day03.bqn">Day 3</a><a href="#day-3" class="floatleft sec-link">§</a></h3>
<p></p>
Day 3 asks us to implement an experimental memory layout: an infinite spiral grid.
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>17  16  15  14  13
18   5   4   3  12
19   6   1   2  11
20   7   8   9  10
21  22  23---&gt; ...
</pre></div>

<p></p>
Part one is all about calculating the
<a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a><!--
--><label for="sn-18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-18" class="margin-toggle" /><div class="sidenote">In two dimensions this is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_1 - x_2| + |y_1 - y_2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>;
or, as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is always the origin, just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_1|+|x_2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>.</div><!--
-->
between the start point <code>1</code> in the middle of the grid, and wherever we end up with after taking
as many steps as our puzzle input demands.
As such, parsing is straightforward.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat⊑•FLines</span><span class="s2">&quot;../inputs/day03.txt&quot;</span>
</pre></div>

<p></p>
I found no good array solution for this,
so I just stared hard at the spiral until noticing the general pattern in which we are moving:
<code>R U 2L 2D 3R 3U 4L 4D 5R 5U…</code>.
The function that outputs all of the coordinates we’ve been to looks like this:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Coords</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># 2×𝕩: Number of steps to go.</span>
<span class="w">  </span><span class="nv">dirs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="m">2</span><span class="o">×</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⥊</span><span class="p">⟨</span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># r u l d</span>
<span class="w">  </span><span class="nv">natnat</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∾</span><span class="sr">(</span><span class="o">↕⋈</span><span class="na">¨</span><span class="o">↕</span><span class="sr">)</span><span class="ni">𝕩</span><span class="w">                   </span><span class="c1"># 0 0 1 1 2 2 3 3 …</span>
<span class="w">  </span><span class="o">+</span><span class="na">`</span><span class="o">∾</span><span class="nv">natnat</span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="nv">dirs</span><span class="w">             </span><span class="c1"># expand</span>
<span class="kt">}</span>
</pre></div>

<p></p>
We create the <code>R U 2L 2D…</code> pattern in two steps,
first assembling the directions and then the associated numbers.
Notice that if <code>𝕨</code> is larger than the length of <code>𝕩</code>, <em>reshape</em> duplicates <code>𝕩</code> until it fits:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">5</span><span class="o">⥊</span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="kt">{</span><span class="sr">(</span><span class="m">2</span><span class="o">×≠</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="o">↕</span><span class="m">5</span><span class="w">       </span><span class="c1"># Monadic ≠ is *length*</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="m">2</span><span class="o">×≠</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⥊</span><span class="w"> </span><span class="o">↕</span><span class="m">5</span><span class="w">          </span><span class="c1"># Bonus: the same thing tacitly</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
The train <code>↕⋈¨↕</code> is interesting because of the middle component, <code>⋈¨</code>.
It’s what one might call <code>zip</code> in other languages.
In the last line, we first use <em>reshape</em> to replicate the vector <code>𝕩</code> exactly <code>𝕨</code> times:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="err">┘</span>
</pre></div>

<p></p>
Then, since we actually want a nested vector instead of a rank two array,
<em>enclosing</em> (<a href="https://mlochbaum.github.io/BQN/doc/enclose.html"><code>&lt;</code></a>)
every major cell creates
<a href="https://mlochbaum.github.io/BQN/doc/enclose.html">unit arrays</a>
out of the individual cells.
Each of these is an array of shape <code>⟨⟩</code> containing the thing we enclosed as its only element.
This reduces the rank of the outer array by one, yielding the desired flat structure.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="w">         </span><span class="c1"># rank</span>
<span class="m">1</span>
<span class="w">    </span><span class="o">≢</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="w">         </span><span class="c1"># shape</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">≡</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="w">         </span><span class="c1"># depth</span>
<span class="m">2</span>
</pre></div>

<p></p>
Walking around the grid can now be simulated by summing up every individual move.
Scanning over the array keeps all intermediate steps,
which is useful since we are looking for a specific index:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">steps</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∾</span><span class="w"> </span><span class="m">3</span><span class="p">‿</span><span class="m">2</span><span class="w"> </span><span class="kt">{</span><span class="o">&lt;</span><span class="na">˘</span><span class="ni">𝕨</span><span class="p">‿</span><span class="m">2</span><span class="o">⥊</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="p">⟨</span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">   </span><span class="o">+</span><span class="na">`</span><span class="nv">steps</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">¯2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
All that’s left is to <em>pick</em> the right coordinate
(keeping in mind we skip the starting position),
and calculate the Manhattan distance.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="o">|</span><span class="w"> </span><span class="sr">(</span><span class="nv">inp</span><span class="o">-</span><span class="m">2</span><span class="sr">)</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="o">Coords</span><span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="c1"># ⇒ 552</span>
</pre></div>

<p></p>
The <code>1000</code> above is a magic number,
because the whole thing is really naturally a lazy infinite stream,<!--
--><label for="sn-19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-19" class="margin-toggle" /><div class="sidenote">Guess which other language I like to program in!</div><!--
-->
but that’s not how <span class="small-caps">bqn</span> works.
<hr />
<p></p>
Part two modifies how the spiral is constructed.
Instead of just being the ascending natural numbers,
a more elaborate iterative process is given:
for every number,
sum up the values of all the neighbours of a cell at the time of its creation.
With an initial seed of <code>1</code>, this would look like
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>    147  142  133  122   59
    304    5    4    2   57
    330   10    1    1   54
    351   11   23   25   26
    362  747  806---&gt;   ...
</pre></div>

<p></p>
Our task is to find the first number that’s bigger than our input.
<p></p>
Again, no array-oriented solution presented itself to me,
so I just did the obvious thing: for the point under consideration,
generate a list of all neighbours,
see whether they appear in the grid already,
sum the values of those that do,
and associate the point with that value in the grid.
<p></p>
In this case, “grid” actually means hash map—yup, we have those.
<span class="small-caps">bqn</span> exposes a simple interface under the <code>•HashMap</code> system value.
The function names—<code>Has</code>, <code>Get</code>, <code>Set</code>, and so on—are relatively self-explanatory.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">N</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="ni">:</span><span class="w"> </span><span class="o">⥊</span><span class="sr">(</span><span class="nv">x</span><span class="o">+</span><span class="p">⟨</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">⟩</span><span class="sr">)</span><span class="o">⋈</span><span class="na">⌜</span><span class="sr">(</span><span class="nv">y</span><span class="o">+</span><span class="p">⟨</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">⟩</span><span class="sr">)</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
We first calculate all of the neighbours of a given point,
represented as a vector with two elements.
The <code>x‿y:</code> part at the start of the function is a
<a href="https://mlochbaum.github.io/BQN/doc/block.html#block-headers">header</a>,
which I guess I should go into now.
<details>
<summary>
Headers
</summary>
<p></p>
At the most basic level,
headers can be used to name the arguments of, say, a function,
instead of using the special names <code>𝕨</code> and <code>𝕩</code>:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">17</span><span class="w"> </span><span class="kt">{</span><span class="nv">left_arg</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">right_arg</span><span class="ni">:</span><span class="w"> </span><span class="nv">left_arg</span><span class="kt">}</span><span class="w"> </span><span class="m">42</span>
<span class="m">17</span>
<span class="w">    </span><span class="m">17</span><span class="w"> </span><span class="kt">{</span><span class="nv">left_arg</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">right_arg</span><span class="ni">:</span><span class="w"> </span><span class="nv">right_arg</span><span class="kt">}</span><span class="w"> </span><span class="m">42</span>
<span class="m">42</span>
</pre></div>

<p></p>
The colon ends the header, and begins the body of the block.
The <code>𝕊</code> here is just a way to signal that the block is a function, instead of something else.
Recursion can then be done by calling <code>𝕊</code> with some arguments, the same as with “anonymous” blocks.
We can also give the function a name:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="kt">{</span><span class="w"> </span><span class="o">Fib</span><span class="w"> </span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="nv">n</span><span class="o">&lt;</span><span class="m">2</span><span class="ni">?</span><span class="w"> </span><span class="nv">n</span><span class="ni">;</span>
<span class="w">      </span><span class="o">Fib</span><span class="w"> </span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">Fib</span><span class="w"> </span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="sr">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">Fib</span><span class="w"> </span><span class="nv">n</span><span class="o">-</span><span class="m">2</span>
<span class="w">    </span><span class="kt">}</span><span class="w"> </span><span class="m">17</span>
<span class="m">1597</span>
</pre></div>

<p></p>
This example already highlights a few more features—and shortcomings—of blocks.
First, a block can contain multiple bodies, separated by <code>;</code>, as well as multiple headers associated to them.
When such a block is called,
its headers are checked for compatibility with the arguments,
until something appropriate is found (otherwise you get an error).
<p></p>
Additionally, predicates in the form of <code>n&lt;2?</code> appear.
Basically, this only evaluates the rest of the body if the predicate is true; otherwise, it jumps to the next header.
Control flow!
This is at the same time syntactically nice (chaining is quite concise: <code>𝕩&lt;2? 6=+´𝕩? …</code>),
but also forces us to repeat the header in the “else” branch,
as everything after <code>;</code> is in a new scope.
This is especially annoying with more elaborate headers,
but even here it feels unnecessarily verbose.
<p></p>
Headers can also do some light destructuring:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="kt">{</span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="ni">:</span><span class="w"> </span><span class="nv">x</span><span class="kt">}</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">⟩</span><span class="w">    </span><span class="c1"># Ok, vector should have exactly two elements</span>
<span class="m">1</span>
<span class="w">    </span><span class="kt">{</span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="ni">:</span><span class="w"> </span><span class="nv">x</span><span class="kt">}</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># Too long</span>
<span class="o">Error</span><span class="ni">:</span><span class="w"> </span><span class="o">No</span><span class="w"> </span><span class="nv">header</span><span class="w"> </span><span class="nv">matched</span><span class="w"> </span><span class="nv">argument</span>
<span class="w">    </span><span class="kt">{</span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="ni">:</span><span class="w"> </span><span class="nv">x</span><span class="kt">}</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">⟩</span><span class="w">       </span><span class="c1"># Too short</span>
<span class="o">Error</span><span class="ni">:</span><span class="w"> </span><span class="o">No</span><span class="w"> </span><span class="nv">header</span><span class="w"> </span><span class="nv">matched</span><span class="w"> </span><span class="nv">argument</span>
</pre></div>

</details>
<p></p>
The rest of <code>N</code> is straightforward.
Add all possible directions to every coordinate individually,
pair them up again in a table,
and flatten everything down to a vector with coordinate entries.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">⥊</span><span class="sr">(</span><span class="m">2</span><span class="o">+</span><span class="p">⟨</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">⟩</span><span class="sr">)</span><span class="o">⋈</span><span class="na">⌜</span><span class="sr">(</span><span class="m">3</span><span class="o">+</span><span class="p">⟨</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">⟩</span><span class="sr">)</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="c1"># Line break for clarity</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Let’s get to simulating!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># 𝕨 = grid = (x‿y)→n, …; 𝕩 = coords = ⟨x‿y, …⟩</span>
<span class="w">  </span><span class="sr">(</span><span class="m">¯1</span><span class="o">⊑</span><span class="ni">𝕨</span><span class="p">.</span><span class="o">Values</span><span class="ss">@</span><span class="sr">)</span><span class="o">&gt;</span><span class="nv">inp</span><span class="ni">?</span><span class="w">           </span><span class="c1"># Newest value larger than input?</span>
<span class="w">    </span><span class="m">¯1</span><span class="o">⊑</span><span class="ni">𝕨</span><span class="p">.</span><span class="o">Values</span><span class="ss">@</span><span class="ni">;</span>
<span class="w">  </span><span class="nv">grid</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">coords</span><span class="ni">:</span>
<span class="w">    </span><span class="nv">p</span><span class="p">‿</span><span class="nv">cs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">1</span><span class="sr">(</span><span class="o">↑⋈↓</span><span class="sr">)</span><span class="nv">coords</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">p</span><span class="o">⊑</span><span class="kd">↩</span><span class="w">   </span><span class="c1"># Point and rest</span>
<span class="w">    </span><span class="nv">p</span><span class="w"> </span><span class="nv">grid</span><span class="p">.</span><span class="o">Set</span><span class="w"> </span><span class="o">+</span><span class="na">´</span><span class="m">0</span><span class="py">⊸</span><span class="nv">grid</span><span class="p">.</span><span class="o">Get</span><span class="na">¨</span><span class="o">N</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="c1"># Get neighbour sums and set for point</span>
<span class="w">    </span><span class="nv">grid</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">cs</span><span class="w">                   </span><span class="c1"># Recurse</span>
<span class="kt">}</span>
</pre></div>

<p></p>
We smuggle a bit of control flow into <code>Sim</code> via the header <code>(¯1⊑𝕨.Values@)&gt;inp?</code>
that checks whether the value added last is larger than the input,
in which case we are done.
Otherwise, we divide the list into a head and a tail with <code>1(↑⋈↓)</code>,
compute the neighbours for the head,
look each of them up in the grid,
sum the results together,
and assign that to the point under consideration.
Then we just recurse to handle the other coordinates.
<p></p>
All that’s left to do is to supply a source of coordinates, and a fresh hash map with <code>1</code> at index <code>0‿0</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="kt">{</span><span class="nv">h</span><span class="kd">←</span><span class="p">⟨⟩</span><span class="o">•HashMap</span><span class="p">⟨⟩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="nv">h</span><span class="p">.</span><span class="o">Set</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">h</span><span class="kt">}</span><span class="w"> </span><span class="o">Sim</span><span class="w"> </span><span class="o">Coords</span><span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="c1"># ⇒ 330785</span>
</pre></div>

<h3 id="day-4"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day04.bqn">Day 4</a><a href="#day-4" class="floatleft sec-link">§</a></h3>
<p></p>
Today we are asked to validate some passphrases (our puzzle input).
One such phrase comprises some completely lowercase words separated by spaces: <code>x y</code>, <code>aa bb eix</code>, and so on.
Our input is a list of these things
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp
xmuf znkhaes pggrlp zia znkhaes znkhaes
nti rxr bogebb zdwrin
sryookh unrudn zrkz jxhrdo gctlyz
</pre></div>

<p></p>
Part one wants us to calculate how many passphrases do not contain duplicate words.
<span class="small-caps">bqn</span> essentially gives us everything we need for this: we
<em>sort</em> (<a href="https://mlochbaum.github.io/BQN/doc/order.html#sort"><code>∧</code></a>)
each passphrase,
use
<em>mark firsts</em> (<a href="https://mlochbaum.github.io/BQN/doc/selfcmp.html#mark-firsts"><code>∊</code></a>)
to mark the first occurrences of every element,
and then check that the resulting vector we get is all ones:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="o">∧</span><span class="na">´</span><span class="py">∘</span><span class="o">∊</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day04.txt&quot;</span><span class="w"> </span><span class="c1"># ⇒ 383</span>
</pre></div>

<p></p>
Easy.
<hr />
<p></p>
Part two slightly expands on this;
instead of being unique, words in a passphrase now only have to be unique up to permutation.
This means that no word may be the anagram of another word.
Solving this only requires a small adjustment to the above solution,
in that we now have to sort every word before using <em>mark firsts</em>:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="o">∧</span><span class="na">´</span><span class="py">∘</span><span class="o">∊</span><span class="py">∘</span><span class="sr">(</span><span class="o">∧</span><span class="na">¨</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day04.txt&quot;</span><span class="w"> </span><span class="c1"># ⇒ 265</span>
</pre></div>

<p></p>
The actually interesting bit about this day was how to combine these two solutions,
which involved writing my first real 1-modifier:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_Sol</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">+</span><span class="na">´</span><span class="w"> </span><span class="sr">(</span><span class="o">∧</span><span class="na">´</span><span class="o">∊</span><span class="py">∘</span><span class="o">𝔽</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">))</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day04.txt&quot;</span><span class="w"> </span><span class="kt">}</span>
<span class="o">⊢</span><span class="w">  </span><span class="na">_Sol</span><span class="w"> </span><span class="c1"># ⇒ 383</span>
<span class="o">∧</span><span class="na">¨</span><span class="w"> </span><span class="na">_Sol</span><span class="w"> </span><span class="c1"># ⇒ 265</span>
</pre></div>

<details>
<summary>
The underscore in the name is syntactically relevant.
</summary>
<p></p>
I’ve not mentioned this until now,
but <span class="small-caps">bqn</span> has a pretty cute system in order to achieve its
<a href="https://mlochbaum.github.io/BQN/doc/context.html">context free grammar</a>;
namely, <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">syntactic roles</a>.
Think of it sort of like a language enforced version of
<a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a><!--
-->—trust me, it’s not as horrendous as it sounds!
<p></p>
First, here’s a fun one:
the following variants all refer to <em>the same</em> identifier: <code>foo</code>, <code>fOo</code>, <code>FOO</code>, <code>___f_o____o</code>, <code>_foo_</code>.
Quite outrageous, but the only way this system can work.
<p></p>
There are just a few roles one needs to keep track of:
subjects like variables, spelled with an initial lower case letter;
functions, featuring an initial upper case letter;
1-modifiers, starting with an underscore;
and 2-modifiers, starting and ending with an underscore.
Keep in mind that builtin functions, 1-modifiers, and 2-modifiers also have consistent syntactic features.
This means that you can decide to which role any identifier belongs by just looking at it,
which can be very useful when trying to decide how an expression should be parenthesised.
<p></p>
The roles themselves are pretty self-explanatory;
functions take variables as their right and left inputs,
modifiers operate on functions, and so on.
The fact that roles can change is how
<a href="https://mlochbaum.github.io/BQN/doc/functional.html">functional programming</a>
works in <span class="small-caps">bqn</span>:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="p">⟨</span><span class="o">×</span><span class="na">˜</span><span class="p">,</span><span class="o">√</span><span class="p">⟩</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">⌜</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">4</span><span class="p">‿</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">81</span>
<span class="w">  </span><span class="m">1</span><span class="w">  </span><span class="m">2</span><span class="w">  </span><span class="m">3</span>
<span class="w">          </span><span class="err">┘</span>
</pre></div>

<p></p>
The function <code>{𝕎𝕩}</code> a priori takes two subjects—as all functions do—but then just turns around and treats the left one as a function.
Since we give it a list of functions, this works and we can apply it to the right arguments.
It’s important that we supplied a list here, btw; <code>×˜ {𝕎𝕩} 4</code> would not work, since <code>×˜</code> has a function role.
In that case, we need to work with variables:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">Square</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">×</span><span class="na">˜</span>
<span class="o">×</span><span class="na">˜</span>
<span class="w">    </span><span class="nv">square</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="m">4</span>
<span class="m">16</span>
</pre></div>

<p></p>
Honestly, I find this system super interesting,
and quite expressive.
It might be a bit confusing at first,
so I would encourage the reader who made it this far to peruse <span class="small-caps">bqn</span>’s entire
<a href="https://mlochbaum.github.io/BQN/doc/expression.html">expression syntax article</a>.
</details>
<p></p>
We can supply a function to <code>_Sol</code> that additionally transforms the individual words, before doing the uniqueness check.
Then, for part one the supplied function may simply be
<em>identity</em> (<a href="https://mlochbaum.github.io/BQN/doc/identity.html"><code>⊢</code></a>),
which does what it says on the tin.
<h3 id="day-5"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day05.bqn">Day 5</a><a href="#day-5" class="floatleft sec-link">§</a></h3>
<p></p>
Day 5 asks us to walk through a maze of self-rewriting jump instructions.
Concretely, this means that we are given a vector of numbers,
indicating how far (and in which direction) the jump is; for example,
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>2
0
0
1
2
0
1
-4
</pre></div>

<p></p>
After having jumped, the number at the last instruction is increased by one.
For part one we have to find out when we would exit the vector.
There is no real algorithm to speak of here, so we can just verbatim do what the instructions ask of us:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day05.txt&quot;</span>
<span class="m">¯1</span><span class="o">⊑</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="c1"># index‿step</span>
<span class="w">  </span><span class="nv">inp</span><span class="w"> </span><span class="sr">(</span><span class="m">1</span><span class="py">⊸</span><span class="o">+</span><span class="sr">)</span><span class="py">⌾</span><span class="sr">(</span><span class="nv">i</span><span class="py">⊸</span><span class="o">⊑</span><span class="sr">)</span><span class="kd">↩</span><span class="w">  </span><span class="c1"># Increase offset</span>
<span class="w">  </span><span class="p">⟨</span><span class="m">1</span><span class="o">-</span><span class="na">˜</span><span class="nv">i</span><span class="o">+</span><span class="nv">i</span><span class="o">⊑</span><span class="nv">inp</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="o">+</span><span class="m">1</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># Subtract one from new index; we just increased the offset</span>
<span class="kt">}</span><span class="o">•_while_</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">i</span><span class="o">&lt;≠</span><span class="nv">inp</span><span class="sr">)</span><span class="o">∧</span><span class="nv">i</span><span class="o">≥</span><span class="m">0</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w">   </span><span class="c1"># ⇒ 351282</span>
</pre></div>

<p></p>
There are nevertheless a few interesting things about the solution:
<code>inp F↩︎</code> <em>modifies</em> <code>inp</code> with the result of calling <code>F inp</code>.<!--
--><label for="sn-20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-20" class="margin-toggle" /><div class="sidenote">I mean, not really—arrays in <span class="small-caps">bqn</span> are immutable.
But we can at least pretend it does that.</div><!--
-->
Much more interestingly, however, we can use
<em>under</em> (<a href="https://mlochbaum.github.io/BQN/doc/under.html"><code>⌾</code></a>)
to change only a part of the input vector.
How it works in this “structural mode”<!--
--><label for="sn-21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-21" class="margin-toggle" /><div class="sidenote">There is also a “computational” <em>under</em>,
in which the <span class="small-caps">bqn</span> implementation tries to find a right inverse to the given function.
It’s a pretty interesting modifier.</div><!--
--> is that <code>𝔽⌾𝔾 𝕩</code>
replaces the part of <code>𝕩</code> that’s picked out by <code>𝔾𝕩</code>
with the result of <code>𝔽𝔾𝕩</code>.
As such, it first focuses in on the structure with <code>𝔾</code>, applies <code>𝔽</code>,
and then somehow “undoes” the first transformation,
such that the result of <code>𝔽</code> gets embedded into the original array.
<p></p>
The <code>•_while_</code> 2-modifier is used for iteration:
<code>𝔽•_while_𝔾 𝕩</code> checks <code>𝔾v</code>, where <code>v</code> is initially <code>𝕩</code>, to see if it should keep iterating;
if yes, it essentially does <code>v 𝔽↩︎</code> and goes back to <code>𝔾v</code> (where <code>v</code> is now updated!).
I have to say that I would much rather think in terms of recursive functions,
but—alas—the standard implementation of <span class="small-caps">bqn</span>, <code>cbqn</code>, does not support tail call optimisation.
<hr />
<p></p>
With that done, we have part two waiting for us.
Now, how an instruction changes after we jumped depends on its value:
if it’s three or more, we decrease it by one;
otherwise, we proceed as before and increase it by one.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="m">¯1</span><span class="o">⊑</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕊</span><span class="w"> </span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="c1"># index‿step</span>
<span class="w">  </span><span class="nv">n</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="nv">i</span><span class="o">+</span><span class="nv">i</span><span class="o">⊑</span><span class="nv">inp</span>
<span class="w">  </span><span class="nv">inp</span><span class="w"> </span><span class="sr">((</span><span class="m">3</span><span class="o">≤</span><span class="nv">i</span><span class="o">⊑</span><span class="nv">inp</span><span class="sr">)</span><span class="o">⊑</span><span class="p">⟨</span><span class="m">1</span><span class="py">⊸</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="py">⊸</span><span class="o">+</span><span class="p">⟩</span><span class="sr">)</span><span class="py">⌾</span><span class="sr">(</span><span class="nv">i</span><span class="py">⊸</span><span class="o">⊑</span><span class="sr">)</span><span class="kd">↩</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="nv">n</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="o">+</span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="kt">}</span><span class="o">•_while_</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">i</span><span class="o">&lt;≠</span><span class="nv">inp</span><span class="sr">)</span><span class="o">∧</span><span class="nv">i</span><span class="o">≥</span><span class="m">0</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w">  </span><span class="c1"># ⇒ 24568703</span>
</pre></div>

<p></p>
This is another neat example of how to use Boolean expressions for control flow:
depending on the result of <code>3≤i⊑inp</code>, we <em>pick</em> the correct function to apply.
<p></p>
Wrapping this in a function that works for both days is not super interesting,
only that we need to find a value <code>t</code> such that <code>t≤i⊑inp</code> will always be false.
<span class="small-caps">bqn</span> has the aptly named <code>∞</code> for that,
which is an infinity according to IEEE 754—<span class="small-caps">bqn</span> really only deals with <code>f64</code>’s.
While we’re at it, we can add the instruction set as an additional argument to <code>Sim</code>,
so that we don’t have to mutate the input directly.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">thresh</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">ins</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="c1"># instructions‿index‿step</span>
<span class="w">  </span><span class="nv">n</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="nv">i</span><span class="o">+</span><span class="nv">i</span><span class="o">⊑</span><span class="nv">ins</span>
<span class="w">  </span><span class="nv">ins</span><span class="w"> </span><span class="sr">((</span><span class="nv">thresh</span><span class="w"> </span><span class="o">≤</span><span class="w"> </span><span class="nv">i</span><span class="o">⊑</span><span class="nv">ins</span><span class="sr">)</span><span class="o">⊑</span><span class="p">⟨</span><span class="m">1</span><span class="py">⊸</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="py">⊸</span><span class="o">+</span><span class="p">⟩</span><span class="sr">)</span><span class="py">⌾</span><span class="sr">(</span><span class="nv">i</span><span class="py">⊸</span><span class="o">⊑</span><span class="sr">)</span><span class="kd">↩</span>
<span class="w">  </span><span class="nv">ins</span><span class="p">‿</span><span class="nv">n</span><span class="p">‿</span><span class="sr">(</span><span class="nv">s</span><span class="o">+</span><span class="m">1</span><span class="sr">)</span>
<span class="kt">}</span>
<span class="m">¯1</span><span class="o">⊑</span><span class="w"> </span><span class="m">∞</span><span class="w"> </span><span class="o">Sim</span><span class="w"> </span><span class="o">•_while_</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="m">·</span><span class="o">𝕊</span><span class="nv">ins</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">i</span><span class="o">&lt;≠</span><span class="nv">ins</span><span class="sr">)</span><span class="o">∧</span><span class="nv">i</span><span class="o">≥</span><span class="m">0</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="nv">inp</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="c1"># ⇒ 351282</span>
<span class="m">¯1</span><span class="o">⊑</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">Sim</span><span class="w"> </span><span class="o">•_while_</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="m">·</span><span class="o">𝕊</span><span class="nv">ins</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">s</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">i</span><span class="o">&lt;≠</span><span class="nv">ins</span><span class="sr">)</span><span class="o">∧</span><span class="nv">i</span><span class="o">≥</span><span class="m">0</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="nv">inp</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="c1"># ⇒ 24568703</span>
</pre></div>

<h2 id="days-610">Days 6–10<a href="#days-610" class="floatleft sec-link">§</a></h2>
<h3 id="day-6"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day06.bqn">Day 6</a><a href="#day-6" class="floatleft sec-link">§</a></h3>
<p></p>
Today we are tasked with redistributing blocks in a memory bank.
Concretely, we are given a vector like <code>⟨0, 2, 7, 0⟩</code> and,
in every step,
we look for the maximal element <code>m</code>, and “redistribute” its value by adding one to each successor in the circular list until <code>m</code> steps have been taken.
For example, the first few redistributions with the above start look like this:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">⟩</span><span class="w">  </span><span class="err">→</span><span class="w">  </span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">⟩</span><span class="w">  </span><span class="err">→</span><span class="w">  </span><span class="p">⟨</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">⟩</span>
</pre></div>

<p></p>
Notice in particular that the redistribution starts by “emptying” the bank with the highest value,
so <code>⟨0, 2, 7, 0⟩</code> is first transformed into <code>⟨0, 2, 0, 0⟩</code>, then into <code>⟨0, 2, 0, 1⟩</code>, then into <code>⟨1, 2, 0, 1⟩</code>, and so on.
At some point, we will—so the problem says—reach a configuration that we were already in before,
and part one asks us to find the number of cycles before that happens.
<p></p>
Parsing is the easy part, as the input just comprises a bunch of numbers on the first line:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">,</span><span class="w"> </span><span class="nv">tab</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat</span><span class="na">¨</span><span class="w"> </span><span class="nv">tab</span><span class="w"> </span><span class="o">Split</span><span class="w"> </span><span class="o">⊑•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day06.txt&quot;</span>
</pre></div>

<p></p>
The only interesting part of the solution is, I guess,
the encoding of the redistribution.
The basic idea is to take a number <code>n</code> at position <code>i</code>,
create a vector of 1’s of length <code>n</code>,
pad with <code>i</code> zeros on the left,
and then press that into the length of the vector.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">v</span><span class="kd">←</span><span class="p">⟨</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">7</span><span class="p">,</span><span class="m">0</span><span class="p">⟩</span><span class="w">         </span><span class="c1"># Test vector with max 7 at position 2</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="m">¯7</span><span class="o">∾</span><span class="m">7</span><span class="o">⥊</span><span class="m">1</span><span class="w">              </span><span class="c1"># Shape of 1's and ¯7</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">¯7</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="m">2</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="m">¯7</span><span class="o">∾</span><span class="m">7</span><span class="o">⥊</span><span class="m">1</span><span class="w">        </span><span class="c1"># Pad with zeros up to index</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">¯7</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">↑</span><span class="p">‿</span><span class="m">4</span><span class="o">⥊</span><span class="sr">(</span><span class="m">2</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="m">¯7</span><span class="o">∾</span><span class="m">7</span><span class="o">⥊</span><span class="m">1</span><span class="w">    </span><span class="c1"># Reshape to dimensions of v, and use fills</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">¯7</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">           </span><span class="err">┘</span>
<span class="w">   </span><span class="o">+</span><span class="na">˝</span><span class="o">↑</span><span class="p">‿</span><span class="m">4</span><span class="o">⥊</span><span class="sr">(</span><span class="m">2</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="m">¯7</span><span class="o">∾</span><span class="m">7</span><span class="o">⥊</span><span class="m">1</span><span class="w">   </span><span class="c1"># Sum up columns</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">¯6</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="nv">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">¯6</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="c1"># And we get the second step!</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<details>
<summary>
Fills and special symbols for <em>reshape</em>
</summary>
<p></p>
As you may have noticed, we gave the symbol <code>↑</code> to <em>reshape</em> above.
Ordinarily, this is the <em>take</em> (or <em>prefixes</em>) function, but here it stands in as a special symbol to alter the behaviour of <em>reshape</em>.
This, as well as various other values, is documented
<a href="https://mlochbaum.github.io/BQN/doc/reshape.html#computed-lengths">here</a>,
the relevant excerpt being
<blockquote>
<p></p>
<code>↑</code> rounds the length up, but uses the argument’s fill for the needed extra elements.
</blockquote>
<hr />
<p></p>
<a href="https://mlochbaum.github.io/BQN/doc/fill.html">Fill elements</a>
are basically certain “default” values of a given array.
Operations on the array might make use of them if the array would otherwise end up having holes in it.
Atomically, they are either <code>0</code> (for numbers) or <code>' '</code> (for characters),
and higher dimensional arrays—being inductively defined in <span class="small-caps">bqn</span>—can inherit from this.
A canonical example is <em>take</em> when the number of elements to be taken is longer than the length of the argument:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">   </span><span class="m">4</span><span class="o">↑</span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
This is also how things like <em>nudge</em> decide what to pad the array with.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">1</span><span class="o">+↕</span><span class="m">9</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">»</span><span class="m">1</span><span class="o">+↕</span><span class="m">9</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">«</span><span class="m">1</span><span class="o">+↕</span><span class="m">9</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<hr />
<p></p>
Reshaping may also use a fill element,
if the dimensions of the reshape are not exactly divisible by the shape of the original array:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">  </span><span class="m">3</span><span class="p">‿</span><span class="o">↑</span><span class="w"> </span><span class="o">⥊</span><span class="w"> </span><span class="m">7</span><span class="o">⥊</span><span class="m">1</span><span class="w"> </span><span class="c1"># After running out of 1's, use 0's for padding</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

</details>
<p></p>
To keep track of the already seen configurations,
we could again use a hash map as in <a href="#day-3">day 3</a>.
However, the number of configurations isn’t actually that large, so a normal list suffices.
Appropriately generalising the above construction nets us the result for part one:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">s</span><span class="p">‿</span><span class="nv">d</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">seen</span><span class="p">‿</span><span class="nv">xs</span><span class="ni">:</span>
<span class="w">    </span><span class="nv">m</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⌈</span><span class="na">´</span><span class="nv">xs</span><span class="w">              </span><span class="c1"># max elements -&gt; to be redistributed</span>
<span class="w">    </span><span class="p">⟨</span><span class="w"> </span><span class="nv">seen</span><span class="o">∾&lt;</span><span class="nv">xs</span><span class="p">,</span><span class="w"> </span><span class="nv">xs</span><span class="o">+</span><span class="w"> </span><span class="o">+</span><span class="na">˝</span><span class="o">↑</span><span class="p">‿</span><span class="sr">(</span><span class="o">≠</span><span class="nv">xs</span><span class="sr">)</span><span class="o">⥊</span><span class="sr">(</span><span class="m">0</span><span class="o">⥊</span><span class="na">˜</span><span class="o">⊑</span><span class="nv">xs</span><span class="o">⊐</span><span class="nv">m</span><span class="sr">)</span><span class="o">∾</span><span class="p">⟨</span><span class="o">-</span><span class="nv">m</span><span class="p">⟩</span><span class="o">∾</span><span class="nv">m</span><span class="o">⥊</span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="c1">#                 reshape  before     at  after</span>
<span class="w">  </span><span class="kt">}</span><span class="w"> </span><span class="o">•_while_</span><span class="w"> </span><span class="kt">{</span>
<span class="w">    </span><span class="nv">seen</span><span class="p">‿</span><span class="nv">xs</span><span class="ni">:</span><span class="w"> </span><span class="o">⊑¬</span><span class="sr">(</span><span class="o">&lt;</span><span class="nv">xs</span><span class="sr">)</span><span class="o">∊</span><span class="nv">seen</span><span class="w"> </span><span class="c1"># while not seen</span>
<span class="w">  </span><span class="kt">}</span><span class="w"> </span><span class="p">⟨⟩‿</span><span class="nv">inp</span>
<span class="o">≠</span><span class="nv">s</span><span class="w">                        </span><span class="c1"># ⇒ 7864</span>
</pre></div>

<hr />
<p></p>
Part two is just a slight variation on this idea:
we now also have to calculate the exact cycle length.
Since <code>•_while_</code> does not actually add the last memory bank state <code>d</code> to the vector <code>s</code>,
this just involves checking for <code>d</code>‘s index in <code>s</code>
and subtracting that from the vectors’ length:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">⊑</span><span class="sr">(</span><span class="o">≠</span><span class="nv">s</span><span class="sr">)</span><span class="o">-</span><span class="nv">s</span><span class="o">⊐&lt;</span><span class="nv">d</span><span class="w"> </span><span class="c1"># ⇒ 1695</span>
</pre></div>

<p></p>
Notice how we need to <em>enclose</em> <code>d</code> before using
<em>index of</em> (<a href="https://mlochbaum.github.io/BQN/doc/search.html#index-of"><code>⊐</code></a>).
Since <code>d</code> is a vector itself, the pervasive aspect of <em>index of</em> would otherwise ruin our day.
<h3 id="day-7"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day07.bqn">Day 7</a><a href="#day-7" class="floatleft sec-link">§</a></h3>
<p></p>
This day has us study a tree of programs.
To every program, one associates a weight and a (possibly empty) number of children.
Our input is in the form of an adjacency list:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>ktlj (57)
fwft (72) -&gt; ktlj, cntj, xhth
qoyq (66)
padx (45) -&gt; pbga, havc, qoyq
</pre></div>

<p></p>
More visually, such a tree can be written as
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>                gyxo
              /
         ugml - ebii
       /      \
      |         jptl
      |
      |         pbga
     /        /
tknk --- padx - havc
     \        \
      |         qoyq
      |
      |         ktlj
       \      /
         fwft - cntj
              \
                xhth
</pre></div>

<p></p>
Part one asks us for the root node.
Parsing is a bit ad-hoc, but not all that complicated:
for a single line of the form <code>a (7) -&gt; b, c</code>,
we first split every line by whitespace,
use the first and second entry in the resulting vector verbatim,
drop the <code>-&gt;</code>, and
split the rest on <code>,</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">ws</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="s1">' '</span><span class="w"> </span><span class="o">Split</span><span class="w"> </span><span class="ni">𝕩</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="o">⊑</span><span class="nv">ws</span><span class="p">,</span><span class="w"> </span><span class="o">•BQN</span><span class="w"> </span><span class="m">1</span><span class="o">⊑</span><span class="nv">ws</span><span class="p">,</span><span class="w"> </span><span class="s1">','</span><span class="o">Split∾</span><span class="m">3</span><span class="o">↓</span><span class="nv">ws</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="c1"># name‿weight‿children</span>
<span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day07.txt&quot;</span>
<span class="c1"># ⇒ ⟨ ⟨&quot;mmqyju&quot; 156 ⟨&quot;rjzvwv&quot; &quot;noybkx&quot;⟩⟩ … ⟩</span>
</pre></div>

<p></p>
The <code>•BQN</code> function is something like <code>eval</code> in lisps, or <code>⍎</code> in <span class="small-caps">apl</span>:
it evaluates the given string
(though, unlike <span class="small-caps">apl</span>, it does so in an isolated environment)
and returns the result, whatever it may be.
This is how we get away with parsing <code>"(8)"</code> to <code>8</code>,
which is something that an ordinary <code>•ParseFloat</code> would fail at.
<p></p>
The root node can be found without thinking about the tree at all:
just check which node does not appear as a child of another one.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">root</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="sr">(</span><span class="o">⊑</span><span class="na">¨</span><span class="nv">inp</span><span class="sr">)(</span><span class="o">¬</span><span class="py">∘</span><span class="o">∊/⊣</span><span class="sr">)(</span><span class="o">∾</span><span class="m">¯1</span><span class="o">⊑</span><span class="na">¨</span><span class="nv">inp</span><span class="sr">)</span><span class="w"> </span><span class="c1"># ⇒ &quot;svugo&quot;</span>
<span class="c1">#        nodes  not-in  children</span>
</pre></div>

<p></p>
Recall the “not-in” idiom <code>¬∘∊/⊣</code> from when we talked about trains.
<hr />
<p></p>
Part two now makes use of the weights, which we haven’t at all needed so far.
Our goal is to balance the tower of programs, so that the children of every node sum up to the same value.
For example, given the input
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>pbga (66)
xhth (57)
ebii (61)
havc (66)
ktlj (57)
fwft (72) -&gt; ktlj, cntj, xhth
qoyq (66)
padx (45) -&gt; pbga, havc, qoyq
tknk (41) -&gt; ugml, padx, fwft
jptl (61)
ugml (68) -&gt; gyxo, ebii, jptl
gyxo (61)
cntj (57)
</pre></div>

<p></p>
for the root, <code>tknk</code>, we would get the following sums of children:
<ul>
<li><code>ugml</code> + (<code>gyxo</code> + <code>ebii</code> + <code>jptl</code>) = 68 + (61 + 61 + 61) = 251</li>
<li><code>padx</code> + (<code>pbga</code> + <code>havc</code> + <code>qoyq</code>) = 45 + (66 + 66 + 66) = 243</li>
<li><code>fwft</code> + (<code>ktlj</code> + <code>cntj</code> + <code>xhth</code>) = 72 + (57 + 57 + 57) = 243</li>
</ul>
<p></p>
The problem tells us that, actually, only one program has the wrong weight.
Above, that’d be <code>ugml</code>, which would have to change from weight <code>68</code> to <code>60</code>—the answer.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">h</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨⟩</span><span class="o">•HashMap</span><span class="p">⟨⟩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">n</span><span class="p">‿</span><span class="nv">w</span><span class="p">‿</span><span class="nv">ch</span><span class="ni">:</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">h</span><span class="p">.</span><span class="o">Set</span><span class="w"> </span><span class="nv">w</span><span class="p">‿</span><span class="nv">ch</span><span class="w"> </span><span class="kt">}</span><span class="na">¨</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># name -&gt; weight, children</span>
<span class="o">M</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">=</span><span class="na">´</span><span class="m">2</span><span class="o">↑⊑</span><span class="na">¨</span><span class="w"> </span><span class="c1"># Do the first two elements have matching cumulative weights?</span>
<span class="o">SpotOutlier</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">w</span><span class="p">‿</span><span class="nv">ch</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="nv">h</span><span class="p">.</span><span class="o">Get</span><span class="w"> </span><span class="ni">𝕩</span>
<span class="w">  </span><span class="nv">sums</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∧𝕊</span><span class="na">¨</span><span class="nv">ch</span><span class="w">       </span><span class="c1"># Sort by ascending w+wc</span>
<span class="w">  </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="p">⟨⟩</span><span class="ni">:</span><span class="w"> </span><span class="nv">w</span><span class="p">‿</span><span class="nv">w</span><span class="ni">;</span><span class="w">        </span><span class="c1"># No children</span>
<span class="w">    </span><span class="o">𝕊</span><span class="nv">s</span><span class="w"> </span><span class="ni">:</span><span class="w"> </span><span class="o">M</span><span class="w"> </span><span class="nv">s</span><span class="ni">?</span><span class="w"> </span><span class="o">M⌽</span><span class="nv">s</span><span class="ni">?</span><span class="w">   </span><span class="c1"># All child nodes's weights match</span>
<span class="w">      </span><span class="p">⟨</span><span class="nv">w</span><span class="o">++</span><span class="na">´</span><span class="o">⊑</span><span class="na">¨</span><span class="nv">s</span><span class="p">,</span><span class="w"> </span><span class="nv">w</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="nv">s</span><span class="w"> </span><span class="ni">:</span><span class="w"> </span><span class="o">M</span><span class="w"> </span><span class="nv">s</span><span class="ni">?</span><span class="w">        </span><span class="c1"># Last weight is higher than the [o]ther[w]eights</span>
<span class="w">      </span><span class="nv">wwc</span><span class="p">‿</span><span class="nv">mw</span><span class="kd">←</span><span class="m">¯1</span><span class="o">⊑</span><span class="nv">s</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">ow</span><span class="p">‿</span><span class="m">·</span><span class="kd">←</span><span class="w">  </span><span class="o">⊑</span><span class="nv">s</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="sr">(</span><span class="nv">mw</span><span class="o">-</span><span class="nv">wwc</span><span class="o">-</span><span class="nv">ow</span><span class="sr">)</span><span class="o">!</span><span class="m">0</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="nv">s</span><span class="w"> </span><span class="ni">:</span><span class="w"> </span><span class="o">M⌽</span><span class="nv">s</span><span class="ni">?</span><span class="w">        </span><span class="c1"># First weight is lower than the [o]ther[w]eights</span>
<span class="w">      </span><span class="nv">wwc</span><span class="p">‿</span><span class="nv">mw</span><span class="kd">←</span><span class="w">  </span><span class="o">⊑</span><span class="nv">s</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">ow</span><span class="p">‿</span><span class="m">·</span><span class="kd">←</span><span class="m">¯1</span><span class="o">⊑</span><span class="nv">s</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="sr">(</span><span class="nv">mw</span><span class="o">-</span><span class="nv">wwc</span><span class="o">-</span><span class="nv">ow</span><span class="sr">)</span><span class="o">!</span><span class="m">0</span>
<span class="w">  </span><span class="kt">}</span><span class="w"> </span><span class="nv">sums</span>
<span class="kt">}</span>

<span class="o">SpotOutlier</span><span class="py">⎊</span><span class="o">•CurrentError</span><span class="w"> </span><span class="nv">root</span><span class="w"> </span><span class="c1"># ⇒ 1152</span>
</pre></div>

<p></p>
This looks like a lot of code, but the underlying recursive algorithm is not so complicated:
<ul>
<li>For all children of the given node,
create tuples of the total weight of each child <code>c</code> (including <code>c</code>’s children) and <code>c</code>’s own weight,
and sort the resulting list in ascending order.
This split of “weight” and “weight with children” is necessary,
since we want to adjust the weight of the node at the end.</li>
<li>Then, we check for the only conditions that can occur.<!--
--><label for="sn-22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-22" class="margin-toggle" /><div class="sidenote">That’s actually false: this algorithm doesn’t provide a general solution,
as it banks on the fact that a node never contains two children
(in which case we would have to try both branches).
It works for my input, though, so I figured this was good enough.
Let’s say that tree manipulations are not necessarily my favourite thing to do in an array language.</div><!--
-->
<ul>
<li>If the list is empty that means there are no children and the node is leaf,
so we hit the base case.</li>
<li>If the weights of all children match,
then we return the weight of the node and its children.</li>
<li>Otherwise, the weight that doesn’t match is singled out,
and the correct weight the node should have is thrown as an exception.</li>
</ul></li>
</ul>
<p></p>
Yes, feeling like a Python programmer, exceptions are used for control flow!
Since we immediately want to exit the function, no questions asked,
this seems as good a time as any to do something like that.
The <em>assert</em> function <a href="https://mlochbaum.github.io/BQN/doc/assert.html#assert"><code>!</code></a>
throws an exception if its right argument is not <code>1</code>.
In case it’s supplied a left argument, this is the value of the exception.
In the call to <code>SpotOutlier</code>, we can use the
<em>catch</em> (<a href="https://mlochbaum.github.io/BQN/doc/assert.html#catch"><code>⎊</code></a>) 2-modifier to catch the exception.
Since <em>catch</em> doesn’t actually know anything about the error<!--
-->—only that one occurred—<!--
-->we need the system value <code>•CurrentError</code> to access it.
<h3 id="day-8"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day08.bqn">Day 8</a><a href="#day-8" class="floatleft sec-link">§</a></h3>
<p></p>
Today we have to help the CPU simulate a small language,
consisting of simple register instructions like the following:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>b inc 5 if a &gt; 1
a inc 1 if b &lt; 5
c dec -10 if a &gt;= 1
c inc -20 if c == 10
</pre></div>

<p></p>
The instructions are given in a pretty rigid form;
abstractly, one has something like
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>«register» «operation» «number» if «register» «comparison» «number»
</pre></div>

<p></p>
where <code>«operation»</code> is one of <code>inc dec</code>, and <code>«comparison»</code> is one of <code>&gt; &lt; &gt;= == &lt;= !=</code>.
Part one asks us what the largest value in any register is after executing each instruction once.
<p></p>
Perhaps unexpectedly, there is a relatively obvious bijection between the instruction syntax and the relevant <span class="small-caps">bqn</span> code!
<ul>
<li>A number is a number.
Due to the right hand side only being zero or one,
we don’t even need to change <code>-20</code> into <code>¯20</code>,
but can keep <code>-</code> as a function.</li>
<li>A register is a variable holding a number.</li>
<li>A register operation is a call to <em>modify</em> for that register.</li>
<li>A comparison is a comparison.</li>
<li>An <code>if</code> instruction is a multiplication of the condition with the “then branch”.
Since <span class="small-caps">bqn</span> is evaluated right to left,
this works on-the-nose and no extra parentheses are needed.</li>
</ul>
<p></p>
Here are some sample translations:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>b inc 5   if a  &gt; 1   ↔  b+↩5   × a&gt;1
a inc 1   if b  &lt; 5   ↔  a+↩1   × b&lt;5
c dec -10 if a &gt;= 1   ↔  c-↩-10 × a≥1
c inc -20 if c == 10  ↔  c+↩-20 × c=10
</pre></div>

<p></p>
Pretty neat, huh?
The plan is clear: transform every line into its equivalent <span class="small-caps">bqn</span> code,
and evaluate everything with <code>•BQN</code>.
We have previously seen this function on <a href="#day-7">day 7</a>,
where it’s essentially used as a shorthand for <code>•ParseFloat</code>—now we really want it to execute some code!
Let’s first split every instruction into a list of its constituent words.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="kd">←</span><span class="o">•Import</span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day08.txt&quot;</span>
<span class="c1"># e.g., &quot;c inc -20 if c == 10&quot; → ⟨&quot;c&quot;, &quot;inc&quot;, &quot;-20&quot;, &quot;if&quot;, &quot;c&quot;, &quot;==&quot;, &quot;10&quot;⟩</span>
</pre></div>

<p></p>
Now we can replace every element with its <span class="small-caps">bqn</span> equivalent.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">C</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># Convert instruction 𝕩 to BQN code</span>
<span class="w">  </span><span class="nv">from</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨</span><span class="s2">&quot;if&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;dec&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;inc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;==&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;!=&quot;</span><span class="p">⟩</span>
<span class="w">  </span><span class="nv">to</span><span class="w">   </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨</span><span class="s2">&quot;×&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;-↩&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;+↩&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;≥&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;=&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;≤&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;≠&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="o">⊢</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># last is fallthrough</span>
<span class="w">  </span><span class="kt">{</span><span class="o">⊑</span><span class="nv">from</span><span class="o">⊐&lt;</span><span class="ni">𝕩</span><span class="kt">}</span><span class="py">◶</span><span class="nv">to</span><span class="na">¨</span><span class="ni">𝕩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
This can be conveniently done with the
<em>choose</em> (<a href="https://mlochbaum.github.io/BQN/doc/choose.html"><code>◶</code></a>) 2-modifier.
Abstractly, <code>𝔽◶𝕘 𝕩</code> applies <code>𝔽</code> to <code>𝕩</code>, which should return an index.
It then <em>picks</em> that index from the list <code>𝕘</code> (remember syntactic roles?).
This should result in a function <code>G</code>, which is then applied to <code>𝕩</code>, yielding the final result:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="py">_choose_</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">g</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⊑</span><span class="ni">𝕘</span>
<span class="w">  </span><span class="o">G</span><span class="ni">𝕩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
In this specific example, for each string in <code>𝕩</code>,
we first get its index in the <code>from</code> vector.
If the element is not found, then <em>index of</em> returns the length of the vector—an invalid index—instead.
Then, we apply the picked function in <code>to</code> to the element we started with.
In almost all cases, what’s being picked from <code>to</code> is actually a string, which is interpreted as the constant function on that value, so nothing happens.
In case the element is not found, however, we apply <em>identity</em>, in order to not lose any information.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="kt">{</span><span class="o">⊑</span><span class="nv">from</span><span class="o">⊐&lt;</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;dec&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;683&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;if&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;qn&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;==&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="w"> </span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="kt">{</span><span class="o">⊑</span><span class="nv">from</span><span class="o">⊐&lt;</span><span class="ni">𝕩</span><span class="kt">}</span><span class="py">◶</span><span class="nv">to</span><span class="na">¨</span><span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;d&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;dec&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;683&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;if&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;qn&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;==&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="w"> </span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;d&quot;</span><span class="w"> </span><span class="s2">&quot;-↩&quot;</span><span class="w"> </span><span class="s2">&quot;683&quot;</span><span class="w"> </span><span class="s2">&quot;×&quot;</span><span class="w"> </span><span class="s2">&quot;qn&quot;</span><span class="w"> </span><span class="s2">&quot;=&quot;</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Let’s get to simulating!
As I said before, <code>•BQN</code> evaluates everything in a rather sandboxed environment.
While it’s possible to inject some variable definitions into the namespace it uses,
it seemed easiest to me to just shove everything we need into a single invocation of the function.
That means lots of tasty string manipulation.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">r</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∊</span><span class="py">⊸</span><span class="o">/</span><span class="w"> </span><span class="o">⊑</span><span class="na">¨</span><span class="nv">inp</span><span class="w">        </span><span class="c1"># all registers   ⇒ ⟨ &quot;d&quot; &quot;rak&quot; … ⟩</span>
<span class="o">•BQN</span><span class="w"> </span><span class="o">∾</span><span class="p">⟨</span>
<span class="w">  </span><span class="o">∾</span><span class="w"> </span><span class="o">∾</span><span class="py">⟜</span><span class="s2">&quot;←0⋄&quot;</span><span class="na">¨</span><span class="nv">r</span><span class="w">        </span><span class="c1"># zero everything ⇒ &quot;d←0 ⋄ rak←0 ⋄ …&quot;</span>
<span class="w">  </span><span class="sr">(</span><span class="o">∾</span><span class="py">⟜</span><span class="s2">&quot;⋄&quot;</span><span class="py">⊸</span><span class="o">∾</span><span class="sr">)</span><span class="na">´</span><span class="sr">(</span><span class="o">∾C</span><span class="sr">)</span><span class="na">¨</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># instructions    ⇒ &quot;d-↩683×qn=0 ⋄ d-↩-220×h=0 ⋄ …&quot;</span>
<span class="w">  </span><span class="s2">&quot;⋄⌈´&quot;</span><span class="o">∾</span><span class="sr">(</span><span class="o">∾</span><span class="py">⟜</span><span class="s2">&quot;‿&quot;</span><span class="py">⊸</span><span class="o">∾</span><span class="sr">)</span><span class="na">´</span><span class="nv">r</span><span class="w">  </span><span class="c1"># get max         ⇒ &quot;⋄⌈´d‿rak‿…&quot;</span>
<span class="p">⟩</span><span class="w"> </span><span class="c1"># ⇒ 4416</span>
</pre></div>

<hr />
<p></p>
Part two instead asks us for the largest value that is ever held in any register during the execution of the program.
This introduces some notational, if not conceptual, difficulties—but nothing we can’t manage!
Simply introduce an additional register that contains this information,
and update it after every “normal” instruction.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">•BQN</span><span class="w"> </span><span class="o">∾</span><span class="p">⟨</span>
<span class="w">  </span><span class="s2">&quot;h_r←0⋄&quot;</span><span class="o">∾∾∾</span><span class="py">⟜</span><span class="s2">&quot;←0⋄&quot;</span><span class="na">¨</span><span class="nv">r</span><span class="w"> </span><span class="c1"># zero everything ⇒ &quot;h_r←0 ⋄ d←0 ⋄ rak←0 ⋄ …&quot;</span>
<span class="w">  </span><span class="sr">(</span><span class="o">∾</span><span class="py">⟜</span><span class="s2">&quot;⋄&quot;</span><span class="py">⊸</span><span class="o">∾</span><span class="sr">)</span><span class="na">´</span><span class="sr">(</span><span class="kt">{</span><span class="o">∾</span><span class="ni">𝕩</span><span class="o">∾</span><span class="s2">&quot;⋄h_r⌈↩&quot;</span><span class="o">∾⊑</span><span class="ni">𝕩</span><span class="kt">}</span><span class="o">C</span><span class="sr">)</span><span class="na">¨</span><span class="nv">inp</span>
<span class="w">                      </span><span class="c1"># Check highest after every instruction</span>
<span class="w">                      </span><span class="c1"># ⇒ &quot;d-↩683×qn=0 ⋄ h_r⌈↩d ⋄ d-↩-220×h=0 ⋄ h_r⌈↩d…&quot;</span>
<span class="w">  </span><span class="s2">&quot;⋄ h_r&quot;</span>
<span class="p">⟩</span><span class="w"> </span><span class="c1"># ⇒ 5199</span>
</pre></div>

<h3 id="day-9"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day09.bqn">Day 9</a><a href="#day-9" class="floatleft sec-link">§</a></h3>
<p></p>
Today, we need to clean up garbage from a stream of characters like <code>{&lt;{o"i!a,&lt;{i&lt;a&gt;e}</code>.
There are a few special characters that one needs to watch out for:
<code>{</code> and <code>}</code> delimit a group,
<code>&lt;</code> and <code>&gt;</code> start and end garbage,
and <code>!</code> ignores the next symbol.
We are given a few examples of self-contained pieces of garbage:
<blockquote>
<ul>
<li><code>&lt;&lt;&lt;&lt;&gt;</code>, because the extra < are ignored.</li>
<li><code>&lt;{!&gt;}&gt;</code>, because the first > is canceled.</li>
<li><code>&lt;!!&gt;</code>, because the second ! is canceled, allowing the > to terminate the garbage.</li>
<li><code>&lt;!!!&gt;&gt;</code>, because the second ! and the first > are canceled.</li>
</ul>
</blockquote>
<p></p>
By assumption, the whole input is one big group;
part one asks how many small groups are contained in it.
Groups are counted according to their depth, so <code>{{{}}}</code> gets a score of <code>1+2+3</code>,
and <code>{{},{}}</code> gets a score of <code>1+2+2</code>.
<p></p>
My solution here is actually quite crude and not all that interesting.
My first idea was to use regular expressions to clean up the stream<!--
-->—seems like a good fit—<!--
-->but, alas, <code>cbqn</code> does not support any sort of regexp, as far as I can tell.
Oh well.
Doing it in a single pass would be nice, though,
so let’s do what any psychopath would,
and simply pattern match on the hard-coded invariants:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Solve</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="ni">𝕩</span><span class="o">⊑</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># char 𝕊 inGarbage?‿ignored?‿depth‿score‿garbageCount</span>
<span class="w">    </span><span class="s1">'{'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="sr">(</span><span class="nv">d</span><span class="o">+¬</span><span class="nv">i</span><span class="sr">)</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
<span class="w">    </span><span class="s1">'}'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="sr">(</span><span class="nv">d</span><span class="o">-¬</span><span class="nv">i</span><span class="sr">)</span><span class="p">‿</span><span class="sr">(</span><span class="nv">s</span><span class="o">+</span><span class="nv">d</span><span class="o">×¬</span><span class="nv">i</span><span class="sr">)</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
<span class="w">    </span><span class="s1">'!'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">g</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="nv">g</span><span class="p">‿</span><span class="m">1</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
<span class="w">    </span><span class="s1">'&lt;'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
<span class="w">    </span><span class="s1">'&gt;'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="nv">i</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
<span class="w">    </span><span class="nv">cr</span><span class="w">  </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">g</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="nv">g</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="sr">(</span><span class="nv">c</span><span class="o">+</span><span class="nv">g</span><span class="o">∧¬</span><span class="nv">i</span><span class="sr">)</span>
<span class="w">  </span><span class="kt">}</span><span class="na">´</span><span class="w"> </span><span class="o">⌽•FChars</span><span class="s2">&quot;../inputs/day09.txt&quot;</span>
<span class="kt">}</span>
<span class="o">Solve</span><span class="w"> </span><span class="m">¯2</span><span class="w"> </span><span class="c1"># ⇒ 16869</span>
</pre></div>

<p></p>
It works, I guess.
Some of the invariants are packed inside of one clause;
e.g., the line
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="s1">'{'</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">d</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="sr">(</span><span class="nv">d</span><span class="o">+¬</span><span class="nv">i</span><span class="sr">)</span><span class="p">‿</span><span class="nv">s</span><span class="p">‿</span><span class="nv">c</span><span class="ni">;</span>
</pre></div>

<p></p>
adds one to the depth only if the character is not ignored
(<code>d+¬i</code> evaluates to <code>d</code> for <code>i=1</code>, and to <code>d+1</code> in case <code>i=0</code>).
<hr />
<p></p>
Part two asks us to find all non-cancelled characters hiding within the garbage.
There are some special rules in that we don’t want to count the enclosing <code>&lt;&gt;</code>’s,
but other than that this is pretty straightforward (and already included in <code>Solve</code>):
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Solve</span><span class="w"> </span><span class="m">¯1</span><span class="w"> </span><span class="c1"># ⇒ 7284</span>
</pre></div>

<h3 id="day-10"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day10.bqn">Day 10</a><a href="#day-10" class="floatleft sec-link">§</a></h3>
<p></p>
On day 10 we are asked to implement a custom hashing algorithm, based on knots.
The basis of the algorithm is a “pinch and twist” move.
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>  4--5   pinch   4  5           4   1
 /    \  5,0,1  / \/ \  twist  / \ / \
3      0  --&gt;  3      0  --&gt;  3   X   0
 \    /         \ /\ /         \ / \ /
  2--1           2  1           2   5
</pre></div>

<p></p>
Rather bravely, the problem… just gives us the instructions on how to do this with a flat list.
<blockquote>
<p></p>
To achieve this, begin with a list of numbers from 0 to 255, a current position which begins at 0 (the first element in the list), a skip size (which starts at 0), and a sequence of lengths (your puzzle input). Then, for each length:
<ul>
<li>Reverse the order of that length of elements in the list, starting with the element at the current position.</li>
<li>Move the current position forward by that length plus the skip size.</li>
<li>Increase the skip size by one.</li>
</ul>
</blockquote>
<p></p>
Part one essentially asks us to simulate our input,
and to multiply the first two numbers in the resulting list.
As written above, the puzzle input looks like <code>3, 4, 1, 5</code>, and represents the sequence of lengths.
We can (ab)use <code>•BQN</code> again to directly parse this into a vector.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•BQN</span><span class="w"> </span><span class="s1">'⟨'</span><span class="o">∾</span><span class="s1">'⟩'</span><span class="o">∾</span><span class="na">˜</span><span class="w"> </span><span class="o">⊑•FLines</span><span class="s2">&quot;../inputs/day10.txt&quot;</span>
</pre></div>

<p></p>
Simulating one round works as described above.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="c1"># One round; 𝕨: one length; 𝕩: ⟨list of marks, position, skip size⟩</span>
<span class="o">R</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">xs</span><span class="p">‿</span><span class="nv">p</span><span class="p">‿</span><span class="nv">ss</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">l</span><span class="kd">←</span><span class="o">≠</span><span class="nv">xs</span>
<span class="w">  </span><span class="p">⟨</span><span class="w"> </span><span class="o">⌽</span><span class="py">⌾</span><span class="sr">((</span><span class="nv">l</span><span class="o">|</span><span class="nv">p</span><span class="o">+↕</span><span class="nv">n</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊏</span><span class="sr">)</span><span class="nv">xs</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nv">l</span><span class="o">|</span><span class="nv">p</span><span class="o">+</span><span class="nv">n</span><span class="o">+</span><span class="nv">ss</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nv">ss</span><span class="o">+</span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="kt">}</span>
<span class="o">×</span><span class="na">´</span><span class="w"> </span><span class="m">2</span><span class="o">↑</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="sr">(</span><span class="o">↕</span><span class="m">256</span><span class="sr">)</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="o">R</span><span class="na">´</span><span class="w"> </span><span class="o">⌽</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 13760</span>
</pre></div>

<p></p>
The only thing we have to keep in mind is that indexing has to be circular.
Due to the fantastic <em>under</em> 2-modifier, this is all pretty ergonomic.
<hr />
<p></p>
Part two now wants us to implement the whole hashing algorithm.
Here’s essentially what we have to do:
<ul>
<li>Treat our input a bit differently, to get a different “length” vector;</li>
<li>repeat the algorithm from part one exactly 64 times, keeping the index and skip size intact across runs;</li>
<li>from the 256 numbers in the vector, create blocks of 16 numbers each and <span class="small-caps">xor</span> them together; and</li>
<li>convert each of the resulting 16 bytes into their hex representation.</li>
</ul>
<p></p>
Regarding the first point: we now treat every character—including the commas—of the input string as a separate input number.
So given <code>1,2,3</code> as an input, we would first transform it to <code>49 44 50 44 51</code> before continuing.
Additionally, we have to append the magic numbers <code>17 31 73 47 23</code> to the input.
This neatly showcases one of the many uses for affine characters:<!--
--><label for="sn-23" class="margin-toggle">⊕</label><input type="checkbox" id="sn-23" class="margin-toggle" /><div class="marginnote">I’m reversing the list because we have to right fold over it later.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp2</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⌽</span><span class="w"> </span><span class="p">⟨</span><span class="m">17</span><span class="p">,</span><span class="w"> </span><span class="m">31</span><span class="p">,</span><span class="w"> </span><span class="m">73</span><span class="p">,</span><span class="w"> </span><span class="m">47</span><span class="p">,</span><span class="w"> </span><span class="m">23</span><span class="p">⟩</span><span class="o">∾</span><span class="na">˜</span><span class="w"> </span><span class="ss">@</span><span class="o">-</span><span class="na">˜</span><span class="w"> </span><span class="o">⊑•FLines</span><span class="s2">&quot;../inputs/day10.txt&quot;</span>
</pre></div>

<p></p>
Since <span class="small-caps">bqn</span> does not have any format strings,
one has to implement base conversions from scratch.
Here is one from decimal to hexadecimal, specialised to one byte—always two characters, padded with <code>0</code> if need be:<!--
--><label for="sn-24" class="margin-toggle">⊕</label><input type="checkbox" id="sn-24" class="margin-toggle" /><div class="marginnote">For example,
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">DecToHex</span><span class="w"> </span><span class="m">15</span>
<span class="s2">&quot;0f&quot;</span>
<span class="w">    </span><span class="o">DecToHex</span><span class="w"> </span><span class="m">32</span>
<span class="s2">&quot;20&quot;</span>
</pre></div>
</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">DecToHex</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="s2">&quot;0123456789abcdef&quot;</span><span class="w"> </span><span class="o">⊏</span><span class="na">˜</span><span class="w"> </span><span class="m">16</span><span class="sr">(</span><span class="o">⌊</span><span class="py">∘</span><span class="o">÷</span><span class="na">˜</span><span class="w"> </span><span class="o">⋈</span><span class="w"> </span><span class="o">|</span><span class="sr">)</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
Finally, we get to <span class="small-caps">xor</span>ing!
One thing that bit me here is that <span class="small-caps">bqn</span> does not support bit operations on unsigned types, only signed and float.
As such, even though all of the numbers are 8-bit unsigned integers, we have to operate on 16-bit <em>signed</em> integers instead.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">X</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⊑⋈</span><span class="py">⊸</span><span class="sr">(</span><span class="m">16</span><span class="o">•bit</span><span class="p">.</span><span class="na">_xor</span><span class="sr">)</span><span class="na">´</span><span class="w"> </span><span class="c1"># XOR two 16 bit signed ints together</span>
</pre></div>

<p></p>
<em>Enlist</em>
(<a href="https://mlochbaum.github.io/BQN/doc/pair.html"><code>⋈</code></a>)
is needed here because at least one of the inputs to <code>•bit.xor</code> should have rank larger than zero
(no, I don’t know why).
We can now assemble all the pieces together:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">∾</span><span class="w"> </span><span class="o">DecToHex</span><span class="py">∘</span><span class="o">X</span><span class="na">¨</span><span class="w"> </span><span class="m">16</span><span class="sr">(</span><span class="o">/⥊</span><span class="na">˜</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊔</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="o">R</span><span class="na">´</span><span class="py">⟜</span><span class="nv">inp2</span><span class="py">⍟</span><span class="m">64</span><span class="w"> </span><span class="sr">(</span><span class="o">↕</span><span class="m">256</span><span class="sr">)</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span>
<span class="c1"># ⇒ &quot;2da93395f1a6bb3472203252e3b17fe5&quot;</span>
</pre></div>

<p></p>
I think the <code>n (/⥊˜)⊸⊔ xs</code> is quite cute.
We first <em>reshape</em> the number <code>n</code> into a vector <code>n n …</code> of length <code>n</code>,
and then use <em>indices</em> to create a list like <code>0 0 0 … 1 1 1 … n n n …</code>,
with each number appearing exactly <code>n</code> times.
Then we can use the vanilla <em>group</em> function to partition the given list into that many chunks.
This obviously only makes sense in this specific scenario; still, cute.
<h2 id="days-1115">Days 11–15<a href="#days-1115" class="floatleft sec-link">§</a></h2>
<h3 id="day-11"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day11.bqn">Day 11</a><a href="#day-11" class="floatleft sec-link">§</a></h3>
<p></p>
This day wants us to walk some steps on a <a href="https://en.wikipedia.org/wiki/Hexagonal_tiling">hexagonal grid</a>.
The coordinate system is defined like this:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>  \ n  /
nw +--+ ne
  /    \
-+      +-
  \    /
sw +--+ se
  / s  \
</pre></div>

<p></p>
Part one asks us to follow our input<!--
-->—which is a string of instructions where to walk, like <code>ne,sw,ne,s,…</code>—<!--
-->and then calculate a Manhattan-type distance from from the origin to the stopping point.
<p></p>
The difficult part here would be to find a comprehensible coordinate system to represent hexagonal grids.
Thankfully—or sadly?—I remember doing the exact same thing in a previous year.
I wanted to use
<a href="https://en.wikipedia.org/wiki/Hexagonal_Efficient_Coordinate_System"><span class="small-caps">hecs</span></a>
just for the name, but since all we really do is to calculate neighbours,
an <a href="https://www.redblobgames.com/grids/hexagons/#coordinates-axial">axial</a><!--
--><label for="sn-25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-25" class="margin-toggle" /><div class="sidenote">This is a phenomenal article, btw, definitely give it a read.</div><!--
--> coordinate system seems like a safer bet.
Basically, since a hex grid has three major axes that one can walk along,
we embed the grid in a cube with standard Cartesian coordinates <code>x y z</code>, with the additional constraint that <code>0=x+y+z</code>.
This in particular means that we don’t actually have to care about <code>z</code> at all.
Given any coordinate, it’s neighbours have the following offsets:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>    \ 0,¯1 /
     \    /
¯1,0  +--+  1,¯1
     /    \
 ---+      +---
     \    /
¯1,1  +--+  1,0
     /    \
    / 0, 1 \
</pre></div>

<p></p>
The Manhattan distance in this encoding is just the sum of the two coordinates.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">dirs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="s2">&quot;n&quot;</span><span class="p">‿</span><span class="s2">&quot;ne&quot;</span><span class="p">‿</span><span class="s2">&quot;se&quot;</span><span class="p">‿</span><span class="s2">&quot;s&quot;</span><span class="p">‿</span><span class="s2">&quot;sw&quot;</span><span class="p">‿</span><span class="s2">&quot;nw&quot;</span>
<span class="nv">movs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">¯1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="nv">pts</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="o">⊑</span><span class="nv">movs</span><span class="o">/</span><span class="na">˜</span><span class="sr">(</span><span class="o">&lt;</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⍷</span><span class="nv">dirs</span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="s1">','</span><span class="o">Split</span><span class="w"> </span><span class="o">⊑•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day11.txt&quot;</span>
<span class="o">+</span><span class="na">´</span><span class="o">|</span><span class="w"> </span><span class="o">+</span><span class="na">´</span><span class="nv">pts</span><span class="w"> </span><span class="c1"># ⇒ 707</span>
</pre></div>

<p></p>
We immediately translate each direction into a coordinate using a combination of <em>find</em>
(<a href="https://mlochbaum.github.io/BQN/doc/find.html"><code>⍷</code></a>)
and <em>replicate</em>,
and that’s basically it.
<hr />
<p></p>
Part two is a slight variation of this idea:
what is the furthest away we have ever been during this process?
This just means that, instead of a <em>fold</em> over the list,
we use a <em>scan</em> and take the maximum distance.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">⌈</span><span class="na">´</span><span class="w"> </span><span class="o">+</span><span class="na">´</span><span class="py">∘</span><span class="o">|</span><span class="na">¨</span><span class="w"> </span><span class="o">+</span><span class="na">`</span><span class="nv">pts</span><span class="w"> </span><span class="c1"># ⇒ 1490</span>
</pre></div>

<h3 id="day-12"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day12.bqn">Day 12</a><a href="#day-12" class="floatleft sec-link">§</a></h3>
<p></p>
It’s another graph problem!
Today, we have to help a village of processes to communicate via pipes.
The input datum is an adjacency list of nodes and their neighbours.
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>0 &lt;-&gt; 2
1 &lt;-&gt; 1
2 &lt;-&gt; 0, 3, 4
3 &lt;-&gt; 2, 4
4 &lt;-&gt; 2, 3, 6
5 &lt;-&gt; 6
6 &lt;-&gt; 4, 5
</pre></div>

<p></p>
Parsing this is not terribly difficult:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">⊑⋈</span><span class="m">2</span><span class="py">⊸</span><span class="o">↓</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="o">•BQN</span><span class="na">¨</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day12.txt&quot;</span>
<span class="c1"># ⇒ ⟨ ⟨0,⟨2⟩⟩, ⟨1,⟨1⟩⟩, ⟨2,⟨0,3,4⟩⟩, … ⟩</span>
</pre></div>

<p></p>
We first split each line on spaces, and then <code>•BQN</code> the whole thing.
This is convenient for two reasons:
it parses numbers followed by commas, like <code>10,</code>, as numbers,
and interprets the <code>&lt;-&gt;</code> part as a train, so we don’t even have to do any further filtering.
<p></p>
The first part wants us to find the path-component of <code>0</code>.
One could now think hard about how to efficiently encode a graph in <span class="small-caps">bqn</span> for these path finding types of problems…
or one could brute force the solution.
Since the input graph is not that big,
let’s just do the latter.
Starting from <code>0</code>, maintain a list of neighbours that are known to connect to it.
Then fold over the adjacency list and add the neighbours of every vertex we’ve already seen along the way.
In code (monadic <code>⍷</code> is called <em>deduplicate</em> and does what it says on the tin):
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Group</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># 𝕩: adjacency list: ⟨ ⟨n, neighbours⟩, … ⟩</span>
<span class="w">  </span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">v</span><span class="p">‿</span><span class="nv">ns</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">seen</span><span class="ni">:</span><span class="w"> </span><span class="o">⊑</span><span class="nv">v</span><span class="o">∊</span><span class="nv">seen</span><span class="ni">?</span><span class="w"> </span><span class="o">⍷</span><span class="nv">seen</span><span class="o">∾</span><span class="nv">ns</span><span class="ni">;</span><span class="w"> </span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="na">´</span><span class="w"> </span><span class="ni">𝕩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Now, the above snippet does not work at all, because obviously the list does not have to be in order.
Consider
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>3 &lt;-&gt; 1
2 &lt;-&gt; 0, 1
1 &lt;-&gt; 1, 3
0 &lt;-&gt; 2
</pre></div>

<p></p>
Calling <code>Group</code> on this input would result in <code>⟨ 0 2 1 ⟩</code>,<!--
--><label for="sn-26" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-26" class="margin-toggle" /><div class="sidenote">Or <code>⟨0 2⟩</code>, depending in which direction your list points.</div><!--
--> even though <code>3</code> is also part of the group!
To fix this we could… just run the algorithm until nothing changes?
Yes, that sounds perfectly sensible.
<p></p>
We need a helper 1-modifier <code>Fix</code>, which performs the iteration for us.<!--
--><label for="sn-27" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-27" class="margin-toggle" /><div class="sidenote">Unlike <span class="small-caps">apl</span>, <span class="small-caps">bqn</span>’s <em>repeat</em> operator does not support this out of the box.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_Fix</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝔽</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="na">_𝕣</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<details>
<summary>
I’m sure you wanted to see another gory walkthrough by someone who has no idea what they’re talking about.
</summary>
<p></p>
Let’s first start with the simpler expression
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_Fix</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
the rest is just some icing on top.
The parse tree for this does not look so bad:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>    )explain {𝕊∘⊢⍟≢⟜𝔽𝕩}
{𝕊∘⊢⍟≢⟜𝔽𝕩}
{│ │ │ ││
 𝕊∘⊢ │ ││
  └─⍟≢ ││
    └─⟜𝔽│
      ├─𝕩
──────┘
</pre></div>

<p></p>
Thus, fully parenthesised and without <em>after</em>, it looks like
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="kt">{</span><span class="w"> </span><span class="ni">𝕩</span><span class="sr">((</span><span class="o">𝕊</span><span class="py">∘</span><span class="o">⊢</span><span class="sr">)</span><span class="py">⍟</span><span class="o">≢</span><span class="sr">)</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
at which point even a simpleton like me may guess that it will execute something like
<code>𝕊𝔽𝕩 if 𝕩≢𝔽𝕩 else 𝕩</code> (remember that using Boolean expression for control flow is a thing).
<p></p>
The problem with this code is, again, that <span class="small-caps">bqn</span> does not support tail recursion.
Let’s now look at the real deal.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_Fix</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝔽</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="na">_𝕣</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
Fully parenthesised this is
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_Fix</span><span class="w"> </span><span class="kd">⇐</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="sr">(((((((</span><span class="o">𝔽</span><span class="py">∘</span><span class="o">⊢</span><span class="sr">)</span><span class="py">⍟</span><span class="o">≢</span><span class="sr">)</span><span class="py">⟜</span><span class="o">𝔽</span><span class="sr">)</span><span class="na">_𝕣</span><span class="sr">)</span><span class="py">∘</span><span class="o">⊢</span><span class="sr">)</span><span class="py">⍟</span><span class="o">≢</span><span class="sr">)</span><span class="py">⟜</span><span class="o">𝔽</span><span class="sr">)</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<p></p>
In particular, notice how we already understand almost all of this modifier!
The <code>𝔽∘⊢⍟≢⟜𝔽</code> part is the same as before, only we now don’t recurse,
but build up another level of “apply <code>𝔽</code>”.
The rest sort of also works as before—the outer <em>after</em> has the same shape—so
we are looking at
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_D</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="o">𝔽</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="kt">}</span><span class="w"> </span><span class="c1"># Double F</span>
<span class="na">_Fix</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="ni">𝕩</span><span class="sr">(((</span><span class="o">𝔽</span><span class="na">_D</span><span class="w"> </span><span class="na">_𝕣</span><span class="sr">)</span><span class="py">∘</span><span class="o">⊢</span><span class="sr">)</span><span class="py">⍟</span><span class="o">≢</span><span class="sr">)</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="kt">}</span>
</pre></div>

So if <code>𝕩≢𝔽𝕩</code>, we change the function <code>𝔽</code> to essentially <code>𝔽𝔽</code>, and then recurse.
This happens on every iteration, so we actually go from <code>𝔽</code> to <code>𝔽𝔽</code> to <code>𝔽𝔽𝔽𝔽</code>, and so on.
In short, we bring down the stack size to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>.
Neat.
</details>
<p></p>
Equipped with <code>_Fix</code>,
we can swiftly change the definition of <code>Group</code> to solve part one:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Group</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="kt">{</span><span class="w"> </span><span class="nv">v</span><span class="p">‿</span><span class="nv">ns</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">seen</span><span class="ni">:</span><span class="w"> </span><span class="o">⊑</span><span class="nv">v</span><span class="o">∊</span><span class="nv">seen</span><span class="ni">?</span><span class="w"> </span><span class="o">⍷</span><span class="nv">seen</span><span class="o">∾</span><span class="nv">ns</span><span class="ni">;</span><span class="w"> </span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="na">´</span><span class="py">⟜</span><span class="ni">𝕩</span><span class="w"> </span><span class="na">_Fix</span><span class="w"> </span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span>
<span class="kt">}</span>
<span class="o">≠Group</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 380</span>
</pre></div>

<p></p>
Because we fold over the same list every time,
we can glue it to the right side of the function using <em>after</em>.
<hr />
<p></p>
Part two tasks us with finding all of the connected components of the graph,
instead of just the one containing <code>0</code>.
For that we first need to adjust our <code>Group</code> function a little; instead of the hard-coded <code>0</code>,
let’s search for the group of the first node in the given adjacency list.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Group</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># 𝕩 = ⟨ ⟨0,⟨2⟩⟩, ⟨1,⟨1⟩⟩, ⟨2,⟨0,3,4⟩⟩, … ⟩</span>
<span class="w">  </span><span class="kt">{</span><span class="w"> </span><span class="nv">v</span><span class="p">‿</span><span class="nv">ns</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">seen</span><span class="ni">:</span><span class="w"> </span><span class="o">⊑</span><span class="nv">v</span><span class="o">∊</span><span class="nv">seen</span><span class="ni">?</span><span class="w"> </span><span class="o">⍷</span><span class="nv">seen</span><span class="o">∾</span><span class="nv">ns</span><span class="ni">;</span><span class="w"> </span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="na">´</span><span class="py">⟜</span><span class="ni">𝕩</span><span class="w"> </span><span class="na">_Fix</span><span class="w"> </span><span class="p">⟨</span><span class="o">⊑⊑</span><span class="ni">𝕩</span><span class="p">⟩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Now, we can successively obtain a single connected component, and delete it from the graph.
Since the graph is undirected, this just means looking for the nodes in our list.
For iteration, <code>•_while_</code> can be used as before:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">c</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">0</span>
<span class="kt">{</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">+</span><span class="py">⟜</span><span class="m">1</span><span class="kd">↩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="sr">(</span><span class="o">⊑</span><span class="na">¨</span><span class="py">⊸</span><span class="sr">(</span><span class="o">¬∊</span><span class="sr">)</span><span class="o">/⊣</span><span class="sr">)</span><span class="py">⟜</span><span class="o">Group</span><span class="w"> </span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="o">•_while_</span><span class="w"> </span><span class="sr">(</span><span class="p">⟨⟩</span><span class="py">⊸</span><span class="o">≢</span><span class="sr">)</span><span class="w"> </span><span class="nv">inp</span>
<span class="nv">c</span><span class="w">            </span><span class="c1"># ⇒ 181</span>
</pre></div>

<p></p>
The result of <code>Group</code> applied to <code>𝕩</code>
is a single connected component,
so we want to throw out all of these nodes.
After that, just increment the counter and move on.
The whole thing stops when the list is empty—easy!
<h3 id="day-13"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day13.bqn">Day 13</a><a href="#day-13" class="floatleft sec-link">§</a></h3>
<p></p>
We need to make our way across a firewall without being detected by packet scanners.
The firewall is represented by layers, each of which has a certain depth to it.
For example, given the input
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>0: 3
1: 2
4: 4
6: 4
</pre></div>

<p></p>
one can visualise the firewall like this:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span> 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]
</pre></div>

<p></p>
In each layer, there is a scanner starting at the top.
Every tick, it moves one layer down, bouncing off the bottom and coming up again.
We start in an imagined layer <code>¯1</code> at the very top.
Part one asks us to calculate how often we are <em>caught</em>—that is, overlap with a scanner.
Let’s quickly go through the first few steps of the simulation for the above input:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>Initial state:
     0   1   2   3   4   5   6
 () [S] [S] ... ... [S] ... [S]
    [ ] [ ]         [ ]     [ ]
    [ ]             [ ]     [ ]
                    [ ]     [ ]

Tick 1 (not caught):
 0   1   2   3   4   5   6
( ) [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

Tick 2 (caught):
 0   1   2   3   4   5   6
[ ] (S) ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]
</pre></div>

<p></p>
You get the idea.
For every layer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,
the question whether the probe is caught in step <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>l</mi></mrow><annotation encoding="application/x-tex">2(n - 1) \equiv 0 \mod l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>,
where we need to subtract <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> due to the bouncing off mechanic.
To get the score of a collision, multiply <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> together.
We can just verbatim copy this to <span class="small-caps">bqn</span>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">•BQN</span><span class="na">¨</span><span class="s1">':'</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day13.txt&quot;</span>
<span class="o">+</span><span class="na">´</span><span class="kt">{</span><span class="nv">l</span><span class="p">‿</span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="nv">l</span><span class="o">×</span><span class="nv">n</span><span class="o">×</span><span class="m">0</span><span class="o">=</span><span class="nv">l</span><span class="o">|</span><span class="na">˜</span><span class="m">2</span><span class="o">×</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="kt">}</span><span class="na">¨</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 1316</span>
</pre></div>

<hr />
<p></p>
Part two wants us to not get caught;
however, the only thing we can control is our starting time.
This would be a pretty cool problem if it were not brute forcable.
Alas, it is.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="py">⟜</span><span class="m">1</span><span class="w"> </span><span class="o">•_while_</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕊</span><span class="nv">d</span><span class="ni">:</span><span class="w"> </span><span class="o">⊑</span><span class="m">0</span><span class="o">∊</span><span class="kt">{</span><span class="nv">l</span><span class="p">‿</span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">l</span><span class="o">+</span><span class="nv">d</span><span class="sr">)</span><span class="o">|</span><span class="na">˜</span><span class="m">2</span><span class="o">×</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="kt">}</span><span class="na">¨</span><span class="nv">inp</span><span class="kt">}</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># ⇒ 3840052</span>
</pre></div>

<p></p>
The algorithm is the same as above,
only that we now have an additional delay to factor into the equation.
We iterate until we find a delay <code>d</code> such that <code>0</code> is not a member of <code>{l‿n: (l+d)|˜2×n-1}¨inp</code>;
i.e., such that we are not caught by any sensor.
<h3 id="day-14"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day14.bqn">Day 14</a><a href="#day-14" class="floatleft sec-link">§</a></h3>
<p></p>
Today we are asked to defragment a disk,
represented by a 128×128 grid,
with each square being either used or free.
It’s built like this:
given our input, e.g., <code>"abc"</code>,
create strings <code>"abc-0"</code> through <code>"abc-127"</code>.
For each of them, run the knot hash function from <a href="#day-10">day 10</a>,
convert every single hex
<a href="https://en.wikipedia.org/wiki/Nibble">nibble</a>
to its 4-digit binary representation—e.g., for <code>"0f"</code> we would get <code>"00001111"</code>—<!--
-->and merge things together into a big 128×128 matrix.
The finished grid might look a little bit like this:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>##.#.#..--&gt;
.#.#.#.#
....#.#.
#.#.##.#
.##.#...
##..#..#
.#...#..
##.#.##.--&gt;
|      |
V      V
</pre></div>

<p></p>
To get the grid representation, we first need to rewrite our solution for day 10,
and export a function to compute the knot hash of the given argument.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">KnotHash</span><span class="w"> </span><span class="kd">⇐</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">ls</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⌽</span><span class="w"> </span><span class="p">⟨</span><span class="m">17</span><span class="p">,</span><span class="w"> </span><span class="m">31</span><span class="p">,</span><span class="w"> </span><span class="m">73</span><span class="p">,</span><span class="w"> </span><span class="m">47</span><span class="p">,</span><span class="w"> </span><span class="m">23</span><span class="p">⟩</span><span class="o">∾</span><span class="na">˜</span><span class="w"> </span><span class="ni">𝕩</span><span class="o">-</span><span class="ss">@</span>
<span class="w">  </span><span class="o">∾</span><span class="w"> </span><span class="o">DecToHex</span><span class="py">∘</span><span class="o">X</span><span class="na">¨</span><span class="w"> </span><span class="m">16</span><span class="sr">(</span><span class="o">/⥊</span><span class="na">˜</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊔</span><span class="w"> </span><span class="o">⊑</span><span class="w"> </span><span class="o">R</span><span class="na">´</span><span class="py">⟜</span><span class="nv">ls</span><span class="py">⍟</span><span class="m">64</span><span class="w"> </span><span class="sr">(</span><span class="o">↕</span><span class="m">256</span><span class="sr">)</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span>
<span class="kt">}</span>
<span class="o">•Show</span><span class="w"> </span><span class="o">KnotHash</span><span class="w"> </span><span class="nv">inp2</span><span class="w"> </span><span class="c1"># ⇒ &quot;2da93395f1a6bb3472203252e3b17fe5&quot;</span>
</pre></div>

<p></p>
Nothing too unusual here,
only that exporting from a namespace works by binding with <em>export</em>
(<a href="https://mlochbaum.github.io/BQN/doc/namespace.html"><code>⇐</code></a>)
instead of <em>define</em>.
We can now import this function as we did for ones in the utility file,<!--
--><label for="sn-28" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-28" class="margin-toggle" /><div class="sidenote">Indeed, <code>utils.bqn</code> just looks like
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Split</span><span class="w"> </span><span class="kd">⇐</span><span class="w"> </span><span class="sr">(</span><span class="o">¬-</span><span class="na">˜</span><span class="o">⊢×</span><span class="m">·</span><span class="o">+</span><span class="na">`</span><span class="o">»</span><span class="py">⊸</span><span class="o">&gt;</span><span class="sr">)</span><span class="py">∘</span><span class="o">≠⊔⊢</span>
<span class="na">_Fix</span><span class="w">  </span><span class="kd">⇐</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝔽</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="na">_𝕣</span><span class="py">∘</span><span class="o">⊢</span><span class="py">⍟</span><span class="o">≢</span><span class="py">⟜</span><span class="o">𝔽</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span>
<span class="nv">tab</span><span class="w">   </span><span class="kd">⇐</span><span class="w"> </span><span class="ss">@</span><span class="o">+</span><span class="m">9</span>
<span class="nv">lf</span><span class="w">    </span><span class="kd">⇐</span><span class="w"> </span><span class="ss">@</span><span class="o">+</span><span class="m">10</span>
</pre></div>
</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">,</span><span class="na">_Fix</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="p">⟨</span><span class="o">KnotHash</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;./day10.bqn&quot;</span>
</pre></div>

<p></p>
and translate the recipe above into <span class="small-caps">bqn</span> code.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">grid</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="o">HexToBin</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w">  </span><span class="o">𝕊</span><span class="nv">p</span><span class="ni">:</span><span class="w"> </span><span class="nv">p</span><span class="o">𝕊</span><span class="p">⟨⟩</span><span class="ni">;</span><span class="w">              </span><span class="c1"># Start</span>
<span class="w">               </span><span class="m">0</span><span class="o">𝕊</span><span class="nv">r</span><span class="ni">:</span><span class="w"> </span><span class="nv">r</span><span class="o">«</span><span class="m">4</span><span class="o">⥊</span><span class="m">0</span><span class="ni">;</span><span class="w">             </span><span class="c1"># End: pad with zeros</span>
<span class="w">               </span><span class="nv">p</span><span class="o">𝕊</span><span class="nv">r</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">⌊</span><span class="nv">p</span><span class="o">÷</span><span class="m">2</span><span class="sr">)</span><span class="o">𝕊</span><span class="sr">(</span><span class="nv">r</span><span class="o">∾</span><span class="na">˜</span><span class="m">2</span><span class="o">|</span><span class="nv">p</span><span class="sr">)</span><span class="w">    </span><span class="c1"># Conversion</span>
<span class="w">             </span><span class="kt">}</span><span class="na">¨</span><span class="py">∘</span><span class="sr">(</span><span class="s2">&quot;0123456789abcdef&quot;</span><span class="py">⊸</span><span class="o">⊐</span><span class="sr">)</span><span class="w"> </span><span class="c1"># Convert hex to decimal, then to binary</span>
<span class="w">  </span><span class="o">Start</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">⊑•FLines</span><span class="s2">&quot;../inputs/day14.txt&quot;</span><span class="sr">)</span><span class="o">∾</span><span class="s2">&quot;-&quot;</span><span class="o">∾•Fmt</span>
<span class="w">  </span><span class="o">Row</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∾</span><span class="py">∘</span><span class="o">HexToBin</span><span class="py">∘</span><span class="o">KnotHash</span>
<span class="w">  </span><span class="o">&gt;Row</span><span class="py">∘</span><span class="o">Start</span><span class="na">¨</span><span class="o">↕</span><span class="m">128</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Not too many new things here.
<code>HexToBin</code> essentially runs on the same logic as a more verbose version of <code>DecToHex</code> from day 10,<!--
--><label for="sn-29" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-29" class="margin-toggle" /><div class="sidenote">That is, the first version of that code, before dzaima told me how to clean it up:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">DecToHex</span><span class="kd">←</span><span class="kt">{</span>
<span class="w">  </span><span class="ni">𝕩</span><span class="kt">{</span><span class="w"> </span><span class="m">0</span><span class="o">𝕊</span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="nv">n</span><span class="o">∾</span><span class="na">˜</span><span class="sr">(</span><span class="m">2</span><span class="o">-≠</span><span class="nv">n</span><span class="sr">)</span><span class="o">⥊</span><span class="s1">'0'</span><span class="ni">;</span>
<span class="w">     </span><span class="nv">x</span><span class="o">𝕊</span><span class="nv">n</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">⌊</span><span class="nv">x</span><span class="o">÷</span><span class="m">16</span><span class="sr">)</span><span class="o">𝕊</span><span class="sr">(</span><span class="nv">n</span><span class="o">∾</span><span class="na">˜</span><span class="s2">&quot;0123456789abcdef&quot;</span><span class="o">⊑</span><span class="na">˜</span><span class="m">16</span><span class="o">|</span><span class="nv">x</span><span class="sr">)</span>
<span class="w">  </span><span class="kt">}</span><span class="s2">&quot;&quot;</span>
<span class="kt">}</span>
</pre></div>
</div><!--
-->
and the <code>•Fmt</code> function just pretty-prints the given value to a string.
This is, however, the first time that we see an ambivalent function definition<!--
-->—one that can be called both monadically and dyadically.
The monadic case is used in lieu of an internal worker function,
like what Haskell people often call <code>go</code>.
This could have also been achieved with a construct like <code>{…}⟜⟨⟩¨…</code>, but I feel like that wouldn’t read as nicely.
<p></p>
Part one just asks us how many cells are alive:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="o">⥊</span><span class="nv">grid</span><span class="w"> </span><span class="c1"># ⇒ 8222</span>
</pre></div>

<p></p>
We need to convert the matrix into a vector first, because <em>fold</em> only works on vectors.
Alternatively, we could have also summed up all major cells separately with <em>insert</em>
(<a href="https://mlochbaum.github.io/BQN/doc/fold.html"><code>˝</code></a>),
and then summed up the resulting vector.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="o">+</span><span class="na">˝</span><span class="nv">grid</span><span class="w"> </span><span class="c1"># ⇒ 8222</span>
</pre></div>

<hr />
<p></p>
Part two is more interesting, and is probably among the top three parts for me in terms of fun.
Instead of simply counting the number of alive cells, we now need to find the number of distinct <em>regions</em>—<!--
-->live cells adjacent to each other in any of the four cardinal directions.
For example, the grid shown above would have the following regions<!--
--><label for="sn-30" class="margin-toggle">⊕</label><input type="checkbox" id="sn-30" class="margin-toggle" /><div class="marginnote">Region <code>8</code> just extends beyond the bounds of the part of the grid that we see and loops back around.</div><!--
-->
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>11.2.3..--&gt;
.1.2.3.4
....5.6.
7.8.55.9
.88.5...
88..5..8
.8...8..
88.8.88.--&gt;
|      |
V      V
</pre></div>

<p></p>
So, what do we do?
This question reminds me a little bit of a game of life–type situation,
only that we don’t have to evolve the grid.
Starting with
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">m</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">‿</span><span class="m">1</span><span class="p">‿</span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
the first step is to associate a unique number with each <code>1</code> in the grid.
One way of doing this is to <em>deshape</em> the array into a vector, and then take a +-<em>scan</em> of it.
This will only increase when another <code>1</code> is encountered:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">+</span><span class="na">`</span><span class="o">⥊</span><span class="nv">m</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">   </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊+</span><span class="na">`</span><span class="o">⥊</span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
If we now multiply with the original matrix,
all of the zeros will kill the redundant numbers in that representation.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">um</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="nv">m</span><span class="o">×</span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊+</span><span class="na">`</span><span class="o">⥊</span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
Packing this up into its own function,
a clever user of <em>under</em> takes care of all of the de- and reshaping for us.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">`</span><span class="py">⊸</span><span class="o">×</span><span class="py">⌾</span><span class="o">⥊</span>
</pre></div>

<p></p>
Now, the idea is to proceed in the following way:
take the maximum of every cell with its four neighbours<!--
-->—to get group the cell should belong to if it’s alive—<!--
-->and then multiply by the original value of the cell, to again make sure we only care about live cells.
Now, because <span class="small-caps">bqn</span> is an array language, we can do all of this for the whole array at the same time!
We can use <em>nudge</em> in either direction to get the North and South neighbour (remember that first axis stuff?),
and <em>nudge</em> <em>cells</em> to get the East and West one:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">m</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊</span><span class="m">1</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">   </span><span class="p">⟨</span><span class="o">«</span><span class="p">,</span><span class="o">»</span><span class="p">,</span><span class="o">«</span><span class="na">˘</span><span class="p">,</span><span class="o">»</span><span class="na">˘</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="o">&lt;</span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">          </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span>
<span class="w">                                          </span><span class="err">┘</span>
</pre></div>

<p></p>
There are a few things going on here.
First, we use <span class="small-caps">bqn</span>’s
<a href="https://mlochbaum.github.io/BQN/doc/functional.html">functional programming capabilities</a>,
which work just about as one would expect.<!--
--><label for="sn-31" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-31" class="margin-toggle" /><div class="sidenote">We can’t just use <code>⟨«,»,«˘,»˘⟩¨&lt;x</code>
because the <a href="https://mlochbaum.github.io/BQN/doc/expression.html#syntactic-role">syntactic role</a> of a list is a subject,
which can’t be applied as a function.</div><!--
-->
Second, we need to <em>enclose</em> <code>m</code> and make it a
<a href="https://mlochbaum.github.io/BQN/doc/enclose.html">unit array</a>,
as otherwise <em>each</em> is trying to match up the major cells of <code>m</code> with the elements of our vector (the functions).
We don’t want that, and making <code>m</code> a unit will correctly “duplicate” it to each function instead.
Finally, <em>nudge</em> correctly inserts the fill elements for the edge cases;
our grid is only 128×128 and we are not on a torus.<!--
--><label for="sn-32" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-32" class="margin-toggle" /><div class="sidenote">In that case, using <em>rotate</em> would be more appropriate.</div><!--
-->
<p></p>
Now, we can just compare every neighbour with the original value,
and kick out the zeros.
Using our <code>um</code> array from above:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">×</span><span class="nv">um</span><span class="sr">)</span><span class="o">×⌈</span><span class="na">´</span><span class="p">⟨</span><span class="o">«</span><span class="p">,</span><span class="o">»</span><span class="p">,</span><span class="o">«</span><span class="na">˘</span><span class="p">,</span><span class="o">»</span><span class="na">˘</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="o">&lt;</span><span class="nv">um</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
For kicking out the zeros we have to use
<em>signum</em> (<a href="https://mlochbaum.github.io/BQN/doc/arithmetic.html"><code>×</code></a>),
so as to not falsify the group.
Now, you may notice that this process hasn’t converged yet; <code>3</code> is in the same group as <code>4</code>,
but there wasn’t enough time for it to be swallowed up yet.
But we have a <code>_Fix</code> for that, don’t we?
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="kt">{</span><span class="w"> </span><span class="sr">(</span><span class="o">×</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">×⌈</span><span class="na">´</span><span class="p">⟨</span><span class="o">«</span><span class="p">,</span><span class="o">»</span><span class="p">,</span><span class="o">«</span><span class="na">˘</span><span class="p">,</span><span class="o">»</span><span class="na">˘</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="o">&lt;</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="na">_Fix</span><span class="w"> </span><span class="nv">um</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">4</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
To get the number of regions,
we just have to pull everything together<!--
-->—and remember to subtract one, for <code>0</code>’s region.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">g</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">g</span><span class="w"> </span><span class="sr">(</span><span class="o">+</span><span class="na">`</span><span class="py">⊸</span><span class="o">×</span><span class="py">⌾</span><span class="o">⥊</span><span class="sr">)</span><span class="kd">↩</span>
<span class="w">  </span><span class="nv">g</span><span class="w"> </span><span class="kt">{</span><span class="sr">(</span><span class="o">×</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">×⌈</span><span class="na">´</span><span class="p">⟨</span><span class="o">»</span><span class="na">˘</span><span class="p">,</span><span class="o">«</span><span class="na">˘</span><span class="p">,</span><span class="o">»</span><span class="p">,</span><span class="o">«</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="o">&lt;</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">_Fix</span><span class="kd">↩</span>
<span class="w">  </span><span class="m">1</span><span class="o">-</span><span class="na">˜</span><span class="o">+</span><span class="na">´</span><span class="o">∊⥊</span><span class="nv">g</span><span class="w"> </span><span class="c1"># Count all unique numbers minus 0</span>
<span class="kt">}</span><span class="w"> </span><span class="nv">grid</span><span class="w">     </span><span class="c1"># ⇒ 1086</span>
</pre></div>

<h3 id="day-15"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day15.bqn">Day 15</a><a href="#day-15" class="floatleft sec-link">§</a></h3>
<p></p>
For day 15 we have to help a pair of duelling generators decide which of them is malfunctioning.
Each generator produces a value in the following way:
take the previous value, multiply it by <code>16807</code> (generator A) or <code>48271</code> (generator B),
and then keep the remainder of dividing the resulting product by <code>2147483647</code>.<!--
--><label for="sn-33" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-33" class="margin-toggle" /><div class="sidenote">Notice that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2147483647</mn><mo>=</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2147483647 = 2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2147483647</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>
so this challenge was doable even for esolangs
that only support signed 32bit integers.
Nice touch.</div><!--
-->
Our puzzle input comprises the initial seeds whence this process starts.
The task for part one is to check whether the lowest 16 bits of both of these numbers match up,
and count the number of times this happens after 40 million pairs.
<p></p>
Parsing is simple.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">a</span><span class="p">‿</span><span class="nv">b</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat</span><span class="py">∘</span><span class="sr">(</span><span class="m">¯1</span><span class="py">⊸</span><span class="o">⊑</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day15.txt&quot;</span>
</pre></div>

<p></p>
The rest is similarly straightforward.
One could drop down to bit-wise operations again,
but the lowest 16 bits of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> matching up is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">x \equiv y \mod 2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>;
let’s do that instead.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">S</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">a</span><span class="p">‿</span><span class="nv">b</span><span class="p">‿</span><span class="nv">n</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">na</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">2147483647</span><span class="o">|</span><span class="nv">a</span><span class="o">×</span><span class="m">16807</span>
<span class="w">  </span><span class="nv">nb</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">2147483647</span><span class="o">|</span><span class="nv">b</span><span class="o">×</span><span class="m">48271</span>
<span class="w">  </span><span class="nv">nn</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="nv">na</span><span class="w"> </span><span class="o">=</span><span class="py">○</span><span class="sr">(</span><span class="m">65536</span><span class="py">⊸</span><span class="o">|</span><span class="sr">)</span><span class="w"> </span><span class="nv">nb</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">na</span><span class="p">,</span><span class="nv">nb</span><span class="p">,</span><span class="nv">n</span><span class="o">+</span><span class="nv">nn</span><span class="p">⟩</span>
<span class="kt">}</span>
<span class="o">S</span><span class="py">⍟</span><span class="m">40e6</span><span class="w"> </span><span class="nv">a</span><span class="p">‿</span><span class="nv">b</span><span class="p">‿</span><span class="m">0</span><span class="w"> </span><span class="c1"># ⇒ 631</span>
</pre></div>

<p></p>
We use <em>over</em>
(<a href="https://mlochbaum.github.io/BQN/doc/compose.html"><code>○</code></a>)
to apply this transformation to the two arguments,
and then check for equality (i.e., <code>𝕨𝔽○𝔾𝕩</code> is <code>(𝔾𝕨)𝔽(𝔾𝕩)</code>).
<hr />
<p></p>
Part two asks us to change up the algorithm, so that generator A only considers multiples of 4,
and generator B only cares about multiples of 8.
That is, both generators independently generate numbers until these conditions are met,
and only then are these numbers compared.
We also only have to check 5 million pairs, instead of the 40 million of part one.
First and foremost, this means that we have to decouple the comparison aspect from the generation of the numbers.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Gen</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">fac</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">n</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">res</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨⟩</span>
<span class="w">  </span><span class="kt">{</span><span class="nv">res</span><span class="o">∾</span><span class="kd">↩</span><span class="m">2147483647</span><span class="o">|</span><span class="sr">(</span><span class="m">¯1</span><span class="o">⊑⥊</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">×</span><span class="nv">fac</span><span class="kt">}</span><span class="py">⍟</span><span class="m">40e6</span><span class="w"> </span><span class="nv">n</span>
<span class="w">  </span><span class="nv">res</span><span class="w"> </span><span class="m">65536</span><span class="py">⊸</span><span class="o">|</span><span class="kd">↩</span>
<span class="kt">}</span>
<span class="nv">as</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">16807</span><span class="w"> </span><span class="o">Gen</span><span class="w"> </span><span class="nv">a</span>
<span class="nv">bs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">48271</span><span class="w"> </span><span class="o">Gen</span><span class="w"> </span><span class="nv">b</span>
</pre></div>

<p></p>
The calculations are the same as in part one, only now we use <em>change</em> to build a list that we can return.
Luckily, simply generating 40 million pairs as above and filtering for the right properties works out for us here.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">F</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">5e6</span><span class="o">↑</span><span class="sr">(</span><span class="m">0</span><span class="py">⊸</span><span class="o">=|</span><span class="sr">)</span><span class="o">/⊢</span>
<span class="o">+</span><span class="na">´</span><span class="sr">(</span><span class="m">8</span><span class="w"> </span><span class="o">F</span><span class="w"> </span><span class="nv">bs</span><span class="sr">)</span><span class="o">=</span><span class="sr">(</span><span class="m">4</span><span class="w"> </span><span class="o">F</span><span class="w"> </span><span class="nv">as</span><span class="sr">)</span><span class="w"> </span><span class="c1"># ⇒ 279</span>
</pre></div>

<h2 id="days-1620">Days 16–20<a href="#days-1620" class="floatleft sec-link">§</a></h2>
<h3 id="day-16"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day16.bqn">Day 16</a><a href="#day-16" class="floatleft sec-link">§</a></h3>
<p></p>
This day involves analysing the dance of a few programs.
Part one is about mutating a small vector—characters <code>'a'</code> through <code>'p'</code>—according to the puzzle input,
which is a single line that looks a bit like this:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>s11,x10/2,pl/d,…
</pre></div>

<p></p>
The valid moves are:
<ul>
<li><code>sA</code> rotates the vector <code>A</code> positions to the right.</li>
<li><code>xA/B</code> exchanges the positions <code>A</code> and <code>B</code>.</li>
<li><code>pA/B</code> exchanges the characters <code>A</code> and <code>B</code>.</li>
</ul>
<p></p>
So starting with just <code>abcd</code>, the sequence <code>s1,x3/4,pe/b</code> would go
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>abcd  →  eabcd  →  eabdc  →  baedc
</pre></div>

<p></p>
Parsing the moves is not terribly complicated.
The cool thing is that we can use <span class="small-caps">bqn</span>’s functional programming facilities again
and immediately translate the instructions above into functions to be applied!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="o">P</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="nv">a</span><span class="p">‿</span><span class="s2">&quot;s&quot;</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">-•ParseFloat</span><span class="w"> </span><span class="nv">a</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⌽</span><span class="ni">;</span><span class="w">                </span><span class="c1"># sA</span>
<span class="w">  </span><span class="nv">a</span><span class="p">‿</span><span class="s2">&quot;x&quot;</span><span class="ni">:</span><span class="w"> </span><span class="o">⌽</span><span class="py">⌾</span><span class="sr">((</span><span class="o">•ParseFloat</span><span class="na">¨</span><span class="s1">'/'</span><span class="o">Split</span><span class="w"> </span><span class="nv">a</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊏</span><span class="sr">)</span><span class="ni">;</span><span class="w">    </span><span class="c1"># xA/B</span>
<span class="w">  </span><span class="nv">a</span><span class="p">‿</span><span class="s2">&quot;p&quot;</span><span class="ni">:</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">xs</span><span class="ni">:</span><span class="w"> </span><span class="o">⌽</span><span class="py">⌾</span><span class="sr">((</span><span class="nv">xs</span><span class="o">⊐∾</span><span class="s1">'/'</span><span class="o">Split</span><span class="w"> </span><span class="nv">a</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊏</span><span class="sr">)</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="c1"># pA/B</span>
<span class="kt">}</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⌽</span><span class="w"> </span><span class="o">P</span><span class="py">∘</span><span class="sr">(</span><span class="m">1</span><span class="py">⊸</span><span class="sr">(</span><span class="o">↓⋈↑</span><span class="sr">))</span><span class="na">¨</span><span class="w"> </span><span class="s1">','</span><span class="o">Split</span><span class="w"> </span><span class="o">⊑•FLines</span><span class="s2">&quot;../inputs/day16.txt&quot;</span>
<span class="c1"># Reverse because we want to fold over the list later.</span>
</pre></div>

<p></p>
Since the format of the instructions is so predictable,
we can just match on the first character and decide where to go from there.
Also, the <code>1(↓⋈↑)</code> idiom returns as a useful tool yet again.
Do note the <code>xs⊐∾…</code> in the third line; we want to get the indices of the <em>characters</em>
in the string, and not the indices of a substring of length one; compare:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="s1">'/'</span><span class="o">Split</span><span class="s2">&quot;a/b&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">∾</span><span class="s1">'/'</span><span class="o">Split</span><span class="s2">&quot;a/b&quot;</span>
<span class="s2">&quot;ab&quot;</span>
<span class="w">    </span><span class="s2">&quot;abcde&quot;</span><span class="o">⊐</span><span class="s1">'/'</span><span class="o">Split</span><span class="s2">&quot;a/b&quot;</span><span class="w"> </span><span class="c1"># ⊐ returns ≠𝕨 if it can't find 𝕩 in 𝕨</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="s2">&quot;abcde&quot;</span><span class="o">⊐∾</span><span class="s1">'/'</span><span class="o">Split</span><span class="s2">&quot;a/b&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
With all of that in place,
we can successively apply all the functions to the seed value <code>abcdefghijklmnop</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="sr">(</span><span class="s1">'a'</span><span class="o">+↕</span><span class="m">16</span><span class="sr">)</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">´</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ &quot;eojfmbpkldghncia&quot;</span>
</pre></div>

<hr />
<p></p>
Part two asks us to keep the result of part one, <code>"eojfmbpkldghncia"</code>,
and repeat the whole dance one billion times.
Now, that number is obviously much too large to simulate the whole thing.
Instead, let’s try to find a loop.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">h</span><span class="w">  </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨⟩</span><span class="o">•HashMap</span><span class="p">⟨⟩</span>
<span class="nv">d</span><span class="w">  </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">´</span><span class="py">⟜</span><span class="nv">inp</span><span class="o">•_while_</span><span class="kt">{</span><span class="w"> </span><span class="sr">(</span><span class="ni">𝕩</span><span class="nv">h</span><span class="p">.</span><span class="o">Set</span><span class="ss">@</span><span class="sr">)</span><span class="w"> </span><span class="o">⊢</span><span class="w"> </span><span class="o">¬</span><span class="nv">h</span><span class="p">.</span><span class="o">Has</span><span class="ni">𝕩</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="sr">(</span><span class="s1">'a'</span><span class="o">+↕</span><span class="m">16</span><span class="sr">)</span><span class="w"> </span><span class="c1"># dup</span>
<span class="nv">di</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⊑</span><span class="sr">(</span><span class="nv">h</span><span class="p">.</span><span class="o">Keys</span><span class="ss">@</span><span class="sr">)</span><span class="o">⊐&lt;</span><span class="nv">d</span><span class="w">                                      </span><span class="c1"># dup index</span>
<span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">´</span><span class="py">⟜</span><span class="nv">inp</span><span class="py">⍟</span><span class="sr">(</span><span class="nv">di</span><span class="o">+</span><span class="sr">(</span><span class="nv">h</span><span class="p">.</span><span class="o">Count</span><span class="ss">@</span><span class="sr">)</span><span class="o">|</span><span class="m">10e9</span><span class="o">-</span><span class="nv">di</span><span class="sr">)</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="c1"># ⇒ &quot;iecopnahgdflmkjb&quot;</span>
</pre></div>

<p></p>
I used a hash map here since I figured the loop was still going to be substantial
(it wasn’t—oh well).
The test function supplied to while <code>•_while_</code> (ab)uses the fact that,
while <code>⊢</code> only ever returns <code>𝕩</code>,
it actually evaluates both of its arguments.
Remember that evaluation happens right-to-left, though;
<code>(¬h.Has𝕩) ⊣ 𝕩h.Set@</code> wouldn’t work!
<p></p>
At the end, the loop returns the first duplicate it found,
so all that’s left to do is to simulate that many steps upfront,
and then whatever we have left over.<!--
--><label for="sn-34" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-34" class="margin-toggle" /><div class="sidenote">My loop happens to start with at 0,
but I don’t know if this is universal across all inputs.</div><!--
-->
The little <code>@</code>’s after the function calls to <code>h.Count</code> and <code>h.Keys</code>
(but not to <code>h.Set</code>, as we need to associate some kind of value to the keys—that value just happens to be the null character)
function as dummy arguments.
To return something,
the upper case (function) variants need to be called,
but the argument is actually ignored.
This is a bit ugly, but sort of how <span class="small-caps">bqn</span>’s “object system”<!--
-->—which really rather seems like an accident of having a module system and syntactic roles—<!--
-->works.
<h3 id="day-17"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day17.bqn">Day 17</a><a href="#day-17" class="floatleft sec-link">§</a></h3>
<p></p>
Today we have to escape a deadly spinlock!
To do that, we have to simulate a circular buffer with the following rules:
<blockquote>
<p></p>
[The spinlock] starts with a circular buffer containing only the value 0, which it marks as the current position.
It then steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on.
The inserted value becomes the current position.
Then, it steps forward from there the same number of steps, and wherever it stops, inserts after it the second new value, 2, and uses that as the new current position again.
</blockquote>
<p></p>
All in all, we have to insert the numbers 0 to 2017 in this way.
For example, suppose our puzzle input was <code>3</code>.
Using <code>()</code> to indicate the current position, the list would grow thusly:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>(0)  →  0 (1)  →  0 (2) 1  →  0 2 (3) 1  →  …
</pre></div>

<p></p>
Part one asks us for the value after 2017 in the final buffer.
<p></p>
With a puzzle input of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> and a position <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> in step <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,
the stepping forward process is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mi>n</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 + (p + n \mod i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span><!--
-->—the list is exactly of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> in that step—<!--
-->and inserting after the element means adding one.
As such, a straightforward solution for part one looks like this:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">n</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat⊑•FLines</span><span class="s2">&quot;../inputs/day17.txt&quot;</span>
<span class="sr">((</span><span class="m">1</span><span class="o">+⊑</span><span class="sr">)</span><span class="o">⊐</span><span class="py">⟜</span><span class="m">2017</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊑</span><span class="w"> </span><span class="m">¯1</span><span class="o">⊑</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="nv">p</span><span class="p">‿</span><span class="nv">b</span><span class="ni">:</span><span class="w">         </span><span class="c1"># index, position, buffer</span>
<span class="w">  </span><span class="nv">np</span><span class="kd">←</span><span class="m">1</span><span class="o">+</span><span class="nv">i</span><span class="o">|</span><span class="nv">p</span><span class="o">+</span><span class="nv">n</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">np</span><span class="p">,</span><span class="sr">(</span><span class="nv">np</span><span class="o">↑</span><span class="nv">b</span><span class="sr">)</span><span class="o">∾</span><span class="nv">i</span><span class="o">∾</span><span class="nv">np</span><span class="o">↓</span><span class="nv">b</span><span class="p">⟩</span>
<span class="kt">}</span><span class="py">⍟</span><span class="m">2017</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">‿⟨</span><span class="m">0</span><span class="p">⟩</span><span class="w">                        </span><span class="c1"># ⇒ 1487</span>
</pre></div>

<p></p>
However, this feel immensely unsatisfactory to me.
Repeatedly breaking apart an array and assembling it again (<code>(np↑b)∾i∾np↓b</code>) sort of signals that something must be amiss.
Instead, it would be much better to not have to care about the position at all,
always insert the element at the front, and rotate the array instead.
After entirely too much thinking, something pops up.
Say we only looked at the small example above of going from <code>(0)</code> to <code>0 2 (3) 1</code>.
Again starting with <code>⟨0⟩</code>,
we can do the following:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">Rot</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">xs</span><span class="o">𝕊</span><span class="nv">i</span><span class="ni">:</span><span class="w"> </span><span class="nv">i</span><span class="o">∾</span><span class="sr">(</span><span class="m">3</span><span class="o">+</span><span class="m">1</span><span class="sr">)</span><span class="o">⌽</span><span class="nv">xs</span><span class="w"> </span><span class="kt">}</span>
<span class="sr">(</span><span class="nv">function</span><span class="w"> </span><span class="nv">block</span><span class="sr">)</span>
<span class="w">    </span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">1</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">1</span><span class="sr">)</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">2</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">((</span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">1</span><span class="sr">)</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">2</span><span class="sr">)</span><span class="w"> </span><span class="o">Rot</span><span class="w"> </span><span class="m">3</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
The final result, <code>3 1 0 2</code> is indeed—up to circular permutation—the same as <code>0 2 3 1</code>!
The <code>3+1</code> comprises the step size <code>3</code>, and keeps track of the fact that we need to insert the value after the index.
Even more, the final inserted value will be the head of the vector,
so getting the element at index <code>1</code> is what we want—no more <em>select</em>ing stuff.
Do note that walking to the <em>right</em> in terms of indices translates to rotating the buffer to the <em>left</em> (i.e., using positive numbers).
We can pack this function up in a fold, yielding an alternative solution for part one:<!--
--><label for="sn-35" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-35" class="margin-toggle" /><div class="sidenote">I suppose inserting <code>i</code> in the back of the array would be cheaper:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="m">¯2</span><span class="o">⊑</span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="kt">{</span><span class="ni">𝕨</span><span class="o">∾</span><span class="na">˜</span><span class="sr">(</span><span class="o">-</span><span class="nv">n</span><span class="o">+</span><span class="m">1</span><span class="sr">)</span><span class="o">⌽</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">´</span><span class="o">⌽</span><span class="m">1</span><span class="o">+↕</span><span class="m">2017</span>
</pre></div>

<p></p>
However, this doesn’t really matter;
we need a different solution for part two either way.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="m">1</span><span class="o">⊑</span><span class="p">⟨</span><span class="m">0</span><span class="p">⟩</span><span class="kt">{</span><span class="ni">𝕨</span><span class="o">∾</span><span class="sr">(</span><span class="nv">n</span><span class="o">+</span><span class="m">1</span><span class="sr">)</span><span class="o">⌽</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">´</span><span class="o">⌽</span><span class="m">1</span><span class="o">+↕</span><span class="m">2017</span><span class="w"> </span><span class="c1"># ⇒ 1487</span>
</pre></div>

<hr />
<p></p>
Part two now wants us to identify the value following <code>0</code>—after fifty million iterations!
This is much too big to simulate in the same way as the first part.
Instead, we can come back to the formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mi>n</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 + (p + n \mod i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>
that predicts the index at which a given number is going to be inserted.
We can use a <em>scan</em> over the vector to get that index for each insertion.
Since the steps are increasing, the solution looks for the last time a <code>1</code> was inserted.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">⊑</span><span class="w"> </span><span class="sr">(</span><span class="o">≠-⊐</span><span class="py">⟜</span><span class="m">1</span><span class="py">∘</span><span class="o">⌽</span><span class="sr">)</span><span class="w"> </span><span class="m">0</span><span class="kt">{</span><span class="m">1</span><span class="o">+</span><span class="ni">𝕩</span><span class="o">|</span><span class="nv">n</span><span class="o">+</span><span class="ni">𝕨</span><span class="kt">}</span><span class="na">`</span><span class="m">1</span><span class="o">+↕</span><span class="m">50e6</span><span class="w"> </span><span class="c1"># ⇒ 25674054</span>
</pre></div>

<details>
<summary>
This is the first time that we use a non-associative scan, so a few words of warning.
</summary>
<p></p>
While <em>fold</em> is consuming its input array in the same direction as <span class="small-caps">bqn</span>’s evaluation model—right-to-left—<em>scan</em> is evaluating its argument left-to-right!
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="o">-</span><span class="m">15</span><span class="p">,</span><span class="w"> </span><span class="sr">(</span><span class="m">10</span><span class="o">-</span><span class="m">15</span><span class="sr">)</span><span class="o">-</span><span class="m">9</span><span class="p">⟩</span><span class="w"> </span><span class="o">≡</span><span class="w"> </span><span class="o">-</span><span class="na">`</span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="m">15</span><span class="p">,</span><span class="m">9</span><span class="p">⟩</span>
<span class="m">1</span>
<span class="w">    </span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="o">-</span><span class="m">15</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="o">-</span><span class="m">15</span><span class="o">-</span><span class="m">9</span><span class="p">⟩</span><span class="w">   </span><span class="o">≡</span><span class="w"> </span><span class="o">-</span><span class="na">`</span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="m">15</span><span class="p">,</span><span class="m">9</span><span class="p">⟩</span>
<span class="m">0</span>
</pre></div>

<p></p>
As such, the default argument in a scan is given as the initial <em>left</em> argument,
instead of the initial right one as in a fold:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="p">⟨</span><span class="m">20</span><span class="o">-</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="sr">(</span><span class="m">20</span><span class="o">-</span><span class="m">10</span><span class="sr">)</span><span class="o">-</span><span class="m">15</span><span class="p">,</span><span class="w"> </span><span class="sr">((</span><span class="m">20</span><span class="o">-</span><span class="m">10</span><span class="sr">)</span><span class="o">-</span><span class="m">15</span><span class="sr">)</span><span class="o">-</span><span class="m">9</span><span class="p">⟩</span><span class="w"> </span><span class="o">≡</span><span class="w"> </span><span class="m">20</span><span class="o">-</span><span class="na">`</span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="m">15</span><span class="p">,</span><span class="m">9</span><span class="p">⟩</span>
<span class="m">1</span>
<span class="w">    </span><span class="sr">(</span><span class="m">10</span><span class="o">-</span><span class="sr">(</span><span class="m">15</span><span class="o">-</span><span class="sr">(</span><span class="m">9</span><span class="o">-</span><span class="m">20</span><span class="sr">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">20</span><span class="o">-</span><span class="na">´</span><span class="p">⟨</span><span class="m">10</span><span class="p">,</span><span class="m">15</span><span class="p">,</span><span class="m">9</span><span class="p">⟩</span>
<span class="m">1</span>
</pre></div>

<p></p>
The reason this is done is more of a pragmatic one,
from what I can tell:
left scans are simply more common than right ones.
One may argue the same for left over right folds, actually,
but I suppose the æsthetics of having <code>20-´⟨10,15,9⟩</code> be <code>10-15-9-20</code> won out there.
</details>
<p></p>
Other than that, the train <code>≠-⊐⟜1∘⌽</code> computes the first occurrence of <code>1</code> in the reversed vector,
and then corrects the index by subtracting it from the length of the vector.
<h3 id="day-18"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day18.bqn">Day 18</a><a href="#day-18" class="floatleft sec-link">§</a></h3>
<p></p>
Today we have to simulate some assembly in order to play music!
The computer has 16 registers, all starting at 0,
with the instructions being as follows:
<blockquote>
<ul>
<li><code>snd X</code> plays a sound with a frequency equal to the value of <code>X</code>.</li>
<li><code>set X Y</code> sets register <code>X</code> to the value of <code>Y</code>.</li>
<li><code>add X Y</code> increases register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mul X Y</code> sets register <code>X</code> to the result of multiplying the value contained in register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mod X Y</code> sets register <code>X</code> to the remainder of dividing the value contained in register <code>X</code> by the value of <code>Y</code> (that is, it sets <code>X</code> to the result of <code>X</code> modulo <code>Y</code>).</li>
<li><code>rcv X</code> recovers the frequency of the last sound played, but only when the value of <code>X</code> is not zero. (If it is zero, the command does nothing.)</li>
<li><code>jgz X Y</code> jumps with an offset of the value of <code>Y</code>, but only if the value of <code>X</code> is greater than zero. (An offset of <code>2</code> skips the next instruction, an offset of <code>-1</code> jumps to the previous instruction, and so on.)</li>
</ul>
</blockquote>
<p></p>
Our input consists of one instruction on each line; for example:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>set a 1
add a 2
mul a a
mod a 5
…
</pre></div>

<p></p>
Part one asks us what value is recovered the first time an <code>rcv</code> instruction is actually executed
(i.e., called with a non-zero argument).
Let’s first to some parsing.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="kd">←</span><span class="o">•Import</span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat</span><span class="py">⎊</span><span class="o">⊢</span><span class="na">¨</span><span class="py">∘</span><span class="sr">(</span><span class="s1">' '</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="o">•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day18.txt&quot;</span>
</pre></div>

<p></p>
Note the <code>•ParseFloat⎊⊢</code>.
We’ve used <em>catch</em> before on <a href="#day-7">day 7</a>, but for a different reason.
Here, we use it as a shorthand to parse a number if possible, and return the argument as-is otherwise.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">•ParseFloat</span><span class="py">⎊</span><span class="o">⊢</span><span class="na">¨</span><span class="w"> </span><span class="s1">' '</span><span class="o">Split</span><span class="s2">&quot;set a 102&quot;</span>
<span class="p">⟨</span><span class="w"> </span><span class="s2">&quot;set&quot;</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="m">102</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Simulating an instruction is easy—if verbose—for the most part;
the only slight challenge is that we have instructions along the lines of <code>mul a 2</code>, as well as <code>mul a a</code>;
in the latter case, we first need to get the current value out of register <code>a</code> before execution.
An easy way to do this is to match on the
<a href="https://mlochbaum.github.io/BQN/spec/system.html#operation-properties"><code>•Type</code></a>
of the argument.
The function returns <code>1</code> for integers,
in which case we just take the value;
otherwise, we can look it up as a register.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">V</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="m">1</span><span class="o">=•Type</span><span class="w"> </span><span class="ni">𝕩?</span><span class="w"> </span><span class="ni">𝕩;</span><span class="w"> </span><span class="sr">(</span><span class="o">⊑</span><span class="ni">𝕩</span><span class="o">-</span><span class="s2">&quot;a&quot;</span><span class="sr">)</span><span class="o">⊑</span><span class="ni">𝕨</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="c1"># [V]alue, 𝕨=arr, 𝕩=el</span>
</pre></div>

<p></p>
The registers <code>a…p</code> are translated into indices <code>0…15</code> in the usual way.
All that’s left to do is to write a change modifier.
It takes the vector of registers, a function <code>F</code>, and an <code>x‿y</code> pair,
and changes <code>x</code> to <code>x F y</code>.
<em>Under</em> is quite nice for these sorts of things.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_C</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">regs</span><span class="w"> </span><span class="o">F</span><span class="w"> </span><span class="na">_𝕣</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="ni">:</span><span class="w"> </span><span class="o">F</span><span class="py">⟜</span><span class="sr">(</span><span class="nv">regs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">y</span><span class="sr">)</span><span class="py">⌾</span><span class="sr">((</span><span class="o">⊑</span><span class="nv">x</span><span class="o">-</span><span class="s2">&quot;a&quot;</span><span class="sr">)</span><span class="py">⊸</span><span class="o">⊑</span><span class="sr">)</span><span class="w"> </span><span class="nv">regs</span><span class="w"> </span><span class="kt">}</span><span class="w"> </span><span class="c1"># [C]hange</span>
</pre></div>

<p></p>
Finally, here is the rest of the simulation.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">snd</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">0</span>
<span class="o">SD</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="p">⟨</span><span class="nv">ix</span><span class="p">,</span><span class="nv">regs</span><span class="p">,</span><span class="nv">ins</span><span class="p">‿</span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="p">⟩</span><span class="ni">:</span>
<span class="w">  </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="s2">&quot;set&quot;</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="w">  </span><span class="o">⊢</span><span class="na">_C</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="s2">&quot;add&quot;</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="w">  </span><span class="o">+</span><span class="na">_C</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="s2">&quot;mul&quot;</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="w">  </span><span class="o">×</span><span class="na">_C</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="s2">&quot;mod&quot;</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="w"> </span><span class="o">|</span><span class="na">˜_C</span><span class="w"> </span><span class="nv">x</span><span class="p">‿</span><span class="nv">y</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="s2">&quot;jgz&quot;</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="o">&lt;</span><span class="nv">regs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">x</span><span class="ni">?</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="nv">regs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">y</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">    </span><span class="o">𝕊</span><span class="s2">&quot;jgz&quot;</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="p">⟩</span>
<span class="w">  </span><span class="kt">}</span><span class="w"> </span><span class="nv">ins</span>
<span class="kt">}</span>
<span class="o">One</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="o">𝕊</span><span class="p">⟨</span><span class="nv">ix</span><span class="p">,</span><span class="nv">regs</span><span class="p">,</span><span class="nv">ins</span><span class="p">‿</span><span class="nv">x</span><span class="p">⟩</span><span class="ni">:</span>
<span class="w">    </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="s2">&quot;snd&quot;</span><span class="ni">:</span><span class="w"> </span><span class="nv">snd</span><span class="kd">↩</span><span class="nv">regs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">      </span><span class="o">𝕊</span><span class="s2">&quot;rcv&quot;</span><span class="ni">:</span><span class="w"> </span><span class="nv">snd</span><span class="o">!</span><span class="m">0</span><span class="o">=</span><span class="nv">regs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">regs</span><span class="p">⟩</span>
<span class="w">    </span><span class="kt">}</span><span class="w"> </span><span class="nv">ins</span><span class="ni">;</span>
<span class="w">  </span><span class="o">SD</span><span class="w"> </span><span class="ni">𝕩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Quite a lot of code!<!--
--><label for="sn-36" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-36" class="margin-toggle" /><div class="sidenote">In fact, since simulating these instructions is so verbose,
the file contains 36 lines of pure code (without comments or empty lines)!
This is not only 15 more lines than the second place, <a href="#day-7">day 7</a>,
but a big anomaly in general;
the average is around 12 lines, and the median is 11:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">((</span><span class="o">+</span><span class="na">´</span><span class="o">÷≠</span><span class="sr">)</span><span class="o">⋈</span><span class="kt">{</span><span class="sr">(</span><span class="o">⌊</span><span class="m">2</span><span class="o">÷</span><span class="na">˜</span><span class="o">≠</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⊑∨</span><span class="ni">𝕩</span><span class="kt">}</span><span class="sr">)</span><span class="kt">{</span><span class="o">•BQN</span><span class="s2">&quot;⟨&quot;</span><span class="o">∾</span><span class="ni">𝕩</span><span class="o">∾</span><span class="s2">&quot;⟩&quot;</span><span class="kt">}</span><span class="m">1</span><span class="o">⊑•SH</span><span class="p">⟨</span>
<span class="w">      </span><span class="s2">&quot;/bin/sh&quot;</span>
<span class="w">      </span><span class="s2">&quot;-c&quot;</span>
<span class="w">      </span><span class="s2">&quot;tokei -f «path» \</span>
<span class="s2">        | awk '{ print $3 }' \</span>
<span class="s2">        | head -n-3 | tail -n25&quot;</span>
<span class="w">    </span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">11.6</span><span class="w"> </span><span class="m">11</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>
</div><!--
-->
However, nothing very interesting happening here;
we use <em>assert</em> (<code>!</code>) in the same way as in <a href="#day-7">day 7</a>,
only that we now have a genuine condition to test.
Recall that <code>𝕨!𝕩</code> checks whether <code>𝕩</code> is 1.
If it is, nothing happens;
if it’s not, an exception with value <code>𝕨</code> is thrown.
We use it here so that we immediately exit upon receiving<!--
--><label for="sn-37" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-37" class="margin-toggle" /><div class="sidenote">Foreshadowing.</div><!--
--> our first recovery signal.
As in any other “simulate indexing into this array”–type situations,
<code>•_while_</code> is used for iteration,
only this time we have to wrap the whole thing inside of <em>catch</em>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="nv">r</span><span class="ni">:</span><span class="w"> </span><span class="o">One</span><span class="p">⟨</span><span class="nv">i</span><span class="p">,</span><span class="nv">r</span><span class="p">,</span><span class="nv">i</span><span class="o">⊑</span><span class="nv">inp</span><span class="p">⟩</span>
<span class="kt">}</span><span class="o">•_while_</span><span class="kt">{</span>
<span class="w">  </span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="m">·</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="nv">i</span><span class="o">≥</span><span class="m">0</span><span class="sr">)</span><span class="o">∧</span><span class="nv">i</span><span class="o">&lt;≠</span><span class="nv">inp</span>
<span class="kt">}</span><span class="py">⎊</span><span class="o">•CurrentError</span><span class="w"> </span><span class="p">⟨</span><span class="m">0</span><span class="p">,</span><span class="m">16</span><span class="o">⥊</span><span class="m">0</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># ⇒ 9423</span>
</pre></div>

<hr />
<p></p>
Part two informs us that we actually completely misunderstood the instructions.
In reality, the assembly is about simulating a concurrent system comprising of program <code>0</code> and program <code>1</code>.
The simulations run completely separately,
save for the “send” and “receive”—instead of “sound” and “recover”—instructions they use to communicate:
<blockquote>
<ul>
<li>snd X sends the value of X to the other program. These values wait in a queue until that program is ready to receive them. Each program has its own message queue, so a program can never receive a message it sent.</li>
<li>rcv X receives the next value and stores it in register X. If no values are in the queue, the program waits for a value to be sent to it. Programs do not continue to the next instruction until they have received a value. Values are received in the order they are sent.</li>
</ul>
</blockquote>
<p></p>
Further, program <code>1</code> starts with a <code>1</code> in its last register.
Our task is to simulate both programs until they deadlock<!--
-->—both are stuck on <code>rcv</code> calls but both send queues are empty—<!--
-->and count the number of times program <code>1</code> pushed something to program <code>0</code>’s queue.
<p></p>
Are you ready to simulate concurrency in an array language?
I wasn’t.
Anyways, my idea was to run both programs in lockstep, with two lists of additional state that we have to keep track of.
This is only important for <code>snd</code> and <code>rcv</code>—the other instructions don’t have to change.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Two</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># my queue, other queue, index, registers, instruction</span>
<span class="w">  </span><span class="c1"># Push to other queue.</span>
<span class="w">  </span><span class="o">𝕊</span><span class="p">⟨</span><span class="nv">my</span><span class="p">,</span><span class="nv">ot</span><span class="p">,</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">,</span><span class="s2">&quot;snd&quot;</span><span class="p">‿</span><span class="nv">x</span><span class="p">⟩</span><span class="ni">:</span><span class="w"> </span><span class="nv">ot</span><span class="o">∾</span><span class="kd">↩</span><span class="nv">rs</span><span class="w"> </span><span class="o">V</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">my</span><span class="p">,</span><span class="w"> </span><span class="nv">ot</span><span class="p">,</span><span class="w"> </span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">rs</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">  </span><span class="c1"># Don't advance on empty queue.</span>
<span class="w">  </span><span class="o">𝕊</span><span class="p">⟨⟨⟩,</span><span class="nv">ot</span><span class="p">,</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">,</span><span class="s2">&quot;rcv&quot;</span><span class="p">‿</span><span class="nv">x</span><span class="p">⟩</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨⟨⟩,</span><span class="nv">ot</span><span class="p">,</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">⟩</span><span class="ni">;</span>
<span class="w">  </span><span class="c1"># Pop from my queue.</span>
<span class="w">  </span><span class="o">𝕊</span><span class="p">⟨</span><span class="nv">my</span><span class="p">,</span><span class="nv">ot</span><span class="p">,</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">,</span><span class="s2">&quot;rcv&quot;</span><span class="p">‿</span><span class="nv">x</span><span class="p">⟩</span><span class="ni">:</span><span class="w"> </span><span class="nv">q</span><span class="p">‿</span><span class="nv">qs</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">1</span><span class="sr">(</span><span class="o">↑⋈↓</span><span class="sr">)</span><span class="nv">my</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">qs</span><span class="p">,</span><span class="w"> </span><span class="nv">ot</span><span class="p">,</span><span class="w"> </span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">rs</span><span class="o">⊢</span><span class="na">_C</span><span class="p">⟨</span><span class="nv">x</span><span class="p">,</span><span class="o">⊑</span><span class="nv">q</span><span class="p">⟩⟩</span><span class="ni">;</span>
<span class="w">  </span><span class="o">𝕊</span><span class="p">⟨</span><span class="nv">my</span><span class="p">,</span><span class="nv">ot</span><span class="p">,</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">,</span><span class="nv">ins</span><span class="p">⟩</span><span class="w">    </span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">my</span><span class="p">,</span><span class="nv">ot</span><span class="p">⟩</span><span class="o">∾SD</span><span class="p">⟨</span><span class="nv">ix</span><span class="p">,</span><span class="nv">rs</span><span class="p">,</span><span class="nv">ins</span><span class="p">⟩</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Now all we have to do is take a deep breath and write the following code.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="c1"># Concurrency at home:</span>
<span class="o">⊑</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">s1</span><span class="p">‿</span><span class="nv">q0</span><span class="p">‿</span><span class="nv">q1</span><span class="p">‿</span><span class="nv">i1</span><span class="p">‿</span><span class="nv">r1</span><span class="p">‿</span><span class="nv">i2</span><span class="p">‿</span><span class="nv">r2</span><span class="p">‿</span><span class="nv">xs</span><span class="ni">:</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">q0</span><span class="p">,</span><span class="nv">q1</span><span class="p">,</span><span class="nv">i1</span><span class="p">,</span><span class="nv">r1</span><span class="p">⟩</span><span class="w"> </span><span class="kd">↩</span><span class="w"> </span><span class="o">Two</span><span class="p">⟨</span><span class="nv">q0</span><span class="p">,</span><span class="nv">q1</span><span class="p">,</span><span class="nv">i1</span><span class="p">,</span><span class="nv">r1</span><span class="p">,</span><span class="nv">i1</span><span class="o">⊑</span><span class="nv">xs</span><span class="p">⟩</span>
<span class="w">  </span><span class="nv">old0</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">≠</span><span class="nv">q0</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">q1</span><span class="p">,</span><span class="nv">q0</span><span class="p">,</span><span class="nv">i2</span><span class="p">,</span><span class="nv">r2</span><span class="p">⟩</span><span class="w"> </span><span class="kd">↩</span><span class="w"> </span><span class="o">Two</span><span class="p">⟨</span><span class="nv">q1</span><span class="p">,</span><span class="nv">q0</span><span class="p">,</span><span class="nv">i2</span><span class="p">,</span><span class="nv">r2</span><span class="p">,</span><span class="nv">i2</span><span class="o">⊑</span><span class="nv">xs</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># q0 and q1 swap here</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">s1</span><span class="o">+</span><span class="nv">old0</span><span class="o">&lt;≠</span><span class="nv">q0</span><span class="p">,</span><span class="nv">q0</span><span class="p">,</span><span class="nv">q1</span><span class="p">,</span><span class="nv">i1</span><span class="p">,</span><span class="nv">r1</span><span class="p">,</span><span class="nv">i2</span><span class="p">,</span><span class="nv">r2</span><span class="p">,</span><span class="nv">xs</span><span class="p">⟩</span>
<span class="kt">}</span><span class="o">•_while_</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="m">·</span><span class="p">‿</span><span class="nv">q0</span><span class="p">‿</span><span class="nv">q1</span><span class="p">‿</span><span class="nv">i1</span><span class="p">‿</span><span class="m">·</span><span class="p">‿</span><span class="nv">i2</span><span class="p">‿</span><span class="m">·</span><span class="p">‿</span><span class="nv">xs</span><span class="ni">:</span>
<span class="w">  </span><span class="o">∨</span><span class="na">´</span><span class="p">⟨</span><span class="w"> </span><span class="nv">q0</span><span class="o">≢</span><span class="p">⟨⟩,</span><span class="w"> </span><span class="nv">q1</span><span class="o">≢</span><span class="p">⟨⟩,</span><span class="w"> </span><span class="s2">&quot;rcv&quot;</span><span class="o">≢⊑</span><span class="nv">i1</span><span class="o">⊑</span><span class="nv">xs</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;rcv&quot;</span><span class="o">≢⊑</span><span class="nv">i2</span><span class="o">⊑</span><span class="nv">xs</span><span class="w"> </span><span class="p">⟩</span>
<span class="kt">}</span><span class="w"> </span><span class="p">⟨</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="p">⟨⟩,⟨⟩,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="sr">(</span><span class="m">15</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="sr">(</span><span class="m">15</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">inp</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># ⇒ 7620</span>
</pre></div>

<p></p>
<code>s1</code> keeps track of how many times program <code>1</code> sent a signal;
the two <code>q</code>’s are the queues; and
the two <code>i</code>’s and <code>r</code>’s correspond to the respective indices and registers.
We simulate the whole thing until a deadlock occurs as per the above considerations.
Technically, I guess, both programs could also run to completion,
so there would have to be some extra index shenanigans in the check,
but this doesn’t happen for my input so I’m going to pretend it never does.
<h3 id="day-19"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day19.bqn">Day 19</a><a href="#day-19" class="floatleft sec-link">§</a></h3>
<p></p>
For day 19 we have to help a network packet traverse a routing diagram.
The diagram we get is pretty self-explanatory; an example
(the real path is much more complicated)
looks like this:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>     |
     |  +--+
     A  |  C
 F---|----E|--+
     |  |  |  D
     +B-+  +--+
</pre></div>

<p></p>
The question lets us know that there will be a unique line connected to the top,
which is our starting point.
This in particular means that we will start out going down.
Letters are simply passed through, and the path we can take is always unique;
we only change directions when absolutely necessary.
<p></p>
Part one asks what letters we see in order.
This is a straightforward simulation, so let’s get to it;
first, parsing and massaging the input:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="kd">←</span><span class="o">•Import</span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">⌽⍉</span><span class="py">∘</span><span class="sr">(</span><span class="kt">{</span><span class="sr">(</span><span class="s1">' '</span><span class="o">⥊</span><span class="na">˜</span><span class="o">≠</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">∾⌽⍉</span><span class="ni">𝕩</span><span class="kt">}</span><span class="py">⍟</span><span class="m">3</span><span class="sr">)</span><span class="w"> </span><span class="o">&gt;•FLines</span><span class="s2">&quot;../inputs/day19.txt&quot;</span>
</pre></div>

<p></p>
We pad the input matrix with spaces on the right, bottom, and left, in order to make changing directions easier.
This way, we only have to check if the next cell is a space character;
since we never move into that space, we don’t have to special case indexing around the edges of the array.
<details>
<summary>
The <code>⌽⍉</code> bit is a neat trick to compute all rotations of a matrix.
</summary>
<p></p>
When padding the input,
we essentially want to rotate the matrix by 90 degrees three times,
and add spaces afterwards.
It is well known that every rotation is merely the product of two reflections,
like
<em>reverse</em> (<a href="https://mlochbaum.github.io/BQN/doc/reverse.html#reverse"><code>⌽</code></a>) and
<em>transpose</em> (<a href="https://mlochbaum.github.io/BQN/doc/transpose.html"><code>⍉</code></a>).
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">m</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">3</span><span class="p">‿</span><span class="m">3</span><span class="o">⥊↕</span><span class="m">9</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⍉</span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">6</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">7</span>
<span class="w">  </span><span class="m">2</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⌽</span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
Depending on whether we rotate or transpose first,
we turn either right or left.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span>
<span class="w">  </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⌽⍉</span><span class="w"> </span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">7</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">6</span>
<span class="w">        </span><span class="err">┘</span>
<span class="w">    </span><span class="o">⍉⌽</span><span class="w"> </span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">7</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">8</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">2</span>
<span class="w">        </span><span class="err">┘</span>
</pre></div>

<p></p>
Doing this four times gives us every rotation of the matrix:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">⍉⌽</span><span class="sr">)</span><span class="py">⍟</span><span class="sr">(</span><span class="o">↕</span><span class="m">4</span><span class="sr">)</span><span class="w"> </span><span class="nv">m</span>
<span class="err">┌─</span>
<span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">6</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">8</span>
<span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w">     </span><span class="m">7</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">5</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">3</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">7</span>
<span class="w">    </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w">     </span><span class="m">8</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">6</span>
<span class="w">          </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span>
<span class="w">                                          </span><span class="err">┘</span>
</pre></div>

<p></p>
Padding all of the sides can be done during this rotation
by just adding the elements with which to pad in the right quantity (the number of major cells) to every side:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="kt">{</span><span class="sr">((</span><span class="o">≠</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⥊</span><span class="m">0</span><span class="sr">)</span><span class="o">∾⌽⍉</span><span class="ni">𝕩</span><span class="kt">}</span><span class="py">⍟</span><span class="m">4</span><span class="w"> </span><span class="nv">m</span><span class="w">  </span><span class="c1"># Pad every side</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">            </span><span class="err">┘</span>
</pre></div>

</details>
<p></p>
Changing direction involves picking the unique (per the question) next direction to go in.
In particular, we never want to turn around.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">ND</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">dir</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">ds</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">&lt;</span><span class="m">¯1</span><span class="o">×</span><span class="nv">dir</span><span class="sr">)(</span><span class="o">¬</span><span class="py">∘</span><span class="o">⍷/⊢</span><span class="sr">)</span><span class="p">⟨</span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">¯1</span><span class="p">⟩</span><span class="w"> </span><span class="c1"># Not where we came from</span>
<span class="w">  </span><span class="nv">ds</span><span class="o">/</span><span class="na">˜</span><span class="s1">' '</span><span class="o">≠</span><span class="nv">inp</span><span class="o">⊑</span><span class="na">˜</span><span class="nv">ds</span><span class="o">+&lt;</span><span class="nv">pos</span><span class="w">                        </span><span class="c1"># Not empty space</span>
<span class="kt">}</span>
</pre></div>

<p></p>
Notice how the result of <code>ND</code> is still a list—when it’s empty,
we know that we have reached the end.
Getting the path now simply involves simulating what we need to simulate.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">path</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span>
<span class="w">  </span><span class="m">·</span><span class="p">‿</span><span class="nv">pth</span><span class="p">‿</span><span class="nv">pos</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">dir</span><span class="p">‿</span><span class="nv">pth</span><span class="p">‿</span><span class="nv">pos</span><span class="ni">:</span>
<span class="w">      </span><span class="kt">{</span><span class="s1">' '</span><span class="o">=</span><span class="nv">inp</span><span class="o">⊑</span><span class="na">˜</span><span class="nv">dir</span><span class="o">+</span><span class="nv">pos</span><span class="ni">?</span><span class="w"> </span><span class="nv">dir</span><span class="sr">(</span><span class="o">⊑</span><span class="nv">pos</span><span class="py">⊸</span><span class="o">ND</span><span class="sr">)</span><span class="kd">↩</span><span class="ni">;</span><span class="ss">@</span><span class="kt">}</span><span class="w"> </span><span class="c1"># Change direction if necessary</span>
<span class="w">      </span><span class="p">⟨</span><span class="nv">dir</span><span class="p">,</span><span class="w"> </span><span class="nv">pth</span><span class="o">∾</span><span class="nv">pos</span><span class="o">⊑</span><span class="nv">inp</span><span class="p">,</span><span class="w"> </span><span class="nv">pos</span><span class="o">+</span><span class="nv">dir</span><span class="p">⟩</span>
<span class="w">  </span><span class="kt">}</span><span class="o">•_while_</span><span class="kt">{</span>
<span class="w">    </span><span class="o">𝕊</span><span class="nv">dir</span><span class="p">‿</span><span class="m">·</span><span class="p">‿</span><span class="nv">pos</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="o">&lt;</span><span class="w"> </span><span class="o">≠</span><span class="nv">pos</span><span class="w"> </span><span class="o">ND</span><span class="w"> </span><span class="nv">dir</span><span class="w">   </span><span class="c1"># While we can move somewhere</span>
<span class="w">  </span><span class="kt">}</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="o">⊑</span><span class="s1">'|'</span><span class="o">⊐</span><span class="na">˜</span><span class="m">1</span><span class="o">⊏</span><span class="nv">inp</span><span class="p">⟩⟩</span><span class="w">  </span><span class="c1"># Unique start</span>
<span class="w">  </span><span class="nv">pth</span><span class="o">∾</span><span class="nv">pos</span><span class="o">⊑</span><span class="nv">inp</span><span class="w">                    </span><span class="c1"># Add last position to final path</span>
<span class="kt">}</span>
</pre></div>

<p></p>
We just continue going into the same direction until the next cell would be a space.
In that case, we correct and move on until we can’t move anymore.
As said above, the start is the unique <code>|</code> connected to the top;
the index is quickly obtained with <em>index of</em> after a <em>first cell</em>,
to get the first major cell (row, in this case).
<p></p>
All that’s left to do is to get all letters from the path:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">∊</span><span class="py">⟜</span><span class="sr">(</span><span class="s1">'A'</span><span class="o">+↕</span><span class="m">26</span><span class="sr">)</span><span class="py">⊸</span><span class="o">/</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="c1"># ⇒ &quot;RUEDAHWKSM&quot;</span>
</pre></div>

<hr />
<p></p>
Part two is short and sweet—probably a breather from yesterday—and asks us for the length of the path.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">≠</span><span class="nv">path</span><span class="w"> </span><span class="c1"># ⇒ 17264</span>
</pre></div>

<h3 id="day-20"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day20.bqn">Day 20</a><a href="#day-20" class="floatleft sec-link">§</a></h3>
<p></p>
Today, we have to help the GPU simulate particles.
Our input consists of the particle positions,
together with their velocity and acceleration.
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>p=&lt;-3770,-455,1749&gt;, v=&lt;-4,-77,53&gt;, a=&lt;11,7,-9&gt;
p=&lt;1430,195,-903&gt;, v=&lt;-123,60,20&gt;, a=&lt;5,-5,1&gt;
p=&lt;-2964,-3029,2594&gt;, v=&lt;-8,157,7&gt;, a=&lt;9,-3,-8&gt;
…
</pre></div>

<p></p>
Part one asks us the following, slightly handwavy, question.
<blockquote>
<p></p>
Which particle will stay closest to position <0,0,0> in the long term?
</blockquote>
<p></p>
Before thinking about this too much, let’s first parse the input.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">P</span><span class="kd">←</span><span class="kt">{</span><span class="nv">p</span><span class="p">‿</span><span class="nv">r</span><span class="kd">←</span><span class="m">3</span><span class="sr">(</span><span class="o">↑⋈↓</span><span class="sr">)</span><span class="ni">𝕩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">v</span><span class="p">‿</span><span class="nv">a</span><span class="kd">←</span><span class="m">3</span><span class="sr">(</span><span class="o">↑⋈↓</span><span class="sr">)</span><span class="nv">r</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">p</span><span class="p">,</span><span class="nv">v</span><span class="p">,</span><span class="nv">a</span><span class="p">⟩</span><span class="kt">}</span>
<span class="nv">inp</span><span class="kd">←</span><span class="kt">{</span><span class="o">P•BQN</span><span class="s1">'⟨'</span><span class="o">∾</span><span class="ni">𝕩</span><span class="o">∾</span><span class="s1">'⟩'</span><span class="kt">}</span><span class="py">∘</span><span class="sr">(</span><span class="o">∊</span><span class="py">⟜</span><span class="sr">(</span><span class="s2">&quot;-,&quot;</span><span class="o">∾</span><span class="s1">'0'</span><span class="o">+↕</span><span class="m">10</span><span class="sr">)</span><span class="py">⊸</span><span class="o">/</span><span class="sr">)</span><span class="na">¨</span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day20.txt&quot;</span>
</pre></div>

<p></p>
Very dirty!
We first filter every line, only keeping the important bits for processing,
and then parse the whole thing as a list.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">∊</span><span class="py">⟜</span><span class="sr">(</span><span class="s2">&quot;-,&quot;</span><span class="o">∾</span><span class="s1">'0'</span><span class="o">+↕</span><span class="m">10</span><span class="sr">)</span><span class="py">⊸</span><span class="o">/</span><span class="sr">)</span><span class="w"> </span><span class="s2">&quot;p=&lt;-3770,-455,1749&gt;, v=&lt;-4,-77,53&gt;, a=&lt;11,7,-9&gt;&quot;</span>
<span class="s2">&quot;-3770,-455,1749,-4,-77,53,11,7,-9&quot;</span>
</pre></div>

<p></p>
Now, “in the long term” is a bit of a flexible formulation,
but what the question essentially wants us to recognise is that a higher acceleration always wins<!--
-->—doesn’t matter how fast the other particle started.
In particular, if we want to find out which particle will stay closest to the origin,
we need to find the one that has the smallest acceleration.
I will discuss two ways of doing this, each slightly flawed in its own way.
<p></p>
First, my input has the neat property that there is a unique particle with a smallest total acceleration.
In such cases, part one just amounts to picking that.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">⊑</span><span class="py">∘</span><span class="sr">(</span><span class="o">⊢⊐⌊</span><span class="na">´</span><span class="sr">)</span><span class="w"> </span><span class="kt">{</span><span class="o">+</span><span class="na">´</span><span class="o">|</span><span class="m">¯1</span><span class="o">⊑</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 376</span>
</pre></div>

<p></p>
<code>{+´|¯1⊑𝕩}</code> computes the maximal acceleration,
and <code>(⊢⊐⌊´)</code> is a neat train to pick the index of the minimal element.
<p></p>
In the absence of a unique particle with smallest total acceleration,
things get a bit more complicated.
One would have to include velocity and direction of travel into the equation,
which is much harder than to just simulate everything “for a bit”.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">U</span><span class="kd">←</span><span class="kt">{</span><span class="nv">p</span><span class="p">‿</span><span class="nv">v</span><span class="p">‿</span><span class="nv">a</span><span class="ni">:</span><span class="w"> </span><span class="p">⟨</span><span class="nv">p</span><span class="o">+</span><span class="nv">v</span><span class="o">+</span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="nv">v</span><span class="o">+</span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="nv">a</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">⊑</span><span class="sr">(</span><span class="o">⊢⊐⌊</span><span class="na">´</span><span class="sr">)(</span><span class="o">+</span><span class="na">´</span><span class="o">|</span><span class="sr">)</span><span class="py">∘</span><span class="o">⊑</span><span class="py">∘</span><span class="sr">(</span><span class="o">U</span><span class="py">⍟</span><span class="m">1000</span><span class="sr">)</span><span class="na">¨</span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 376</span>
</pre></div>

<p></p>
Get the absolute value of each position after 1000 steps,
and then compute the minimum as before.
<hr />
<p></p>
Part two wants us to take care of “colliding” particles—those whose positions match up at any point in time.
Since I’m not going to solve quadratic equations, let’s also just simulate this one “long enough”.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">≠</span><span class="kt">{</span><span class="sr">(</span><span class="o">∊∧</span><span class="m">1</span><span class="o">⌽∊</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="o">⊑</span><span class="na">¨</span><span class="sr">)</span><span class="py">⊸</span><span class="o">/</span><span class="w"> </span><span class="o">∨U</span><span class="na">¨</span><span class="ni">𝕩</span><span class="kt">}</span><span class="py">⍟</span><span class="m">1000</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 574</span>
</pre></div>

<p></p>
We advance every particle in the input by one,
sort the resulting list by position,
and kick out all particles that are equal to any adjacent ones.
<details>
<summary>
The <code>∊∧1⌽∊</code> part is probably reasonably obfuscated, so let’s go through it.
</summary>
<p></p>
First, one could write that piece of code in a slightly different—perhaps more understandable—way:<!--
--><label for="sn-38" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-38" class="margin-toggle" /><div class="sidenote">This is modulo some shenanigans when <code>0</code> is the first element of the list,
but let’s completely ignore that case for the purposes of this exposition.
Indeed, since we are dealing with a vector of three numbers and the fill element is still <code>0</code>,
this does not affect the actual solution.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">«</span><span class="sr">)</span><span class="o">∧</span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">»</span><span class="sr">)</span>
</pre></div>

<p></p>
This very symmetrical looking expression checks which elements in a given vector
are unequal to their successor and predecessor:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">«</span><span class="sr">)</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,⟨</span><span class="m">4</span><span class="p">⟩,⟨</span><span class="m">4</span><span class="p">⟩⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">»</span><span class="sr">)</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,⟨</span><span class="m">4</span><span class="p">⟩,⟨</span><span class="m">4</span><span class="p">⟩⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">((</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">«</span><span class="sr">)</span><span class="o">∧</span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">»</span><span class="sr">))</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,⟨</span><span class="m">4</span><span class="p">⟩,⟨</span><span class="m">4</span><span class="p">⟩⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
The first thing to notice is that, in a sorted list,
a number not being equal to its predecessor just means that it’s the first occurrence of that number in the vector:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">»</span><span class="sr">)</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">∊</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="o">∊</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">   </span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">»</span><span class="sr">)</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
The more interesting questions is how to capture that a number is not equal to its successor.
For that, one can still use <em>mark firsts</em> and then simply <em>rotate</em> the vector by one to the left.
This will instead give you the last occurrence of every element in the vector.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">≢</span><span class="na">˘</span><span class="py">⟜</span><span class="o">«</span><span class="sr">)</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">   </span><span class="m">1</span><span class="o">⌽∊</span><span class="w"> </span><span class="p">⟨</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">⟩</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
Thus, to get the unique elements of our sorted list, <code>∊∧1⌽∊</code> will do!<!--
--><label for="sn-39" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-39" class="margin-toggle" /><div class="sidenote">After writing this, I saw that <a href="https://mlochbaum.github.io/bqncrate/"><span class="small-caps">bqn</span>crate</a> suggests <code>∊∧∊⌾⌽</code>,
which should also work for non-sorted lists.</div><!--
-->
</details>
<h2 id="days-2125">Days 21–25<a href="#days-2125" class="floatleft sec-link">§</a></h2>
<h3 id="day-21"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day21.bqn">Day 21</a><a href="#day-21" class="floatleft sec-link">§</a></h3>
<p></p>
In today’s very array-oriented problem,
we have to help a program create art by repeatedly enhancing an image.
The following is our starting pattern:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>.#.
..#
###
</pre></div>

<p></p>
The task says to apply the following two simple rules over and over again.
<blockquote>
<ul>
<li>If the size [of the array] is evenly divisible by 2, break the pixels up into 2x2 squares, and convert each 2x2 square into a 3x3 square by following the corresponding enhancement rule.</li>
<li>Otherwise, the size is evenly divisible by 3; break the pixels up into 3x3 squares, and convert each 3x3 square into a 4x4 square by following the corresponding enhancement rule.</li>
</ul>
</blockquote>
<p></p>
An “enhancement rule” look like <code>../.# =&gt; ##./#../...</code>, where <code>/</code> signals a line break.
An important part of the problem is that not only does <code>../.#</code> match this pattern, but also any rotation or flip of it,
which means the following configurations are all matches:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>..     .#     #.     ..
.#     ..     ..     #.
</pre></div>

<p></p>
Note that regardless of how the match is formed, the output pattern is never rotated or flipped.
<p></p>
Beginning with the above starting configuration and applying enhancement rule <code>.#./..#/### =&gt; #..#/..../..../#..#</code>,
we end up with
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>#..#
....
....
#..#
</pre></div>

<p></p>
Applying rule <code>../.# =&gt; ##./#../...</code> to each of the four 2×2 squares, we get
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>##.##.
#..#..
......
##.##.
#..#..
......
</pre></div>

<p></p>
and so on.
<p></p>
Part one asks us to simulate the whole thing five times,
and determine how many <code>#</code>’s are in the resulting grid.
Let’s start by parsing a single enhancement line:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="w"> </span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="o">P</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># Parse a line into from‿to pairs</span>
<span class="w">  </span><span class="nv">f</span><span class="p">‿</span><span class="nv">t</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="s1">'='</span><span class="o">Split</span><span class="ni">𝕩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="m">¯1</span><span class="py">⊸</span><span class="o">↓</span><span class="kd">↩</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="m">2</span><span class="py">⊸</span><span class="o">↓</span><span class="kd">↩</span>
<span class="w">  </span><span class="o">&gt;</span><span class="py">∘</span><span class="sr">(</span><span class="s2">&quot;.#&quot;</span><span class="py">⊸</span><span class="o">⊐</span><span class="na">¨</span><span class="sr">)</span><span class="py">∘</span><span class="sr">(</span><span class="s1">'/'</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="nv">f</span><span class="p">‿</span><span class="nv">t</span>
<span class="kt">}</span>
</pre></div>

<p></p>
This isn’t too surprising; we first essentially split on <code>" =&gt; "</code> in an awkward way,<!--
--><label for="sn-40" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-40" class="margin-toggle" /><div class="sidenote">A version of <code>Split</code> that splits on subarrays would have probably been useful here.
Certainly something to write before this year’s event.</div><!--
-->
split every individual array on <code>/</code>,
change the dots and hashes to zeros and ones,
and <em>merge</em> each of the vectors into a proper array.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">P</span><span class="w"> </span><span class="s2">&quot;.../.../... =&gt; ...#/#.##/.##./#..#&quot;</span>
<span class="err">┌─</span>
<span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">                        </span><span class="err">┘</span>
</pre></div>

<p></p>
Since all rotations and flips are valid for the pattern match,
we might as well immediately “expand” each of the substitutions into all eight possibilities.
This essentially boils down to applying every transformation of the
<a href="https://en.wikipedia.org/wiki/Dihedral_group#Matrix_representation">dihedral group</a>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">D_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of the square to our array.
One way to do this is to compute all of the rotations,
and all of the rotations with reversed rows.
We already saw that we can use <code>(⍉⌽)⍟(↕4)</code> to obtain all rotations on <a href="#day-19">day 19</a>,
and reversing the rows is easy enough to do with <code>⌽˘</code>:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="p">⟨</span><span class="o">⌽</span><span class="na">˘</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">⌜</span><span class="sr">(</span><span class="o">⍉⌽</span><span class="sr">)</span><span class="py">⍟</span><span class="sr">(</span><span class="o">↕</span><span class="m">4</span><span class="sr">)</span><span class="w"> </span><span class="o">&gt;</span><span class="p">⟨⟨</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">⟩,⟨</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">⟩⟩</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">3</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">2</span>
<span class="w">    </span><span class="m">4</span><span class="w"> </span><span class="m">3</span><span class="w">     </span><span class="m">2</span><span class="w"> </span><span class="m">4</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w">     </span><span class="m">3</span><span class="w"> </span><span class="m">1</span>
<span class="w">        </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">3</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">4</span>
<span class="w">    </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w">     </span><span class="m">4</span><span class="w"> </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">3</span>
<span class="w">        </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span><span class="w">       </span><span class="err">┘</span>
<span class="w">                                  </span><span class="err">┘</span>
</pre></div>

<p></p>
We now just have to do some plumbing to associate every one of the resulting eight input patterns to the same output.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">E</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">f</span><span class="p">‿</span><span class="nv">t</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">⥊</span><span class="p">⟨</span><span class="o">⌽</span><span class="na">˘</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">⌜</span><span class="sr">(</span><span class="o">⍉⌽</span><span class="sr">)</span><span class="py">⍟</span><span class="sr">(</span><span class="o">↕</span><span class="m">4</span><span class="sr">)</span><span class="nv">f</span><span class="sr">)</span><span class="o">⋈</span><span class="na">¨</span><span class="o">&lt;</span><span class="nv">t</span><span class="w"> </span><span class="kt">}</span>
</pre></div>

<details>
<summary>
For example (line wrapped for readability):
</summary>
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="err">┌─</span>
<span class="m">·</span><span class="w"> </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span>
<span class="w">  </span><span class="m">·</span><span class="w"> </span><span class="err">┌─</span><span class="w">      </span><span class="err">┌─</span>
<span class="w">    </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">   </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">                    </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">                        </span><span class="err">┘</span>
</pre></div>

</details>
<p></p>
Now, as you can imagine by either thinking about or looking at the output,
there are usually a lot of duplicates in this list.
We can fix this by using
<em>deduplicate</em> (<a href="https://mlochbaum.github.io/BQN/doc/selfcmp.html#deduplicate"><code>⍷</code></a>)
to only keep the first occurrence of every major cell.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">E</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">f</span><span class="p">‿</span><span class="nv">t</span><span class="ni">:</span><span class="w"> </span><span class="sr">(</span><span class="o">⍷⥊</span><span class="p">⟨</span><span class="o">⌽</span><span class="na">˘</span><span class="p">,</span><span class="o">⊢</span><span class="p">⟩</span><span class="kt">{</span><span class="o">𝕎</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">⌜</span><span class="sr">(</span><span class="o">⍉⌽</span><span class="sr">)</span><span class="py">⍟</span><span class="sr">(</span><span class="o">↕</span><span class="m">4</span><span class="sr">)</span><span class="nv">f</span><span class="sr">)</span><span class="o">⋈</span><span class="na">¨</span><span class="o">&lt;</span><span class="nv">t</span><span class="w"> </span><span class="kt">}</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">∾</span><span class="w"> </span><span class="o">E</span><span class="py">∘</span><span class="o">P</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day21.txt&quot;</span>
</pre></div>

<p></p>
Next up is enhancing the grid as described.
Let’s do this generically:
given an array, a target <code>k</code> (for <code>k×k</code> subarrays),
and a list of <code>k×k → (k+1)×(k+1)</code> substitutions,
perform one enhancement step.<!--
--><label for="sn-41" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-41" class="margin-toggle" /><div class="sidenote">Note that this is all under the assumption that <code>k</code> divides <code>n</code>.</div><!--
-->
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Widen</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">k</span><span class="p">‿</span><span class="nv">substs</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">grid</span><span class="ni">:</span>
<span class="w">  </span><span class="o">∾</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">sg</span><span class="ni">:</span><span class="w"> </span><span class="c1"># A k×k submatrix of `grid'</span>
<span class="w">    </span><span class="m">1</span><span class="o">⊑⊑</span><span class="w"> </span><span class="sr">(</span><span class="nv">sg</span><span class="o">≡⊑</span><span class="sr">)</span><span class="na">¨</span><span class="py">⊸</span><span class="o">/</span><span class="nv">substs</span>
<span class="w">  </span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="sr">(</span><span class="m">2</span><span class="o">⥊&lt;⌊</span><span class="nv">k</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕≠</span><span class="nv">grid</span><span class="sr">)</span><span class="o">⊔</span><span class="nv">grid</span>
<span class="kt">}</span>
</pre></div>

<p></p>
<em>Group</em> is used to partition the grid into the necessary <code>k×k</code> subarrays:
<code>⌊k÷˜↕≠grid</code> creates a vector like <code>⟨0,…,0, 1,…,1 …, n,…,n⟩</code>,
where <code>n = ((≠grid)÷k)-1</code> and each number appears exactly <code>k</code> times:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="sr">(</span><span class="o">⌊</span><span class="m">3</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕</span><span class="m">21</span><span class="sr">)</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="m">6</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="o">⌊</span><span class="m">7</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕</span><span class="m">21</span><span class="sr">)</span>
<span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
We can then use the fact that the left argument to <em>group</em> can be a nested vector,
where each element corresponds to one axis of the right argument;
see <a href="https://mlochbaum.github.io/BQN/doc/group.html#multidimensional-grouping">multidimensional grouping</a>.
For the simple partition that we want, doubling the vector suffices.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="m">2</span><span class="o">⥊&lt;⌊</span><span class="m">3</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕</span><span class="m">6</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
<span class="w">    </span><span class="sr">(</span><span class="m">2</span><span class="o">⥊&lt;⌊</span><span class="m">3</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕</span><span class="m">6</span><span class="sr">)</span><span class="o">⊔</span><span class="sr">(</span><span class="m">6</span><span class="p">‿</span><span class="m">6</span><span class="o">⥊↕</span><span class="m">36</span><span class="sr">)</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="err">┌─</span><span class="w">           </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w">  </span><span class="m">0</span><span class="w">  </span><span class="m">1</span><span class="w">  </span><span class="m">2</span><span class="w">   </span><span class="err">╵</span><span class="w">  </span><span class="m">3</span><span class="w">  </span><span class="m">4</span><span class="w">  </span><span class="m">5</span>
<span class="w">     </span><span class="m">6</span><span class="w">  </span><span class="m">7</span><span class="w">  </span><span class="m">8</span><span class="w">      </span><span class="m">9</span><span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="m">11</span>
<span class="w">    </span><span class="m">12</span><span class="w"> </span><span class="m">13</span><span class="w"> </span><span class="m">14</span><span class="w">     </span><span class="m">15</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">17</span>
<span class="w">             </span><span class="err">┘</span><span class="w">            </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span><span class="w">           </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">18</span><span class="w"> </span><span class="m">19</span><span class="w"> </span><span class="m">20</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">22</span><span class="w"> </span><span class="m">23</span>
<span class="w">    </span><span class="m">24</span><span class="w"> </span><span class="m">25</span><span class="w"> </span><span class="m">26</span><span class="w">     </span><span class="m">27</span><span class="w"> </span><span class="m">28</span><span class="w"> </span><span class="m">29</span>
<span class="w">    </span><span class="m">30</span><span class="w"> </span><span class="m">31</span><span class="w"> </span><span class="m">32</span><span class="w">     </span><span class="m">33</span><span class="w"> </span><span class="m">34</span><span class="w"> </span><span class="m">35</span>
<span class="w">             </span><span class="err">┘</span><span class="w">            </span><span class="err">┘</span>
<span class="w">                            </span><span class="err">┘</span>
</pre></div>

<p></p>
The rest of the code is kind of straightforward;
in <code>{𝕊sg: 1⊑⊑ (sg≡⊑)¨⊸/substs}</code> we look for the substitution that fits the current subset of the grid<!--
-->—we are guaranteed by the question that we have exactly one such match—<!--
-->and take the enhancement (<code>1⊑</code>).
This already has the right shape in that the resulting array consists of <code>(k+1)×(k+1)</code> blocks in the right order,
so we just need to <em>join</em> everything together.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="nv">t</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">{</span><span class="m">2</span><span class="o">=≠⊑</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="py">⊸</span><span class="o">/</span><span class="nv">inp</span><span class="p">⟩</span><span class="w"> </span><span class="kt">{</span>
<span class="w">      </span><span class="nv">k</span><span class="p">‿</span><span class="nv">ss</span><span class="o">𝕊</span><span class="nv">g</span><span class="ni">:</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕊</span><span class="nv">sg</span><span class="ni">:</span><span class="w"> </span><span class="m">1</span><span class="o">⊑⊑</span><span class="w"> </span><span class="sr">(</span><span class="nv">sg</span><span class="o">≡⊑</span><span class="sr">)</span><span class="na">¨</span><span class="py">⊸</span><span class="o">/</span><span class="nv">ss</span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="sr">(</span><span class="m">2</span><span class="o">⥊&lt;⌊</span><span class="nv">k</span><span class="o">÷</span><span class="na">˜</span><span class="o">↕≠</span><span class="nv">g</span><span class="sr">)</span><span class="o">⊔</span><span class="nv">g</span>
<span class="w">    </span><span class="kt">}</span><span class="w"> </span><span class="p">[[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">],[</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">],[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">],[</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">]]</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">          </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span>
<span class="w">  </span><span class="err">┌─</span><span class="w">        </span><span class="err">┌─</span>
<span class="w">  </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="err">╵</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">    </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">          </span><span class="err">┘</span><span class="w">         </span><span class="err">┘</span>
<span class="w">                      </span><span class="err">┘</span>
<span class="w">    </span><span class="o">∾</span><span class="nv">t</span>
<span class="err">┌─</span>
<span class="err">╵</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">1</span>
<span class="w">              </span><span class="err">┘</span>
</pre></div>

<p></p>
When plugging everything together we just need to make sure to pass the right substitutions to <code>Widen</code>
(and to have the case for <code>2</code> come before that for <code>3</code>).
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># Only take valid substitutions.</span>
<span class="w">  </span><span class="m">0</span><span class="o">=</span><span class="m">2</span><span class="o">|≠</span><span class="ni">𝕩?</span><span class="w"> </span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">{</span><span class="m">2</span><span class="o">=≠⊑</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="py">⊸</span><span class="o">/</span><span class="nv">inp</span><span class="p">⟩</span><span class="w"> </span><span class="o">Widen</span><span class="w"> </span><span class="ni">𝕩;</span>
<span class="w">  </span><span class="m">0</span><span class="o">=</span><span class="m">3</span><span class="o">|≠</span><span class="ni">𝕩?</span><span class="w"> </span><span class="p">⟨</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">{</span><span class="m">3</span><span class="o">=≠⊑</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="py">⊸</span><span class="o">/</span><span class="nv">inp</span><span class="p">⟩</span><span class="w"> </span><span class="o">Widen</span><span class="w"> </span><span class="ni">𝕩</span>
<span class="kt">}</span>

<span class="nv">start</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">&gt;</span><span class="s2">&quot;.#&quot;</span><span class="py">⊸</span><span class="o">⊐</span><span class="na">¨</span><span class="p">⟨</span><span class="s2">&quot;.#.&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;..#&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;###&quot;</span><span class="p">⟩</span>
<span class="o">+</span><span class="na">´</span><span class="o">⥊</span><span class="w"> </span><span class="o">Sim</span><span class="py">⍟</span><span class="m">5</span><span class="w">  </span><span class="nv">start</span><span class="w"> </span><span class="c1"># ⇒ 155</span>
</pre></div>

<hr />
<p></p>
Part two asks us to instead simulate 18 enhancement steps.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="o">⥊</span><span class="w"> </span><span class="o">Sim</span><span class="py">⍟</span><span class="m">18</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="c1"># ⇒ 2449665</span>
</pre></div>

<h3 id="day-22"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day22.bqn">Day 22</a><a href="#day-22" class="floatleft sec-link">§</a></h3>
<p></p>
Today we are tasked with helping a computer cluster fend off a virus.
Our puzzle input is a populated part of an infinite grid:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>..#
#..
...
</pre></div>

<p></p>
The virus starts square in the middle, looking up.
<p></p>
Part one has two types of cells, clean (<code>.</code>) and infected (<code>#</code>),
and wants us to count the number of cells that have been infected (at any point) after 10’000 steps.
A single step in the simulation proceeds according to the following rules:
<blockquote>
<ul>
<li>If the current node is infected, it turns to its right. Otherwise, it turns to its left. (Turning is done in-place; the current node does not change.)</li>
<li>If the current node is clean, it becomes infected. Otherwise, it becomes cleaned. (This is done after the node is considered for the purposes of changing direction.)</li>
<li>The virus carrier moves forward one node in the direction it is facing</li>
</ul>
</blockquote>
<p></p>
We will use a hash map to simulate the infinite grid.
Parsing is easy this time:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">&gt;•FLines</span><span class="w"> </span><span class="s2">&quot;../inputs/day22.txt&quot;</span>
<span class="o">Start</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="p">⟨</span><span class="sr">(</span><span class="o">⥊↕≢</span><span class="nv">inp</span><span class="sr">)</span><span class="o">•HashMap</span><span class="ni">𝕩</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="o">⌊</span><span class="sr">(</span><span class="o">≢</span><span class="nv">inp</span><span class="sr">)</span><span class="o">÷</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span><span class="kt">}</span>
</pre></div>

<p></p>
Note the unusual coordinates:
since I don’t want to change the “direction” in the array itself,
up, right, down, and left are <code>¯1‿0</code>, <code>0‿1</code>, <code>1‿0</code>, and <code>0‿¯1</code>, respectively.
For the simulation, we also need the ability to change direction.
The idea is to get the index of <code>𝕩</code> in a list of directions,
add <code>𝕨</code> mod 4 (to turn <code>𝕨</code> steps to the right),
and <em>pick</em> the element at that index.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Turn</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="c1"># Given direction 𝕩, turn 𝕨 steps to the right.</span>
<span class="w">  </span><span class="nv">ts</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="p">⟨</span><span class="m">¯1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="m">¯1</span><span class="p">⟩</span>
<span class="w">  </span><span class="sr">(</span><span class="o">⊑</span><span class="m">4</span><span class="o">|</span><span class="ni">𝕨</span><span class="o">+</span><span class="nv">ts</span><span class="o">⊐&lt;</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">⊑</span><span class="nv">ts</span>
<span class="kt">}</span>
</pre></div>

<p></p>
The simulation now just does what the rules say.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="nv">g</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">p</span><span class="p">‿</span><span class="nv">d</span><span class="ni">:</span><span class="w">     </span><span class="c1"># grid, index, position, direction</span>
<span class="w">  </span><span class="nv">pv</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="nv">g</span><span class="p">.</span><span class="o">Get</span><span class="w"> </span><span class="nv">p</span><span class="w">      </span><span class="c1"># Don't keep track of clean (= 0) cells.</span>
<span class="w">  </span><span class="nv">nd</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="kt">{</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="m">¯1</span><span class="ni">;𝕩</span><span class="kt">}</span><span class="nv">pv</span><span class="sr">)</span><span class="w"> </span><span class="o">Turn</span><span class="w"> </span><span class="nv">d</span>
<span class="w">  </span><span class="nv">p</span><span class="w"> </span><span class="nv">g</span><span class="p">.</span><span class="o">Set</span><span class="w"> </span><span class="o">¬</span><span class="nv">pv</span><span class="w">         </span><span class="c1"># New value for p.</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">g</span><span class="p">,</span><span class="w"> </span><span class="nv">i</span><span class="o">+</span><span class="m">0</span><span class="o">=</span><span class="nv">pv</span><span class="p">,</span><span class="w"> </span><span class="nv">p</span><span class="o">+</span><span class="nv">nd</span><span class="p">,</span><span class="w"> </span><span class="nv">nd</span><span class="p">⟩</span>
<span class="kt">}</span>

<span class="m">1</span><span class="o">⊑</span><span class="w"> </span><span class="o">Sim</span><span class="py">⍟</span><span class="m">10_000</span><span class="w"> </span><span class="o">Start</span><span class="sr">(</span><span class="o">⥊</span><span class="s2">&quot;.#&quot;</span><span class="o">⊐</span><span class="nv">inp</span><span class="sr">)</span><span class="w"> </span><span class="c1"># ⇒ 5460</span>
</pre></div>

<p></p>
Since we want to turn left when we see a clean cell,
we have to have a substitution like <code>0→¯1</code>,
which is what <code>{𝕊0:¯1;𝕩}</code> accomplishes.
We again don’t keep track of additional clean cells by supplying a default argument to <code>Get</code>, in case <code>p</code> is not found.
<hr />
<p></p>
Part two wants us to simulate the same thing, but instead of two we now have four states to keep track of:
clean, weakened, infected, and flagged—in that order.
We also have to simulate everything for 10’000’000 instead of only 10’000 steps,
and the rules are a bit different:
<blockquote>
<ul>
<li>Decide which way to turn based on the current node:
<ul>
<li>If it is clean, it turns left.</li>
<li>If it is weakened, it does not turn, and will continue moving in the same direction.</li>
<li>If it is infected, it turns right.</li>
<li>If it is flagged, it reverses direction, and will go back the way it came.</li>
</ul></li>
<li>Modify the state of the current node, as described above [clean → weakened → infected → flagged → clean …].</li>
<li>The virus carrier moves forward one node in the direction it is facing.</li>
</ul>
</blockquote>
<p></p>
After some staring one figures out that while the infected state has moved from <code>1</code> to <code>2</code>, the whole thing just switches out numbers mod 2 for numbers mod 4.
Looking at our <code>Sim</code> function,
we only need to change a few things to make it more generic:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="c1"># mod‿infectedTarget‿TurnOffset 𝕊 grid‿infectCount‿position‿direction</span>
<span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">m</span><span class="p">‿</span><span class="nv">t</span><span class="p">‿</span><span class="o">TO</span><span class="w"> </span><span class="o">𝕊</span><span class="w"> </span><span class="nv">g</span><span class="p">‿</span><span class="nv">i</span><span class="p">‿</span><span class="nv">p</span><span class="p">‿</span><span class="nv">d</span><span class="ni">:</span>
<span class="w">  </span><span class="nv">pv</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="nv">g</span><span class="p">.</span><span class="o">Get</span><span class="w"> </span><span class="nv">p</span><span class="w">      </span><span class="c1"># Don't keep track of clean (= 0) cells.</span>
<span class="w">  </span><span class="nv">nd</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">TO</span><span class="w"> </span><span class="nv">pv</span><span class="sr">)</span><span class="w"> </span><span class="o">Turn</span><span class="w"> </span><span class="nv">d</span>
<span class="w">  </span><span class="nv">p</span><span class="w"> </span><span class="nv">g</span><span class="p">.</span><span class="o">Set</span><span class="w"> </span><span class="nv">m</span><span class="o">|</span><span class="nv">pv</span><span class="o">+</span><span class="m">1</span><span class="w">      </span><span class="c1"># New value for p.</span>
<span class="w">  </span><span class="p">⟨</span><span class="nv">g</span><span class="p">,</span><span class="w"> </span><span class="nv">i</span><span class="o">+</span><span class="nv">t</span><span class="o">=</span><span class="nv">pv</span><span class="p">,</span><span class="w"> </span><span class="nv">p</span><span class="o">+</span><span class="nv">nd</span><span class="p">,</span><span class="w"> </span><span class="nv">nd</span><span class="p">⟩</span>
<span class="kt">}</span>

<span class="c1"># Part one still works:</span>
<span class="m">1</span><span class="o">⊑</span><span class="w"> </span><span class="p">⟨</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">{</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="m">¯1</span><span class="ni">;𝕩</span><span class="kt">}</span><span class="p">⟩</span><span class="w"> </span><span class="o">Sim</span><span class="py">⍟</span><span class="m">10_000</span><span class="w"> </span><span class="o">Start</span><span class="sr">(</span><span class="o">⥊</span><span class="s2">&quot;.#&quot;</span><span class="o">⊐</span><span class="nv">inp</span><span class="sr">)</span><span class="w"> </span><span class="c1"># ⇒ 5460</span>
</pre></div>

<p></p>
Some bits of additional state, like the modulus used or which number we want to count in the end, are needed.
Other than that, though, it’s the same function as before.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="m">1</span><span class="o">⊑</span><span class="w"> </span><span class="p">⟨</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="py">⟜</span><span class="m">1</span><span class="p">⟩</span><span class="w"> </span><span class="o">Sim</span><span class="py">⍟</span><span class="m">10_000_000</span><span class="w"> </span><span class="o">Start</span><span class="sr">(</span><span class="o">⥊</span><span class="s2">&quot;. #&quot;</span><span class="o">⊐</span><span class="nv">inp</span><span class="sr">)</span><span class="w"> </span><span class="c1"># ⇒ 2511702</span>
</pre></div>

<h3 id="day-23"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day23.bqn">Day 23</a><a href="#day-23" class="floatleft sec-link">§</a></h3>
<p></p>
Today we have to help an experimental coprocessor to not halt and catch fire.
This again boils down to simulating some small assembly language—or so one would think.
The instruction set is similar to that of <a href="#day-18">day 18</a>:
<blockquote>
<ul>
<li><code>set X Y</code> sets register <code>X</code> to the value of <code>nY</code>.</li>
<li><code>sub X Y</code> decreases register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mul X Y</code> sets register <code>X</code> to the result of multiplying the value contained in register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>jnz X Y</code> jumps with an offset of the value of <code>Y</code>, but only if the value of <code>X</code> is not zero. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)</li>
</ul>
<p></p>
Only the instructions listed above are used. The eight registers here, named <code>a</code> through <code>h</code>, all start at 0.
</blockquote>
<p></p>
Part one asks us how many times the <code>mul</code> instruction is invoked.
My solution is this one:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="m">63</span><span class="o">×</span><span class="m">63</span><span class="w"> </span><span class="c1"># ⇒ 3969</span>
</pre></div>

<p></p>
Oh yeah.
<hr />
<p></p>
So what’s that all about?
Well, originally the code looked very different<!--
-->—almost an exact copy-paste of what we did for day 18—<!--
-->but part two reveals what the task actually wants us to do.
<blockquote>
<p></p>
You flip the switch, which makes register <code>a</code> now start at <code>1</code> when the program is executed.
<p></p>
Immediately, the coprocessor begins to overheat. Whoever wrote this program obviously didn’t choose a very efficient implementation. You’ll need to optimize the program if it has any hope of completing before Santa needs that printer working.
The coprocessor’s ultimate goal is to determine the final value left in register <code>h</code> once the program completes. Technically, if it had that… it wouldn’t even need to run the program.
</blockquote>
<p></p>
This is a very big nudge into the direction of “go and read the assembly”.
There are, I suppose, several ways to go about finding the solution.
The sane one might be to translate the assembly into a more human readable form,<!--
--><label for="sn-42" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-42" class="margin-toggle" /><div class="sidenote">There’s a great (apocryphal) anecdote about John von Neumann
shouting at his PhD students because they were writing assembly.
Obviously, this just wasted resources because it was much too high-level,
and they should have written their programs directly in binary instead.
A more civilised age.</div><!--
-->
and then try to see patterns in this simpler representation (remember notation as a tool for thought?).
Instead, I employed a trusted method that I learned from studying maths for too long:
stare at it until it makes sense.
<details>
<summary>
Here’s the input if you want to give it a try.
</summary>
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>set b 65
set c b
jnz a 2
jnz 1 5
mul b 100
sub b -100000
set c b
sub c -17000
set f 1
set d 2
set e 2
set g d
mul g e
sub g b
jnz g 2
set f 0
sub e -1
set g e
sub g b
jnz g -8
sub d -1
set g d
sub g b
jnz g -13
jnz f 2
sub h -1
set g b
sub g c
jnz g 2
jnz 1 3
sub b -17
jnz 1 -23
</pre></div>

</details>
<p></p>
<!--
--><label for="sn-43" class="margin-toggle">⊕</label><input type="checkbox" id="sn-43" class="margin-toggle" /><div class="marginnote">There always seems to be at least one day each year where inspecting one’s input is the expected way to solve the problem.
Honestly, I’m not sure what to think of that;
I used to really dislike these days, but this one was unexpectedly fun.
It <em>is</em> a breath of fresh air after over 20 days of solving puzzles, I guess.
However, it also helps that doing these problems “out of season”
is a lot more relaxed than trying to bash out both parts before work every day.</div><!--
-->
After quite a lot of staring, one figures out that <code>h</code> will fill up with all non-primes between <code>106500</code> and <code>123500</code> in steps of <code>17</code>.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">+</span><span class="na">´</span><span class="kt">{</span><span class="m">1</span><span class="o">≠+</span><span class="na">´</span><span class="m">0</span><span class="o">=</span><span class="ni">𝕩</span><span class="o">|</span><span class="na">˜</span><span class="o">↕⌈√</span><span class="ni">𝕩</span><span class="kt">}</span><span class="na">¨</span><span class="o">+</span><span class="py">⟜</span><span class="m">17</span><span class="py">⍟</span><span class="sr">(</span><span class="o">↕</span><span class="m">1</span><span class="o">+</span><span class="m">17</span><span class="o">÷</span><span class="na">˜</span><span class="m">123500</span><span class="o">-</span><span class="m">106500</span><span class="sr">)</span><span class="w"> </span><span class="m">106500</span><span class="w"> </span><span class="c1"># ⇒ 917</span>
</pre></div>

<h3 id="day-24"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day24.bqn">Day 24</a><a href="#day-24" class="floatleft sec-link">§</a></h3>
<p></p>
The penultimate day wants us to build a bridge to get across a
<a href="https://knowyourmeme.com/memes/bottomless-pit-supervisor">bottomless pit</a>.
Our puzzle input comprises components that we have to connect to each other:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>0/2
2/2
2/3
3/4
3/5
0/1
10/1
9/10
</pre></div>

<p></p>
We start at <code>0</code>; the “ports” of connected components have to match up, but only up to rotation:
<code>0/2—2/3—4/3</code> is a valid bridge.
The only restriction we have in that regard is that a port can only be used once,
so <code>0/2—2/3—2/4</code> is not valid.
Part one asks us for the strongest bridge we can make of our input (without replacement),
where the strength is just all ports added together.
Parsing is trivial:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="p">⟨</span><span class="o">Split</span><span class="p">,</span><span class="na">_Fix</span><span class="p">⟩</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•Import</span><span class="s2">&quot;../../util/bqn_util/util.bqn&quot;</span>
<span class="nv">inp</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">•ParseFloat</span><span class="na">¨</span><span class="py">∘</span><span class="sr">(</span><span class="s1">'/'</span><span class="py">⊸</span><span class="o">Split</span><span class="sr">)</span><span class="na">¨</span><span class="w"> </span><span class="o">•FLines</span><span class="s2">&quot;../inputs/day24.txt&quot;</span>
</pre></div>

<p></p>
This creates a nested vector like <code>⟨⟨0 2⟩ ⟨2 2⟩ ⟨2 3⟩ …⟩</code>.
For selecting a part, we want to match a number against that list and pick all ports where at least one port matches that number:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="w">    </span><span class="o">Sel</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="sr">(</span><span class="o">&gt;∊</span><span class="na">¨</span><span class="sr">)</span><span class="o">/⊢</span>
<span class="sr">(</span><span class="nv">function</span><span class="w"> </span><span class="nv">block</span><span class="sr">)</span>
<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="o">Sel</span><span class="w"> </span><span class="nv">inp</span><span class="w">      </span><span class="c1"># Starting states</span>
<span class="p">⟨</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">50</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">28</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟨</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">33</span><span class="w"> </span><span class="p">⟩</span><span class="w"> </span><span class="p">⟩</span>
</pre></div>

<p></p>
For each of these starting states, we can formulate a naturally recursive algorithm:
given a target value <code>t</code> and a list <code>xs</code> of components, do the following:
<ul>
<li>if no components match <code>t</code>, return <code>0</code>;</li>
<li>otherwise, recurse on each match
(using the value that <code>t</code> didn’t match as the new target),
pick the maximum over all branches,
and add the value of the current match to it.</li>
</ul>
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">SM</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="o">¬</span><span class="py">∘</span><span class="o">∊/⊣</span><span class="w"> </span><span class="c1"># Set minus</span>
<span class="o">Sim</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="ni">:</span>
<span class="w">  </span><span class="kt">{</span><span class="sr">(</span><span class="o">+</span><span class="na">´</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">+</span><span class="w"> </span><span class="m">0</span><span class="o">⌈</span><span class="na">´</span><span class="w"> </span><span class="sr">(</span><span class="ni">𝕩</span><span class="o">⊑</span><span class="na">˜</span><span class="nv">t</span><span class="o">=⊑</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="o">SM</span><span class="p">⟨</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="kt">}</span><span class="na">¨</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="o">Sel</span><span class="w"> </span><span class="nv">xs</span>
<span class="kt">}</span>
</pre></div>

<p></p>
We use our old friend <code>¬∘∊/⊣</code> to take care of the “without replacement” part of the whole thing,
<code>𝕩⊑˜t=⊑𝕩</code> picks the number that did not match <code>t</code> for the recursion, and
the maximum over all branches has a default value of <code>0</code>, which is supplied in case the list is empty.
<p></p>
To complete part one we just have to pick the maximum over all starting values:
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">⌈</span><span class="na">´</span><span class="o">∾</span><span class="kt">{</span><span class="o">𝕊</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="ni">:</span><span class="w"> </span><span class="nv">b</span><span class="o">+</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">Sim</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="o">SM</span><span class="p">⟨</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="p">,</span><span class="nv">b</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span><span class="kt">}</span><span class="py">∘</span><span class="o">∧</span><span class="na">¨</span><span class="m">0</span><span class="w"> </span><span class="o">Sel</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 1656</span>
</pre></div>

<p></p>
We sort the starting values for easier pattern matching,
and then just have to take some extra care of actually removing it from the list.
<hr />
<p></p>
Part two wants us to get the strongest bridge only amongst those that are longest overall.
For example, given the bridges
<ul>
<li><code>0/1—10/1—9/10</code></li>
<li><code>0/2</code></li>
<li><code>0/2—2/3—3/5</code></li>
<li><code>0/2—2/2—2/3—3/4</code></li>
<li><code>0/2—2/2—2/3—3/5</code></li>
</ul>
<p></p>
for part one <code>0/1—10/1—9/10</code> would win with a score of <code>31</code>,
and for part two <code>0/2—2/2—2/3—3/5</code> would win with a score of <code>19</code>.
Conceptually, this is sort of the same code, only with more bookkeeping.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="o">Sim2</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">i</span><span class="p">‿</span><span class="nv">t</span><span class="w"> </span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="ni">:</span><span class="w"> </span><span class="c1"># Step i, target value t, list xs</span>
<span class="w">  </span><span class="kt">{</span><span class="nv">i</span><span class="p">‿</span><span class="sr">(</span><span class="o">+</span><span class="na">´</span><span class="ni">𝕩</span><span class="sr">)</span><span class="o">+</span><span class="w"> </span><span class="o">⊑∨</span><span class="w"> </span><span class="sr">(</span><span class="o">&lt;</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="w"> </span><span class="p">⟨</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="ni">𝕩</span><span class="o">⊑</span><span class="na">˜</span><span class="nv">t</span><span class="o">=⊑</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="w"> </span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="o">SM</span><span class="w"> </span><span class="p">⟨</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="kt">}</span><span class="na">¨</span><span class="nv">t</span><span class="w"> </span><span class="o">Sel</span><span class="w"> </span><span class="nv">xs</span>
<span class="kt">}</span>
<span class="m">1</span><span class="o">⊑⌈</span><span class="na">´</span><span class="o">∾</span><span class="kt">{</span><span class="o">𝕊</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="ni">:</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="py">⊸</span><span class="o">+</span><span class="na">¨</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="nv">b</span><span class="w"> </span><span class="o">Sim2</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="o">SM</span><span class="w"> </span><span class="p">⟨</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="p">,</span><span class="nv">b</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span><span class="kt">}</span><span class="py">∘</span><span class="o">∧</span><span class="na">¨</span><span class="m">0</span><span class="w"> </span><span class="o">Sel</span><span class="w"> </span><span class="nv">inp</span><span class="w"> </span><span class="c1"># ⇒ 1642</span>
</pre></div>

<p></p>
Instead of just the current strength, we also keep track of the depth.
The maximum thus has to prefer the first index of that tuple to the second one.
Thankfully, the default
<em>sort down</em> (<a href="https://mlochbaum.github.io/BQN/doc/order.html#sort"><code>∨</code></a>)
already does this,
which gives us our answer for part two.
<p></p>
If we really wanted to, we could now combine these two solutions,
and even get rid of the <code>SM</code> and <code>Sel</code> functions, because why have human readable names if you could use funny symbols?
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="na">_sol</span><span class="w"> </span><span class="kd">←</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="o">Mx</span><span class="w"> </span><span class="na">_𝕣</span><span class="ni">:</span><span class="w">               </span><span class="c1"># Max function Mx</span>
<span class="w">  </span><span class="o">⌈</span><span class="na">´</span><span class="o">∾</span><span class="kt">{</span><span class="w"> </span><span class="o">𝕊</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="ni">:</span>
<span class="w">    </span><span class="nv">b</span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">⊑</span><span class="na">¨</span><span class="w"> </span><span class="m">1</span><span class="p">‿</span><span class="nv">b</span><span class="w"> </span><span class="kt">{</span><span class="w"> </span><span class="nv">i</span><span class="p">‿</span><span class="nv">t</span><span class="w"> </span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="ni">:</span><span class="w">  </span><span class="c1"># Step i, Target value t, list xs</span>
<span class="w">      </span><span class="kt">{</span><span class="p">⟨</span><span class="nv">i</span><span class="p">,</span><span class="o">+</span><span class="na">´</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="o">+</span><span class="w"> </span><span class="o">Mx</span><span class="w"> </span><span class="p">⟨</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="ni">𝕩</span><span class="o">⊑</span><span class="na">˜</span><span class="nv">t</span><span class="o">=⊑</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="o">Rec</span><span class="w"> </span><span class="nv">xs</span><span class="sr">(</span><span class="o">¬</span><span class="py">∘</span><span class="o">∊/⊣</span><span class="sr">)</span><span class="p">⟨</span><span class="ni">𝕩</span><span class="p">⟩</span><span class="kt">}</span><span class="na">¨</span><span class="nv">t</span><span class="sr">((</span><span class="o">&gt;∊</span><span class="na">¨</span><span class="sr">)</span><span class="o">/⊢</span><span class="sr">)</span><span class="nv">xs</span>
<span class="w">    </span><span class="kt">}</span><span class="w"> </span><span class="nv">inp</span><span class="sr">(</span><span class="o">¬</span><span class="py">∘</span><span class="o">∊/⊣</span><span class="sr">)</span><span class="p">⟨</span><span class="m">0</span><span class="p">‿</span><span class="nv">b</span><span class="p">,</span><span class="nv">b</span><span class="p">‿</span><span class="m">0</span><span class="p">⟩</span>
<span class="w">  </span><span class="kt">}</span><span class="py">∘</span><span class="o">∧</span><span class="na">¨</span><span class="m">0</span><span class="sr">((</span><span class="o">&gt;∊</span><span class="na">¨</span><span class="sr">)</span><span class="o">/⊢</span><span class="sr">)</span><span class="nv">inp</span>
<span class="kt">}</span>

<span class="kt">{</span><span class="m">0</span><span class="o">⌈</span><span class="na">´</span><span class="m">1</span><span class="o">⊑</span><span class="na">¨</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w">    </span><span class="na">_sol</span><span class="w"> </span><span class="c1"># ⇒ 1656</span>
<span class="kt">{</span><span class="o">⊑∨</span><span class="sr">(</span><span class="o">&lt;</span><span class="m">0</span><span class="p">‿</span><span class="m">0</span><span class="sr">)</span><span class="o">∾</span><span class="ni">𝕩</span><span class="kt">}</span><span class="w"> </span><span class="na">_sol</span><span class="w"> </span><span class="c1"># ⇒ 1642</span>
</pre></div>

<h3 id="day-25"><a href="https://github.com/slotThe/advent/blob/master/aoc2017/bqn/day25.bqn">Day 25</a><a href="#day-25" class="floatleft sec-link">§</a></h3>
<p></p>
Appropriately, for the final day we have to simulate a Turing machine!
Actually, it starts with a parsing problem:
the transition function of the Turing machine is given in the following format:
<div class="highlight-text" style="padding-left: 1em;"><pre><span></span>In state A:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state B.
  If the current value is 1:
    - Write the value 0.
    - Move one slot to the left.
    - Continue with state C.
</pre></div>

<p></p>
Some additional information,
like the starting state and the number of iterations we should simulate the machine for,
is also given.
Frankly, on the last day I have no intention of doing a bunch of parsing in a language which is, in my opinion, not at all suited for that kind of task.
Since the transition function is small enough, however, we can do what we did two days ago and just… inspect the input.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="nv">tape</span><span class="kd">←</span><span class="p">⟨⟩</span><span class="o">•HashMap</span><span class="p">⟨⟩</span>
<span class="o">G</span><span class="kd">←</span><span class="m">0</span><span class="py">⊸</span><span class="nv">tape</span><span class="p">.</span><span class="o">Get</span><span class="w">   </span><span class="c1"># Get</span>
<span class="o">W</span><span class="kd">←</span><span class="nv">tape</span><span class="p">.</span><span class="o">Set</span><span class="w">     </span><span class="c1"># Write</span>
<span class="o">A</span><span class="kd">←</span><span class="o">B</span><span class="kd">←</span><span class="o">C</span><span class="kd">←</span><span class="o">D</span><span class="kd">←</span><span class="o">E</span><span class="kd">←</span><span class="o">F</span><span class="kd">←</span><span class="o">⊢</span><span class="w">  </span><span class="c1"># Forward declarations!</span>
<span class="o">A</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">B</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">C</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">B</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">A</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">D</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">C</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">A</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">E</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">D</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">A</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">B</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">E</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">F</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">C</span><span class="p">⟩</span><span class="kt">}</span>
<span class="o">F</span><span class="kd">↩</span><span class="kt">{</span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">0</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">D</span><span class="p">⟩</span><span class="ni">;</span><span class="w"> </span><span class="nv">ix</span><span class="o">𝕊</span><span class="m">1</span><span class="ni">:</span><span class="w"> </span><span class="nv">ix</span><span class="w"> </span><span class="o">W</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">⋄</span><span class="w"> </span><span class="p">⟨</span><span class="nv">ix</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="o">A</span><span class="p">⟩</span><span class="kt">}</span>
</pre></div>

<p></p>
The tape is just a hash map that only keeps track of the non-zero entries.
Each of the states is a separate function that takes the current index and the value at that index,
and gives back the next index and state.
To solve part one, we just have to simulate this for the appropriate amount of time and then count the number of ones still on the tape.
<div class="highlight-bqn" style="padding-left: 1em;"><pre><span></span><span class="kt">{</span><span class="o">𝕊</span><span class="nv">i</span><span class="p">‿</span><span class="o">Sim</span><span class="ni">:</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">Sim</span><span class="w"> </span><span class="o">G</span><span class="w"> </span><span class="nv">i</span><span class="kt">}</span><span class="py">⍟</span><span class="m">12_919_244</span><span class="w"> </span><span class="m">0</span><span class="p">‿</span><span class="o">A</span>
<span class="o">+</span><span class="na">´</span><span class="nv">tape</span><span class="p">.</span><span class="o">Values</span><span class="ss">@</span><span class="w"> </span><span class="c1"># ⇒ 4287</span>
</pre></div>

<p></p>
There is probably a more array-oriented solution to this:
the transition function of this Turing machine is something like
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>δ</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>⟶</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>×</mo><mo stretchy="false">{</mo><mi mathvariant="normal">L</mi><mo separator="true">,</mo><mi mathvariant="normal">R</mi><mo stretchy="false">}</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\delta\colon Q \times \Gamma \longrightarrow Q \times \Gamma \times \{ \mathrm{L}, \mathrm{R} \},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathrm">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">R</span><span class="mclose">}</span><span class="mpunct">,</span></span></span></span></span>
where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo><mpadded class="vcenter"><mo lspace="0em" rspace="0em">:</mo></mpadded></mo><mo>=</mo><mo stretchy="false">{</mo><mtext> </mtext><mrow><mi mathvariant="normal">A</mi><mo separator="true">,</mo><mi mathvariant="normal">B</mi><mo separator="true">,</mo><mi mathvariant="normal">C</mi><mo separator="true">,</mo><mi mathvariant="normal">D</mi><mo separator="true">,</mo><mi mathvariant="normal">E</mi><mo separator="true">,</mo><mi mathvariant="normal">F</mi></mrow><mtext> </mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Q \mathrel{\vcenter{:}}= \{\, \mathrm{A,B,C,D,E,F} \,\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.4653em;"><span style="top:-3.0347em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">:</span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">F</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo><mpadded class="vcenter"><mo lspace="0em" rspace="0em">:</mo></mpadded></mo><mo>=</mo><mo stretchy="false">{</mo><mtext> </mtext><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Gamma \mathrel{\vcenter{:}}= \{\, 0, 1 \,\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.4653em;"><span style="top:-3.0347em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">:</span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span></span>.
In particular,
for any of the 12 possible inputs, one obtains a single 3-tuple as an output.
This means that one should be able to use an array of shape <code>⟨6, 2⟩</code> to solve this problem,
where every element would be a vector of length <code>3</code>, indicating the new state, tape cell, and direction.
Alternatively, I suppose, an array of shape <code>⟨6, 2, 3⟩</code> also works
(and <a href="https://saltysylvi.github.io/blog/flat1.html">would be flat</a>).
I haven’t explored this further, but it would probably be fun to implement—I will leave it as an exercise for the eager reader.
<hr />
<p></p>
As every year, part two is a freebie if one has completed all of the puzzles up until now,
as it asks for the 49 stars collected so far to reboot the printer.
Nice.
</div>

      <!-- Body is included in the above file -->
    </section>
    
      <!-- A footer-ish thing above the actual boring footer for pretty
           fleurons and things that should only appear on posts. -->
      <div style="text-align:center;">
        <img class="center-block-dark" src="../images/fleuron-dark.svg" style="max-width: 3cm" alt="End of post fleuron">
        <img class="center-block-light" src="../images/fleuron.svg" style="max-width: 3cm" alt="End of post fleuron">
        Have a comment? Write me an <a href="../about.html">email!</a>
      </div>
    
</article>


        </div>
        <div id="footer">
          <!-- Left -->
          <a id="to-top" href="#">top</a>
          <!-- Right -->
          <a href="../atom.xml" style="font-variant:small-caps">rss</a>
          &nbsp;|&nbsp;
          <a href="https://github.com/slotThe/slotThe.github.io">Website source</a>
          &nbsp;|&nbsp;
          <a href="../impressum.html">Legal notice and privacy policy</a>
        </div>
      </div>
    </div>
  </body>
</html>
