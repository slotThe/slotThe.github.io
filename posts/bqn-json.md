---
title: Writing a JSON parser in BQN
date: 2025-10-08
tags: BQN
---

Let's write a JSON parser in BQN!

<!--more-->

At least, for some vague definition of JSON.
I will restrict myself to the following underspecified subset,
so that this will not be a 20'000-word post:

+ Only (positive) integers.
+ ASCII only and only `\`-based escaping.
+ No constants.
+ Absolutely no input validation‚Äîwe'll try to parse the wildest things.

Some of those are not difficult to add:
adding negative integers is a 4-character change,
and other number formats are not much harder.
Constants are a fun exercise for the reader, and also useful for JSON in the wild.
Input validation is not difficult per se,
but seemed a bit too tedious for this blog post to me.
I'm staying away from Unicode though,
see [bqn-libs/json.bqn][bqn-libs:json] for that.
In general, I do not claim originality for any line of code in this post<!--
-->‚Äîthis is more or less my attempt to understand [bqn-libs/json.bqn][bqn-libs:json] to a reasonable degree.

This article assumes that you are already a bit familiar with BQN as a language,
or know some amount of array programming and are willing to look up unknown symbols.
If not, I recommend starting with the official [tutorials](https://mlochbaum.github.io/BQN/tutorial/index.html).
I've also written about my experience of
[using BQN](https://tony-zorman.com/posts/aoc-in-bqn.html)
for Advent of Code,
a post which certainly contains some amount of written words that talk about the language.
I'll recall the basic tricks that one uses in array-oriented parsing,
though if you feel like I'm going too fast perhaps it's a good idea to peruse my post about writing a
[CSV parser](https://tony-zorman.com/posts/bqn-csv.html).[^9]

# Lists of numbers

We'll start with simply trying to parse lists of integers.
Can't be that hard, right?
Additionally<!--
-->‚Äîand this is where *array-oriented* starts to come into play‚Äî<!--
-->we want to handle as much as possible using flat arrays.
This is both faster and way cooler.
In particular, this will result in a parser that has essentially no branching to speak of:
everything is just executed in order, line by line.

Motivated by an Advent of Code problem,
[Sylvia](https://saltysylvi.github.io/blog/index.html)
has already written a
[fantastic article](https://saltysylvi.github.io/blog/parsing-nested-lists-in-bqn.html)
about this exact type of thing,
including a comparison with two other approaches:
recursive descent, as well as a more nested array-style parser.[^8]
I will follow the same approach for this part of the parser;
if you've already read‚Äîand understood‚ÄîSylvia's post, feel free to skip to [Adding strings](#adding-strings).

Assume we have a list of numbers like the following:[^10]

``` bqn
    inp ‚Üê "[12,34,5,678,910]"
"[12,34,5,678,910]"
```

We'll follow standard practise by first tokenising‚Äîlexing‚Äîthe string,
and then parsing the tokens.

## Tokenisation

Brackets can stay as they are,
each number will be replaced by a single `0`,
and thus all commas can be removed.
We'll then return a two element array,
the first entry containing the tokenised array,
and the second one being all of the numbers.

``` bqn
    Tokenise inp
‚ü® "[00000]" ‚ü® 12 34 5 678 910 ‚ü© ‚ü©
```

The first thing we have to do is to get the start of each number,
and save that in a variable `ns`,
while a mask of all numbers will be called `n`.

``` bqn
    '0'+‚Üï10
"0123456789"
    inp‚àä('0'+‚Üï10)
‚ü® 0 1 1 0 1 1 0 1 0 1 1 1 0 1 1 1 0 ‚ü©
    ¬ª‚ä∏< inp‚àä('0'+‚Üï10)
‚ü® 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 ‚ü©
    ns ‚Üê ¬ª‚ä∏< n‚Üêinp‚àä('0'+‚Üï10)
‚ü® 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 ‚ü©
    n         # For comparison
‚ü® 0 1 1 0 1 1 0 1 0 1 1 1 0 1 1 1 0 ‚ü©
    inp ‚âç ns  # Visualise ns by stacking inp on top of it
‚îå‚îÄ
‚ïµ '[' '1' '2' ',' '3' '4' ',' '5' ',' '6' '7' '8' ',' '9' '1' '0' ']'
   0   1   0   0   1   0   0   1   0   1   0   0   0   1   0   0   0
                                                                     ‚îò
```

While it's not immediately obvious,
defining `ns` is useful because we can create a depth scan of all numbers,
where the start of each new number increases the depth by one.

``` bqn
    +`ns
‚ü® 0 1 1 1 2 2 2 3 3 4 4 4 4 5 5 5 5 ‚ü©
    inp ‚âç +`ns
‚îå‚îÄ
‚ïµ '[' '1' '2' ',' '3' '4' ',' '5' ',' '6' '7' '8' ',' '9' '1' '0' ']'
   0   1   1   1   2   2   2   3   3   4   4   4   4   5   5   5   5
                                                                     ‚îò
```

By supplementing this with `n`,
we obtain sufficient information to *group* the string!

``` bqn
    n√ó+`ns                                    # Stencil out the numbers
‚ü® 0 1 1 0 2 2 0 3 0 4 4 4 0 5 5 5 0 ‚ü©
    1-Àú n√ó+`ns                                # Kill irrelevant part
‚ü® ¬Ø1 0 0 ¬Ø1 1 1 ¬Ø1 2 ¬Ø1 3 3 3 ¬Ø1 4 4 4 ¬Ø1 ‚ü©
    (1-Àú n√ó+`ns)‚äîinp                          # Grouping
‚ü® "12" "34" "5" "678" "910" ‚ü©
    ‚Ä¢ParseFloat¬® (1-Àú n√ó+`ns)‚äîinp             # Parsing
‚ü® 12 34 5 678 910 ‚ü©
    (10‚ä∏√ó‚ä∏+Àú¬¥‚àò‚åΩ-‚üú'0')¬® (1-Àú n√ó+`ns)‚äîinp       # Or: manual parsing
‚ü® 12 34 5 678 910 ‚ü©
```

Now all that's left in the tokenisation step
is to create the string `"[00000]"` from the input.
Since we know all other tokens,
this can be achieved with a combination of *replicate*, *indices*, and *under*:

``` bqn
    ts ‚Üê ns ‚à® inp‚àä"[]"                # Tokens are numbers and brackets
‚ü® 1 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 ‚ü©
    ts/inp                            # Just the tokens of the string
"[13569]"
    ns/inp                            # Number beginnings
"13569"
    '0'¬®‚åæ(ns‚ä∏/)inp                    # Make them zero
"[02,04,0,078,010]"
    ts/'0'¬®‚åæ(ns‚ä∏/)inp                 # Choose just the tokens
"[00000]"
```

That'll do!
We can put all of this into a function now:[^1]

``` bqn
Tokenise ‚Üê {
  ns ‚Üê ¬ª‚ä∏< n‚Üêùï©‚àä'0'+‚Üï10           # Number beginnings
  nr ‚Üê ‚Ä¢ParseFloat¬®(1-Àún√ó+`ns)‚äîùï© # Numbers to return
  ts ‚Üê ns‚à®ùï©‚àä"[]"                 # Tokens
  ‚ü®ts/'0'¬®‚åæ((/ns)‚ä∏‚äè)ùï©, nr‚ü©
}
```

This of course also works with nested lists,
giving us a flat representation in `nr`:

``` bqn
    Tokenise "[1,[2,[3],4],[5,6]]"
‚ü® "[0[0[0]0][00]]" ‚ü® 1 2 3 4 5 6 ‚ü© ‚ü©
```

Using the "blueprint" `"[0[0[0]0][00]]"`,
the main job of the parser will be to turn the flat representation of `nr` back into a nested list.

## Parsing

The end result we want looks like this:

``` bqn
    Parse "[1,[2,[3]],4]"
‚ü® 1 ‚ü® 2 ‚ü® 3 ‚ü© ‚ü© 4 ‚ü©
```

For this post, let's define a function to compactly display some text,
so that I can use some more complicated arguments without *couple* taking up too much space.

``` bqn
    DP ‚Üê { ùï®‚âç'0'+ùï© }
(function block)
    "abc" DP ‚ü®1,2,3‚ü©
‚îå‚îÄ
‚ïµ"abc
  123"
      ‚îò
```

The first thing we need to do is to get a depth ordering of the list;
i.e., make an opening bracket increase and have a closing one decrease the depth by one.[^11]

``` bqn
    inp‚Üê"[1,[2,[3,4]],5,[6,7],8]"
"[1,[2,[3,4]],5,[6,7],8]"
    ts‚Äønums ‚Üê Tokenise inp # Tokens and numbers
‚ü® "[0[0[00]]0[00]0]" ‚ü® 1 2 3 4 5 6 7 8 ‚ü© ‚ü©
    o ‚Üê '['=ts             # Opening brackets
‚ü® 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 ‚ü©
    c ‚Üê ']'=ts             # Closing brackets
‚ü® 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 ‚ü©
    ts DP +`o-c
‚îå‚îÄ
‚ïµ"[0[0[00]]0[00]0]
  1122333211222110"
                   ‚îò
```

We can obtain a depth ordering of the list by turning ``+`o-c`` into a permutation with *grade up*
and then indexing into the tokens with *select*.

``` bqn
    d ‚Üê ‚çã+`o-c # Depth ordering
‚ü® 15 0 1 8 9 13 14 2 3 7 10 11 12 4 5 6 ‚ü©
    d‚äèts
"][0]0]0[0][00[00"
```

This is pretty hard to read at first (and even later),
but it's really nothing more than a breadth-first ordering of the input.
Since `inp` is defined as `"[1,[2,[3,4]],5,[6,7],8]"`
and so in particular only contains one-digit numbers,
it's perhaps more instructive to look at

``` bqn
    d‚äè(','‚ä∏‚â†)‚ä∏/inp
"][1]5]8[2][67[34"
```

Drawing a picture often helps:

\begin{tikzpicture}
  \begin{pgfonlayer}{nodelayer}
      \node [style=whitedot] (0) at (0, 5) {]};
      \node [style=whitedot] (1) at (0, 4.5) {[};
      \node [style=whitedot] (2) at (-2, 3.5) {1};
      \node [style=whitedot] (3) at (-1, 3.5) {]};
      \node [style=whitedot] (4) at (0, 3.5) {5};
      \node [style=whitedot] (5) at (1, 3.5) {]};
      \node [style=whitedot] (6) at (2, 3.5) {8};
      \node [style=whitedot] (7) at (-1, 3) {[};
      \node [style=whitedot] (10) at (1, 3) {[};
      \node [style=whitedot] (11) at (0.5, 2.25) {6};
      \node [style=whitedot] (12) at (1.5, 2.25) {7};
      \node [style=whitedot] (13) at (-1.5, 2.25) {2};
      \node [style=whitedot] (14) at (-0.5, 2.25) {]};
      \node [style=whitedot] (15) at (-0.5, 1.75) {[};
      \node [style=whitedot] (16) at (-1, 1) {3};
      \node [style=whitedot] (17) at (0, 1) {4};
  \end{pgfonlayer}
  \begin{pgfonlayer}{edgelayer}
      \draw (0) to (1);
      \draw (1) to (2);
      \draw (1) to (3);
      \draw (1) to (4);
      \draw (1) to (5);
      \draw (1) to (6);
      \draw (3) to (7);
      \draw (5) to (10);
      \draw (10) to (11);
      \draw (10) to (12);
      \draw (15) to (16);
      \draw (15) to (17);
      \draw (7) to (13);
      \draw (7) to (14);
      \draw (14) to (15);
  \end{pgfonlayer}
\end{tikzpicture}

So `]` indicates that a new sublist be placed at a certain slot,
and `[` is the start of such a sublist.
Filling in the tree from the string proceeds from left to right,
and every time we encounter a `[` we look for the "oldest" `]` that still isn't filled, and start there.

We now assign each sublist the depth in this tree representation.
This works much like the ``+`o-c`` trick above,
only we don't need to care about closing parentheses<!--
-->‚Äîthey only show up when we are going a level deeper anyways.

``` bqn
    '['=d‚äèts
‚ü® 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 ‚ü©
    l ‚Üê (‚çãd)‚äè+`'['=d‚äèts             # Nesting
‚ü® 1 1 2 2 4 4 4 2 1 1 3 3 3 1 1 0 ‚ü©
    ts DP l
‚îå‚îÄ
‚ïµ"[0[0[00]]0[00]0]
  1122444211333110"
                   ‚îò
```

Compare this with the above tree.
One important detail is that we index with `‚çãd` and not just `d`:
since `d` is a permutation already, we can invert it with another call to *grade up*.
This effectively allows us to translate back from the BFS ordering of `d‚äèts`,
into the "ordinary" ordering that we started with.

This is a lot to take in;
I would encourage you to play with these ideas for a while, until you're comfortable with them.

---

Now that we know in which order to fill the sublists,
it's about time that we figure out which values to use for that very filling.

``` bqn
    ln ‚Üê ts‚àä"0]"                 # Literals and nesting
‚ü® 0 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 ‚ü©
    ts DP ln
‚îå‚îÄ
‚ïµ"[0[0[00]]0[00]0]
  0101011111011111"
                   ‚îò
    (ln/ts='0') + 2√óln/c
‚ü® 1 1 1 1 2 2 1 1 1 2 1 2 ‚ü©
    vi ‚Üê ‚çã‚çã (ln/ts='0') + 2√óln/c # Value indices
‚ü® 0 1 2 3 8 9 4 5 6 10 7 11 ‚ü©
    (ln/ts) ‚âç vi
‚îå‚îÄ
‚ïµ '0' '0' '0' '0' ']' ']' '0' '0' '0' ']' '0' ']'
   0   1   2   3   8   9   4   5   6   10  7   11
                                                  ‚îò
    inp
"[1,[2,[3,4]],5,[6,7],8]"
```

We separate out the literals,
as well as the "nesting indicator" `]`,
and then produce a list of "value indices"
that should indicate the order in which the final output is to be filled.
We use the
[ordinals pattern](https://mlochbaum.github.io/BQN/doc/order.html#ordinals)
`‚çã‚çã` to turn `ln` into something we can actually use to index into `ts`.
However, there is a problem:
the filling of the actual literals will be from left to right,
so the order is fine already,
but the closing brackets are all over the place.
For example, the second `]`, assigned to index `9`, is associated to the sublist `[6,7]` in the original input.
Since we will construct the final list bottom-up,
this should come after the list `[2,[3,4]]`,
the closing bracket of which is however assigned to index `10`.

To fix this, we use the nesting variable `l` defined above<!--
-->‚Äîthere, we've already associated a sublist to its depth in the breadth-first representation.
Looking at `l` again, we can find the index of the sublist that a given `]` is closing by looking at the index of the element in front of it:

``` bqn
    ts DP l
‚îå‚îÄ
‚ïµ"[0[0[00]]0[00]0]
  1122444211333110"
                   ‚îò
    c/¬ªl
‚ü® 4 2 3 1 ‚ü©
```

Since the list with the highest index above will be constructed first,
we have to invert these numbers.
Then, we just have to add these to the rest of the literals.

``` bqn
    c/¬ªl
‚ü® 4 2 3 1 ‚ü©
    ‚â†‚ä∏- c/¬ªl          # Deeply nested lists are constructed *first*
‚ü® 0 2 1 3 ‚ü©
    (‚â†nums)+ ‚â†‚ä∏- c/¬ªl # Indices should not clash with literals
‚ü® 8 10 9 11 ‚ü©
    (‚Üï‚â†nums)‚àæ (‚â†nums)+ ‚â†‚ä∏- c/¬ªl # Add to end
‚ü® 0 1 2 3 4 5 6 7 8 10 9 11 ‚ü©
    vi ‚Ü© vi‚äè(‚Üï‚â†nums)‚àæ (‚â†nums)+ ‚â†‚ä∏- c/¬ªl # Fix vi by indexing this new list
‚ü® 0 1 2 3 8 10 4 5 6 9 7 11 ‚ü©
```

This gives us fixed indices:

``` bqn
    (ln/ts) ‚âç vi
‚îå‚îÄ
‚ïµ '0' '0' '0' '0' ']' ']' '0' '0' '0' ']' '0' ']'
   0   1   2   3   8   10  4   5   6   9   7   11
                                                  ‚îò
```

This means we first construct `[3,4]`, then `[2,[3,4]]`, then `[6,7]`, and finally the whole list `[1,[2,[3,4]],5,[6,7],8]`.
For this, we simply have to *group* the indices of `vi` accordingly.

``` bqn
    vi
‚ü® 0 1 2 3 8 10 4 5 6 9 7 11 ‚ü©
    ln/l # Since vi also only contains indices for literals and nesting
‚ü® 1 2 4 4 2 1 1 3 3 1 1 0 ‚ü©
    (ln/l)‚äîvi
‚ü® ‚ü® 11 ‚ü© ‚ü® 0 10 4 9 7 ‚ü© ‚ü® 1 8 ‚ü© ‚ü® 5 6 ‚ü© ‚ü® 2 3 ‚ü© ‚ü©
    1-Àúln/l # Drop final ] for the whole list
‚ü® 0 1 3 3 1 0 0 2 2 0 0 ¬Ø1 ‚ü©
    ‚åΩ(1-Àúln/l)‚äîvi # Reverse to build deeply nested lists sooner
‚ü® ‚ü® 2 3 ‚ü© ‚ü® 5 6 ‚ü© ‚ü® 1 8 ‚ü© ‚ü® 0 10 4 9 7 ‚ü© ‚ü©
```

Now all that is left is to build the whole list recursively.
We start with the list of literals,
construct the next list, and add it to the end of the list of literals.
This way, the later indices `8`, `9`, and `10` will refer to these sublists.

``` bqn
    ‚åΩ(1-Àúln/l)‚äîvi
‚ü® ‚ü® 2 3 ‚ü© ‚ü® 5 6 ‚ü© ‚ü® 1 8 ‚ü© ‚ü® 0 10 4 9 7 ‚ü© ‚ü©
    nums
‚ü® 1 2 3 4 5 6 7 8 ‚ü©
    2‚Äø3‚äènums
‚ü® 3 4 ‚ü©
    nums ‚àæ‚Ü© <2‚Äø3‚äènums
‚ü® 1 2 3 4 5 6 7 8 ‚ü® 3 4 ‚ü© ‚ü©
    nums ‚àæ‚Ü© <5‚Äø6‚äènums
‚ü® 1 2 3 4 5 6 7 8 ‚ü® 3 4 ‚ü© ‚ü® 6 7 ‚ü© ‚ü©
    nums ‚àæ‚Ü© <1‚Äø8‚äènums
‚îå‚îÄ
¬∑ 1 2 3 4 5 6 7 8 ‚ü® 3 4 ‚ü© ‚ü® 6 7 ‚ü© ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü©
                                                ‚îò
    nums ‚àæ‚Ü© <0‚Äø10‚Äø4‚Äø9‚Äø7‚äènums
‚îå‚îÄ
¬∑ 1 2 3 4 5 6 7 8 ‚ü® 3 4 ‚ü© ‚ü® 6 7 ‚ü© ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü© ‚îå‚îÄ
                                                ¬∑ 1 ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü© 5 ‚ü® 6 7 ‚ü© 8
                                                                              ‚îò
                                                                                ‚îò
    ¬Ø1‚äënums
‚îå‚îÄ
¬∑ 1 ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü© 5 ‚ü® 6 7 ‚ü© 8
                              ‚îò
```

More concisely:

``` bqn
    res ‚Üê nums # Mutation is evil
‚ü® 1 2 3 4 5 6 7 8 ‚ü©
    {res ‚àæ‚Ü© <ùï©‚äères ‚ãÑ@}¬® ‚åΩ(1-Àúln/l)‚äîvi
"    "
    ¬Ø1‚äëres
‚îå‚îÄ
¬∑ 1 ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü© 5 ‚ü® 6 7 ‚ü© 8
                              ‚îò
```

One tiny change has to be made to the building of the sublists:
if our input is `"[]"`, then `1-Àúln/l` will be `‚ü®¬Ø1‚ü©`,
to the list as a whole will be dropped!
We can hackily fix this by always appending the total number of closing brackets to the back of the list via `(+¬¥c)‚àæÀú`.
If the list is empty, then this will accommodate for that case.
Otherwise, the left argument to *group* will be one element longer than the right one.
This is not a problem, however, because that's actually a feature[^12] of the function:
in that case, the last element specified the minimum length of the result.

``` bqn
    0‚Äø¬Ø1‚Äø1‚Äø4 ‚äî "abc" # Padding
‚ü® "a" "c" ‚ü®‚ü© ‚ü®‚ü© ‚ü©
```

Putting everything together:

``` bqn
Parse ‚Üê {
  ts‚Äønums ‚Üê Tokenise ùï©                 # Tokens and numbers
  o ‚Üê '['=ts                           # Opening brackets
  c ‚Üê ']'=ts                           # Closing brackets
  d ‚Üê ‚çã+`o-c                           # Depth ordering
  ln ‚Üê ts‚àä"0]"                         # Literals and nesting
  l ‚Üê (‚çãd)‚äè+`'['=d‚äèts                  # Sublist depth
  vi ‚Üê ‚çã‚çã (ln/ts='0') + 2√óln/c         # Value indices
  r ‚Üê nums                             # Result
  vi ‚äè‚Ü© (‚Üï‚â†nums)‚àæ(‚â†nums)+ ‚â†‚ä∏- c/¬ªl     # Fix value indices
  {r ‚àæ‚Ü© <ùï©‚äèr ‚ãÑ@}¬® ‚åΩ((+¬¥c)‚àæÀú1-Àúln/l)‚äîvi # Build result
  ¬Ø1‚äër
}
```

Works like a charm:

``` bqn
    Parse "[1,[2,[3,4]],5,[6,7],8]"
‚îå‚îÄ
¬∑ 1 ‚ü® 2 ‚ü® 3 4 ‚ü© ‚ü© 5 ‚ü® 6 7 ‚ü© 8
                              ‚îò
    Parse "[]"
‚ü®‚ü©
    Parse "[1, [42, [[0], 2, 3]], 30]"
‚îå‚îÄ
¬∑ 1 ‚îå‚îÄ                   30
    ¬∑ 42 ‚ü® ‚ü® 0 ‚ü© 2 3 ‚ü©
                       ‚îò
                            ‚îò
    Parse "[1,2,[],[3,4,[5,6]],7,8,[9,[],10]]"
‚îå‚îÄ
¬∑ 1 2 ‚ü®‚ü© ‚ü® 3 4 ‚ü® 5 6 ‚ü© ‚ü© 7 8 ‚ü® 9 ‚ü®‚ü© 10 ‚ü©
                                         ‚îò
```

# Adding strings

I'd like to add one more literal,
so that we get a feeling for how to do that sort of extension;
strings sound like a good idea.

First, the lexer: getting the strings and their beginnings works almost the same as in the numbers case above.[^13]

``` bqn
    inp ‚Üê "[1,""a"",2,""b""]"
"[1,""a"",2,""b""]"
    s ‚Üê ‚â†`'"'=inp             # strings
‚ü® 0 0 0 1 1 0 0 0 0 1 1 0 0 ‚ü©
```

Before we move on, let's slightly change the definition of `DP`:
for syntax highlighting reasons, I'd like quotes to occupy a single character that is not the quote character itself.
Let's just substitute `'` for `"` in the left argument,
which should fix this issue and hopefully still be clear enough.

``` bqn
    DP ‚Üê {((@+39)¬®‚åæ((ùï®='"')‚ä∏/)ùï®) ‚âç '0'+ùï©}
(function block)
    inp DP s
‚îå‚îÄ
‚ïµ"[1,'a',2,'b']
  0001100001100"
                ‚îò
    sb ‚Üê ¬ª‚ä∏< s                # string beginnings
‚ü® 0 0 0 1 0 0 0 0 0 1 0 0 0 ‚ü©
    inp DP sb
‚îå‚îÄ
‚ïµ"[1,'a',2,'b']
  0001000001000"
                ‚îò
```

Selecting the strings also works the same way;
do a sum *scan* on the string beginnings, punch out the actual strings, and then *group*.

``` bqn
    1-Àús√ó+`sb
‚ü® ¬Ø1 ¬Ø1 ¬Ø1 0 0 ¬Ø1 ¬Ø1 ¬Ø1 ¬Ø1 1 1 ¬Ø1 ¬Ø1 ‚ü©
    +`sb
‚ü® 0 0 0 1 1 1 1 1 1 2 2 2 2 ‚ü©
    1-Àús√ó+`sb
‚ü® ¬Ø1 ¬Ø1 ¬Ø1 0 0 ¬Ø1 ¬Ø1 ¬Ø1 ¬Ø1 1 1 ¬Ø1 ¬Ø1 ‚ü©
    (1-Àús√ó+`sb)‚äîinp
‚ü® """a" """b" ‚ü©
    1‚Üì¬® (1-Àús√ó+`sb)‚äîinp
‚ü® "a" "b" ‚ü©
```

Actually, you can be a little bit smarter here;
instead of dropping the first element of every string,
we can instead make sure that they are never selected by *group*
by comparing when `s` is bigger than `sb`:
this will only be the case if one is truly inside of a string.

``` bqn
    (s>sb)√ó+`sb               # Same as (s‚àß¬¨sb)√ó+`sb
‚ü® 0 0 0 0 1 0 0 0 0 0 2 0 0 ‚ü©
    (1-Àú(s>sb)√ó+`sb)‚äîinp
‚ü® "a" "b" ‚ü©
```

Putting this together in our tokeniser,
we now also need to make sure that we ignore everything that's happening inside of a string.
To do that, we can introduce an "exclusion" variable
`ex ‚Üê s‚à®ùï©‚àä@+9‚Äø10‚Äø13‚Äø32`
and thread it through to the respective definitions.[^5]

``` bqn
Tokenise ‚Üê {
  sb ‚Üê ¬ª‚ä∏< s‚Üê‚â†`'"'=ùï©             # String beginnings
  sr ‚Üê (1-Àú(s>sb)√ó+`sb)‚äîùï©        # Strings to return

  ex ‚Üê s‚à®ùï©‚àä@+9‚Äø10‚Äø13‚Äø32          # Exclude whitespace and strings
  nb ‚Üê ¬ª‚ä∏< n‚Üê (¬¨ex)‚àß ùï©‚àä'0'+‚Üï10   # Number beginnings
#             ^^^^^^
  nr ‚Üê ‚Ä¢ParseFloat¬®(1-Àún√ó+`nb)‚äîùï© # Numbers to return

  ts ‚Üê sb‚à®(¬¨ex)‚àßnb‚à®ùï©‚àä"[]"        # Tokens
#         ^^^^^^
  ‚ü®ts/ '0'¬®‚åæ(nb‚ä∏/) ùï©, nr, sr‚ü©
}
```

``` bqn
    Tokenise "[1,""a"",2,""b""]"
‚ü® "[0""0""]" ‚ü® 1 2 ‚ü© ‚ü® "a" "b" ‚ü© ‚ü©
    Tokenise "[1,""a,2,b""]"
‚ü® "[0""]" ‚ü® 1 ‚ü© ‚ü® "a,2,b" ‚ü© ‚ü©
```

## Parsing

Adjusting the parser is actually quite easy here:
we just have to add quotes to the allowed literals,
make the value indices aware of them,
and also feed them into the initial value of the result;
no further changes necessary.

``` bqn
Parse ‚Üê {
  ts‚Äønums‚Äøstrs ‚Üê Tokenise ùï©                    # Tokens, numbers, and strings
#        ^^^^^
  o ‚Üê '['=ts                                   # Opening, closing, depth
  c ‚Üê ']'=ts                                   # Closing brackets
  d ‚Üê ‚çã+`o-c                                   # Depth ordering
  ln ‚Üê ts‚àä"""0]"                               # Literals and nesting
#          ^^
  l ‚Üê (‚çãd)‚äè+`'['=d‚äèts                          # Sublist depth
  vi ‚Üê ‚çã‚çã (ln/ts='0') + (2√óln/ts='"') + 3√óln/c # Value indices
#                       ^^^^^^^^^^^^^
  r ‚Üê nums‚àæstrs                                # Result
#         ^^^^^
  vi ‚äè‚Ü© (‚Üï‚â†r)‚àæ(‚â†r)+ ‚â†‚ä∏- c/¬ªl                   # Fix value indices
  {r ‚àæ‚Ü© <ùï©‚äèr ‚ãÑ@}¬® ‚åΩ((+¬¥c)‚àæÀú1-Àúln/l)‚äîvi         # Build result
  ¬Ø1‚äër
}
```

## Escaping

To make things a little bit‚Äîthough not too‚Äîinteresting, let's add some easy escaping.
By this I exclusively mean backslash-based escaping:
every time we encounter a backslash inside of a string,
we treat the following character (e.g., a quote) literally.
Thinking about semantics a bit, if we have a sequence of backslashes like `\\\\\`,
we want to alternate between treating them as the escapist and the escapee.
One way to do this is with a less-than *scan*:

``` bqn
    inp ‚Üê "[1,""a"",""b_\\\""\\_c""]"
"[1,""a"",""b_\\\""\\_c""]"
    '\'=inp
‚ü® 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 ‚ü©
    <`'\'=inp
‚ü® 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 ‚ü©
    inp DP <`'\'=inp
‚îå‚îÄ
‚ïµ"[1,'a','b_\\\'\\_c']
  00000000001010100000"
                       ‚îò
```

We effectively check if the previous character of the string was escaped, but in a left-to-right fashion
(as in, earlier choices on the left affect those on the right).
To get the escaped values themselves, we can now simply *nudge* the string to the right.

``` bqn
    inp DP ¬ª<`'\'=inp
‚îå‚îÄ
‚ïµ"[1,'a','b_\\\'\\_c']
  00000000000101010000"
                       ‚îò
```

Finally, when selecting the strings, we just need to exclude the escaped quotes:

``` bqn
    e ‚Üê ¬ª<`'\'=inp     # Escapes
‚ü® 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 ‚ü©
    s ‚Üê ‚â†`(¬¨e)‚àß'"'=inp # Strings are in quotes that are not escaped
‚ü® 0 0 0 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 ‚ü©
    sb ‚Üê ¬ª‚ä∏< s
‚ü® 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 ‚ü©
    (1-Àú(s>sb)√ó+`sb)‚äîinp
‚ü® "a" "b_\\\""\\_c" ‚ü©
```

As we are dealing with Boolean masks,
alternatively to `(¬¨e)‚àß'"'=inp` one could also write the shorter,
though slightly more obscure,
`e<'"'=inp`.
All in all, we have

``` bqn
Tokenise ‚Üê {
  e  ‚Üê ¬ª<`'\'=ùï©                  # Escapes
  sb ‚Üê ¬ª‚ä∏< s‚Üê ‚â†`(¬¨e)‚àß '"'=ùï©      # String beginnings
  sr ‚Üê (1-Àú(s>sb)√ó+`sb)‚äîùï©        # Strings to return

  ex ‚Üê s‚à® ùï©‚àä@+9‚Äø10‚Äø13‚Äø32         # Exclude whitespace and strings
  nb ‚Üê ¬ª‚ä∏< n‚Üê (¬¨ex)‚àß ùï©‚àä'0'+‚Üï10   # Number beginnings
  nr ‚Üê ‚Ä¢ParseFloat¬®(1-Àún√ó+`nb)‚äîùï© # Numbers to return

  ts ‚Üê sb‚à®(¬¨ex)‚àßnb‚à®ùï©‚àä"[]"        # Tokens
  ‚ü®ts/ '0'¬®‚åæ(nb‚ä∏/) ùï©, nr, sr‚ü©
}
```

``` bqn
    Tokenise "[1,""a,2,b""]"
‚ü® "[0""]" ‚ü® 1 ‚ü© ‚ü® "a,2,b" ‚ü© ‚ü©
    Tokenise "[1,""a"",""b_\\\""\\_c"",2]"
‚ü® "[0""""0]" ‚ü® 1 2 ‚ü© ‚ü® "a" "b_\\\""\\_c" ‚ü© ‚ü©
```

The parser doesn't need to be adjusted at all this time and just works:

``` bqn
    Parse "[1,""a"",""b_\\\""\\_c"",2]"
‚ü® 1 "a" "b_\\\""\\_c" 2 ‚ü©
    Parse "[1,[2,[""[x,10]"",4]],5,[""a"",7],8]"
‚îå‚îÄ
¬∑ 1 ‚ü® 2 ‚ü® "[x,10]" 4 ‚ü© ‚ü© 5 ‚ü® "a" 7 ‚ü© 8
                                       ‚îò
```

# Objects and their ilk

Onto the second big type we have to support: objects.
They should look like

```
{"a": 1, "b": ["c", "d"]}
```

and so on.

This time, lexing is the easy part‚Äîwe merely have to add curly braces to our list of tokens.
Actually, to keep things visually comprehensible,
let's go back on what I said at the beginning
and do the same for the comma as the array separator,
and the colon as the key‚Äìvalue separator.

``` bqn
Tokenise ‚Üê {
  e  ‚Üê ¬ª<`'\'=ùï©                  # Escapes
  sb ‚Üê ¬ª‚ä∏< s‚Üê ‚â†`(¬¨e)‚àß '"'=ùï©      # String beginnings
  sr ‚Üê (1-Àú(s>sb)√ó+`sb)‚äîùï©        # Strings to return

  ex ‚Üê s‚à® ùï©‚àä@+9‚Äø10‚Äø13‚Äø32         # Exclude whitespace and strings
  nb ‚Üê ¬ª‚ä∏< n‚Üê (¬¨ex)‚àß ùï©‚àä'0'+‚Üï10   # Number beginnings
  nr ‚Üê ‚Ä¢ParseFloat¬®(1-Àún√ó+`nb)‚äîùï© # Numbers to return

  ts ‚Üê sb‚à®(¬¨ex)‚àßnb‚à®ùï©‚àä"[]{},:"    # Tokens
#                       ^^^^
  ‚ü®ts/ '0'¬®‚åæ(nb‚ä∏/) ùï©, nr, sr‚ü©
}
```

``` bqn
    Tokenise "{""a"": 123, ""bcde"": [1,""42"",30]}"
‚ü® "{"":0,"":[0,"",0]}" ‚ü® 123 1 30 ‚ü© ‚ü® "a" "bcde" "42" ‚ü© ‚ü©
```

Looks good.

## Parsing

Since the parser will change quite a bit,
it is perhaps more instructive to build it up from scratch again.
Up to getting the depth, things don't really change much.

``` bqn
    inp ‚Üê "{""a"": 1, ""b"": [""1"",2,{""a"":2}]}"
"{""a"": 1, ""b"": [""1"",2,{""a"":2}]}"
    ts‚Äønums‚Äøstrs ‚Üê Tokenise inp
‚ü® "{"":0,"":["",0,{"":0}]}" ‚ü® 1 2 2 ‚ü© ‚ü® "a" "b" "1" "a" ‚ü© ‚ü©
    o ‚Üê ts‚àä"{["  # Open
‚ü® 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 ‚ü©
    c ‚Üê ts‚àä"]}"  # Close
‚ü® 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 ‚ü©
    cl ‚Üê ':'=ts  # Colon
‚ü® 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 ‚ü©
    d ‚Üê ‚çã+`o-c   # Depth
‚ü® 18 0 1 2 3 4 5 6 17 7 8 9 10 11 16 12 13 14 15 ‚ü©
    td ‚Üê d‚äèts    # Tokens by depth
"}{"":0,"":]["",0,}{"":0"
```

Since we now have two different "container" types,
we also need to be careful about how "nesting" is defined‚Äî<!--
-->sometimes we may only want the delimiters of one container to increase the level of nesting.
Let's start with getting a mask of the start of all new sublists[^14],
which are now defined by an opening brace or bracket:

``` bqn
    s ‚Üê td‚àä"[{"  # Sublist starts
‚ü® 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ‚ü©
    td DP s
‚îå‚îÄ
‚ïµ"}{':0,':][',0,}{':0
  0100000001000001000"
                      ‚îò
```

We also did the same thing in the original parser
when we defined the sublist depth ``l ‚Üê (‚çãd)‚äè+`'['=d‚äèts``,
only we didn't give `'['=d‚äèts`
(which now morphed to `(d‚äèts)‚àä"[{"` due to the additional container types) a name.
However, defining the sublist depth still works as before:

``` bqn
    n ‚Üê (‚çãd)‚äè+`s  # Nesting
‚ü® 1 1 1 1 1 1 1 2 2 2 2 2 3 3 3 3 2 1 0 ‚ü©
    ts DP n
‚îå‚îÄ
‚ïµ"{':0,':[',0,{':0}]}
  1111111222223333210"
                      ‚îò
```

Moving on, we can use the mask of sublists `s` to build a mask of sub-objects.

``` bqn
    s
‚ü® 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ‚ü©
    td DP s
‚îå‚îÄ
‚ïµ"}{':0,':][',0,}{':0
  0100000001000001000"
                      ‚îò
    of ‚Üê s/'{'=td  # Filter of sublists that are objects
‚ü® 1 0 1 ‚ü©
```

The `of` variable is to be read as something like "there are three sublists, the first and third of which are sub-objects".
This is good, but doesn't yet take object nesting into account<!--
-->‚Äîthe second `1` in `of`,
being nested inside of the first object,
is actually at depth two and should be treated accordingly.
To fix this, we proceed as before and do a sum *scan* across `of`,
with a subsequent stencil to make sure we only select the objects.

``` bqn
    +`of
‚ü® 1 1 2 ‚ü©
    on ‚Üê of √ó +`of  # Object nesting
‚ü® 1 0 2 ‚ü©
    on ‚Üê +`‚ä∏√ó of    # Object nesting (prettier!)
‚ü® 1 0 2 ‚ü©
```

Next, let's get the keys of each object and *group* them by depth,
as this will make subsequent processing much easier.
That is, given an input like `{"a": 1, "b": [1, "c", {"a": 2}]}`,
we want to end up with `‚ü®‚ü®"a", "b"‚ü©, ‚ü®"a"‚ü©‚ü©`.
Actually, since strings can be values as well,
we probably want to separate those, too,
ending up with an array of the form `‚ü®‚ü®"c"‚ü©, ‚ü®"a", "b"‚ü©, ‚ü®"a"‚ü©‚ü©`.

Selecting the keys themselves is easy:
just go to the colons,
*nudge* them to consider the token before,
and *replicate* from all strings.

``` bqn
    cl
‚ü® 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 ‚ü©
    ts DP ¬´cl
‚îå‚îÄ
‚ïµ"{':0,':[',0,{':0}]}
  0100010000000100000"
                      ‚îò
    ('"'=ts)/¬´cl
‚ü® 1 1 0 1 ‚ü©
```

A `0` stands for "this string is a value",
and a `1` is for "this string is a key somewhere".
We already have a nesting variable `n`,
which however also increases the depth when hitting an array instead of an object.
If we had one only for objects, we could use that as a stencil to obtain a depth ordered list when combining it with the above.

There's (at least) two things we can do:
re-create `n` but only take into consideration objects,
or somehow use `n`, but punch holes into it for the arrays.
The first way is straightforward and essentially just copies the definition of `n`:

``` bqn
    (‚çãd)‚äè+`td='{'
‚ü® 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 1 1 0 ‚ü©
    ts DP (‚çãd)‚äè+`td='{'
‚îå‚îÄ
‚ïµ"{':0,':[',0,{':0}]}
  1111111111112222110"
                      ‚îò
    (¬´cl)√ó (‚çãd)‚äè+`td='{'
‚ü® 0 1 0 0 0 1 0 0 0 0 0 0 0 2 0 0 0 0 0 ‚ü©
    ('"'=ts)/ (¬´cl)√ó (‚çãd)‚äè+`td='{'
‚ü® 1 1 0 2 ‚ü©
```

However, this seems quite inelegant to me;
thankfully, punching holes into `n` is not as hard as it sounds.
We already have an array `on` that tells us about the object nesting,
with a `0` standing in for "this is the start of an array".
That means if we simply use `n` to *select* from `on`,
this gives us what we want![^6]

``` bqn
    ts DP n
‚îå‚îÄ
‚ïµ"{':0,':[',0,{':0}]}
  1111111222223333210"
                      ‚îò
    n‚äè0‚àæon
‚ü® 1 1 1 1 1 1 1 0 0 0 0 0 2 2 2 2 0 1 0 ‚ü©
    ts DP n‚äè0‚àæon
‚îå‚îÄ
‚ïµ"{':0,':[',0,{':0}]}
  1111111000002222010"
                      ‚îò
    ('"'=ts) / (¬´cl)√ón‚äè0‚àæon
‚ü® 1 1 0 2 ‚ü©
```

All that's left is to *group* the given strings!

``` bqn
    (('"'=ts)/(¬´cl)√ón‚äè0‚àæon) ‚äî strs         # Keys
‚ü® ‚ü® "1" ‚ü© ‚ü® "a" "b" ‚ü© ‚ü® "a" ‚ü© ‚ü©
    (('"'=ts)/(¬´cl)√ó(‚çãd)‚äè+`td='{') ‚äî strs  # Same result
‚ü® ‚ü® "1" ‚ü© ‚ü® "a" "b" ‚ü© ‚ü® "a" ‚ü© ‚ü©
```

There is but a small wrinkle yet to fix:
if the object is empty, it might be that
``(('"'=ts)/(¬´cl)√ó(‚çãd)‚äè+`td='{')`` returns a nonsense answer,
which would yield an error when trying to *group* the strings.
This is much the same situation as before when we had to change `1-Àúln/l` to `(+¬¥c)‚àæÀú1-Àúln/l` during the construction of the final array.
The fix here is similar, since with `of` we have an obvious quantity, the *length* of which is always the length we want to end up with,[^15]
even when trying to parse `{}`.

``` bqn
    ks ‚Üê ((1+¬¥of)‚àæÀú ('"'=ts)/(¬´cl)√ón‚äè0‚àæon)‚äîstrs # Keys, final definition
‚ü® ‚ü® "1" ‚ü© ‚ü® "a" "b" ‚ü© ‚ü® "a" ‚ü© ‚ü©
```

Building up our initial list of values,
this now includes all numbers, as well as all strings that are not keys.
Conveniently, by the above argument the latter is exactly the first element of `ks`.

``` bqn
    vs ‚Üê nums ‚àæ ‚äëks # Initial values
‚ü® 1 2 2 "1" ‚ü©
```

Building up the value indices works exactly the same as before;
the only complication now is that a definition of `ln ‚Üê ts‚àä"""0]"` for literals and nesting does not work anymore, as we need to exclude the strings that are keys.
What seems to work best is to specify what `ln` should *not* be:
a comma, a colon, any opening parenthesis, and its token should not occur immediately before a colon.

``` bqn
    ln ‚Üê ¬¨ (¬´‚ä∏‚à®cl)‚à®o‚à®','=ts                       # Literals and nesting
‚ü® 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 ‚ü©
    vi ‚Üê ‚çã‚çã (ln/ts='0') + (2√óln/ts='"') + 3√óln/c  # Value indices
‚ü® 0 3 1 2 4 5 6 ‚ü©
    vi ‚äè‚Ü© (‚Üï‚â†vs)‚àæ(‚â†vs)+ ‚â†‚ä∏- c/¬ªn                  # Fix value indices
‚ü® 0 3 1 2 4 5 6 ‚ü©
```

Almost done‚Äîthe only thing left is to build up the finished, nested, array.
This is also the time we have to decide upon the final representation of an object.
What turns out to be quite convenient for small-ish JSON<!--
-->‚Äîwhich, let's be honest, will be the only kind of JSON that `Parse` ever gets to see‚Äî<!--
-->is to use *rank* 2 arrays;
an object `{"a": 1}` gets parsed into `2‚Äø1‚•ä"a"‚Äø1`.
Further, when building the result we have to make sure to "recognise" when to pull values and sublists out of the recursively built up `vs`,
and when to use `ks` to get keys instead.
This can be achieved by taking `on` into consideration:

``` bqn
    ‚åΩ((‚â†on)‚àæÀú1-Àúln/n)‚äîvi  # How to build which sublist
‚ü® ‚ü® 2 ‚ü© ‚ü® 3 1 4 ‚ü© ‚ü® 0 5 ‚ü© ‚ü©
    ‚åΩon                   # Which sublist is an object?
‚ü® 2 0 1 ‚ü©
    on ‚âç‚óã‚åΩ ((‚â†on)‚àæÀú1-Àúln/n)‚äîvi
‚îå‚îÄ
‚ïµ 2     0         1
  ‚ü® 2 ‚ü© ‚ü® 3 1 4 ‚ü© ‚ü® 0 5 ‚ü©
                         ‚îò
```

This means that the final shape is something like
`on BUILD¬®‚óã‚åΩ ((‚â†on)‚àæÀú1-Àúln/l)‚äîvi`,
where `BUILD` is a dyadic function,
taking as its left argument a number that's zero if we are dealing with a list or literal,
and bigger than zero if we have an object and want to select at least one key.
The right argument first *select*s the required sublist or value from `vs`,
and then refines this selection by picking possible keys out of `ks`.
Putting this into code:

``` bqn
    on {vs ‚àæ‚Ü© <ùï®Selùï©‚äèvs ‚ãÑ@}¬®‚óã‚åΩ ((‚â†on)‚àæÀú1-Àúln/l)‚äîvi # Build result
```

All that's left to do is to write `Sel`.
Doing nothing when `ùï®` is zero can just be achieved with a
[header](https://mlochbaum.github.io/BQN/doc/block.html#block-headers).
If `ùï®` is a number, it represents the depth of the object, and directly corresponds with the indexing of `ks`,
so we can just *pick* the result and *couple* it to `ùï©` to make things a *rank* 2 array.[^16]

``` bqn
    Sel ‚Üê {0ùïäx: x; iùïäx: (i‚äëks)‚âçx}  # Select
(function block)
    Sel ‚Üê ‚äë‚üúks‚ä∏‚âç‚çü(0<‚ä£)             # Point-free and without blocks
‚äë‚üú‚ü® ‚ü® "1" ‚ü© ‚ü® "a" "b" ‚ü© ‚ü® "a" ‚ü© ‚ü©‚ä∏‚âç‚çü(0<‚ä£)

# The object {"a": 2} is the first non-literal that's constructed.
    inp
"{""a"": 1, ""b"": [""1"",2,{""a"":2}]}"
    ‚åΩ((‚â†on)‚àæÀú1-Àúln/n)‚äîvi
‚ü® ‚ü® 2 ‚ü© ‚ü® 3 1 4 ‚ü© ‚ü® 0 5 ‚ü© ‚ü©
    ‚åΩon
‚ü® 2 0 1 ‚ü©
    vs
‚ü® 1 2 2 "1" ‚ü©
    2 Sel ‚ü®2‚ü©‚äèvs
‚îå‚îÄ
‚ïµ "a"
   2
      ‚îò
```

And that's pretty much it‚Äîhere are the last two lines, in all their glory:

``` bqn
    on {vs ‚àæ‚Ü© <ùï®Selùï©‚äèvs ‚ãÑ@}¬®‚óã‚åΩ ((‚â†on)‚àæÀú1-Àúln/n)‚äîvi  # Build result
"   "
    ¬Ø1‚äëvs                                           # Get result
‚îå‚îÄ
‚ïµ "a" "b"
   1   ‚îå‚îÄ
       ¬∑ "1" 2 ‚îå‚îÄ
               ‚ïµ "a"
                  2
                     ‚îò
                       ‚îò
                         ‚îò
    inp
"{""a"": 1, ""b"": [""1"",2,{""a"":2}]}"
```

It works!

---

At the risk of repeating myself, let's look at the entire parser as well as the tokeniser that we've built over the course of this post.

``` bqn
Tokenise ‚Üê {
  e  ‚Üê ¬ª<`'\'=ùï©                  # Escapes
  sb ‚Üê ¬ª‚ä∏< s‚Üê ‚â†`(¬¨e)‚àß '"'=ùï©      # String beginnings
  sr ‚Üê (1-Àú(s>sb)√ó+`sb)‚äîùï©        # Strings to return

  ex ‚Üê s‚à® ùï©‚àä@+9‚Äø10‚Äø13‚Äø32         # Exclude whitespace and strings
  nb ‚Üê ¬ª‚ä∏< n‚Üê (¬¨ex)‚àß ùï©‚àä'0'+‚Üï10   # Number beginnings
  nr ‚Üê ‚Ä¢ParseFloat¬®(1-Àún√ó+`nb)‚äîùï© # Numbers to return

  ts ‚Üê sb‚à®(¬¨ex)‚àßnb‚à®ùï©‚àä"[]{},:"    # Tokens
  ‚ü®ts/ '0'¬®‚åæ(nb‚ä∏/) ùï©, nr, sr‚ü©
}

Parse ‚Üê {
  ts‚Äønums‚Äøstrs ‚Üê Tokenise ùï©
  d  ‚Üê ‚çã+`(o‚Üêts‚àä"{[")-(c‚Üêts‚àä"]}") # Closing, opening, depth
  td ‚Üê d‚äèts                       # Tokens by depth
  s  ‚Üê td‚àä"[{"                    # Sublist starts
  n  ‚Üê (‚çãd)‚äè+`s                   # Nesting

  of ‚Üê s/'{'=td                   # Filter of subsists that are objects
  on ‚Üê +`‚ä∏√ó of                    # Object nesting
  cl ‚Üê ':'=ts                     # Colon
  ks ‚Üê ((1+¬¥of)‚àæÀú ('"'=ts)/(¬´cl)√ón‚äè0‚àæon)‚äîstrs    # Keys

  vs ‚Üê nums ‚àæ ‚äëks                 # Initial values
  ln ‚Üê ¬¨ (¬´‚ä∏‚à®cl)‚à®o‚à®','=ts         # Literals and nesting
  vi ‚Üê ‚çã‚çã (ln/ts='0') + (2√óln/ts='"') + 3√óln/c   # Value indices
  vi ‚äè‚Ü© (‚Üï‚â†vs)‚àæ(‚â†vs)+ ‚â†‚ä∏- c/¬ªn                   # Fix value indices

  Sel ‚Üê {(ùï®‚äëks)‚âçùï©}‚çü(0<‚ä£)          # Select
  on {vs ‚àæ‚Ü© <ùï®Selùï©‚äèvs ‚ãÑ@}¬®‚óã‚åΩ ((‚â†on)‚àæÀú1-Àúln/n)‚äîvi # Build result
  ¬Ø1‚äëvs
}
```

I don't know about you,
but I think it's pretty incredible that one can write a parser for a reasonable subset[^7] of JSON,
using what are essentially only flat arrays of numbers,
and still have it be this compact.

# Conclusion

I can probably offer the same conclusion as in the
[CSV post](https://tony-zorman.com/posts/bqn-csv.html):

> Q: Is writing (and reading) a parser in an array language unnecessarily hard? \
> A: Yes.
>
> Q: Is it the most fun I‚Äôve had programming in a long time? \
> A: Yes.

There's really something to be said about this style of writing parsers.
I hope I'm not butchering this,
but I believe that Marshall Lochbaum<!--
-->‚Äîthe creator of BQN‚Äî<!--
-->once said that it is
hard to write,
hard to read,
hard to modify,
but an absolute joy to debug,
and I would have to agree on all points.
Especially the debugging part, though:
since there's essentially no branching, control flow is trivial,
and furthermore everything is just a flat array of numbers.
Once that one `0` that should be a `1` is identified, going back to the source just involves reading backwards, with no logic to keep track of at all.

Interestingly, this feels quite different from ordinary array programming‚Äî<!--
-->especially the quite tricky task to give lots of names[^17] to lots of concepts.
Still, I suppose this is much more readable than if one tried to make the names go away by using combinators.
At least there are comments, right?

I certainly wouldn't write all‚Äîor even most‚Äîparsers in this style,
but honestly this whole thing was so refreshing that I can't help but recommend anyone to try at least getting the hang of a simplified form of one of the parsing libraries in [bqn-libs][bqn-libs].

[^1]: {-} Û†Ä†

      We could in fact also move *replicate*
      into the calls to `ns` and `ùï©`:

      ``` bqn
          '0'¬®‚åæ((ts/ns)‚ä∏/) (ts/inp)
      "[0,0,0,0,0]"
      ```

      I'm not super well-versed in the ins and outs of CBQN's performance,
      but from a cursory benchmark with the `‚Ä¢_timed` modifier,
      it does not seem to make much of a difference.

[^5]: {-} Û†Ä†

      You will see repeated definitions of `Tokenise` and `Parse` throughout this article.
      I figured that perhaps indicating changes in this way is more readable than giving you diffs,
      if only because all context one needs is right there.
      That's one of the advantages of the complete program fitting on a single screen!

[^6]: {-} Û†Ä†

      Û†Ä†

      Don't worry too much about having to use `0‚àæon` instead of `on` here;
      this appears because we are starting at depth zero before reading anything.
      Assuming well-formed JSON, this will appear only once at the very end.

[^7]: With a simple extension to the tokeniser to recognise the constants `true`, `false`, and `null`,
      this already parses the `cargo metadata` output of a few Rust crates that I've tried,
      which is the sort of data I would characterise as "ordinary JSON".
      The resulting representation is probably not super easy to work with<!--
      -->‚Äîthere's quite a lot of metadata and thus the nesting gets quite deep‚Äî<!--
      -->but still, it works.

[^8]: Although CBQN seems to have improved since then<!--
      -->‚Äîfor me, even the nested array version is faster than the recursive approach now.

[^9]: If you feel like I'm going too slow, or that I got something wrong, sorry!
      As I said, this is more or less my way of learning and better understanding this style of parsing;
      I am by no means the expert here.

[^10]: {-} Û†Ä†

       I will present many functions in a bottom-up kind of way,
       where I gradually build them up in the REPL,
       using an example input to showcase the behaviour of the individual array manipulations.
       Usually, proper definitions of `Tokenise` or `Parse` (the two functions we're building)
       will only be given at the very end of each section.
       The input is always indented by four spaces, with the output flush to the left.
       If I refer to an unknown variable further down, it was probably defined in such a block.

[^11]: {-} Û†Ä†

       Û†Ä†

       Û†Ä†

       Û†Ä†

       Û†Ä†

       Û†Ä†

       As you can see, an opening parenthesis is treated as being inside of the pair,
       while a closing one is outside.
       This is fine (even wanted) for this use-case;
       if you want to treat both pairs as being inside of the pair you can use
       ``+`o-¬ªc``.

[^12]: A questionable API choice, for sure, but I'll take it!

[^13]: {-} The double quotes `""` in the string are BQN's way of escaping quotes
       (the same way that CSV does it).
       *Everything* else is treated as a literal characters, even backslashes!

[^14]: I will use this as shorthand for "sub-object and sub-array".
       Not the best terminology, I suppose, but it will have to do.

[^15]: Remember that questionable *group* API?

[^16]: {-} Û†Ä†

       I find this process of treating values and keys separately,
       but in a way that they eventually match up at the end,
       almost magical.

[^17]: Short names at that, otherwise things just look too cumbersome in this style of programming.

[bqn-libs:json]: https://github.com/mlochbaum/bqn-libs/blob/master/json.bqn
[bqn-libs]: https://github.com/mlochbaum/bqn-libs
